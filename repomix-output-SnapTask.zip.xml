This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore/
  .gitignore
Extensions/
  Color+Hex.swift/
    Color+Hex.swift
  Date+Utilities.swift/
    Date+Utilities.swift
  TaskManagerExtension.swift/
    TaskManagerExtension.swift
  WatchConnectivityManager.swift/
    WatchConnectivityManager.swift
README.md/
  README.md
SnapTask/
  App/
    SnapTaskApp.swift/
      SnapTaskApp.swift
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json/
        Contents.json
    AppIcon.appiconset/
      Contents.json/
        Contents.json
    Contents.json/
      Contents.json
  Core/
    Timer/
      TimerViewModel.swift/
        TimerViewModel.swift
  Extensions/
    Color+Extensions.swift/
      Color+Extensions.swift
    Color+Hex.swift/
      Color+Hex.swift
    Date+Extensions.swift/
      Date+Extensions.swift
    TimeInterval+Formatting.swift/
      TimeInterval+Formatting.swift
    View+CornerRadius.swift/
      View+CornerRadius.swift
    WatchConnectivityManager.swift/
      WatchConnectivityManager.swift
  Managers/
    CategoryManager.swift/
      CategoryManager.swift
    LanguageManager.swift/
      LanguageManager.swift
    QuoteManager.swift/
      QuoteManager.swift
  Models/
    Category.swift/
      Category.swift
    FocusMode.swift/
      FocusMode.swift
    FocusSettings.swift/
      FocusSettings.swift
    PomodoroSettings.swift/
      PomodoroSettings.swift
    Priority.swift/
      Priority.swift
    Quote.swift/
      Quote.swift
    Recurrence.swift/
      Recurrence.swift
    Subtask.swift/
      Subtask.swift
    TaskCompletion.swift/
      TaskCompletion.swift
    TaskManager.swift/
      TaskManager.swift
    TodoTask.swift/
      TodoTask.swift
  Preview Content/
    Preview Assets.xcassets/
      Contents.json/
        Contents.json
  Resources/
    en.lproj/
      Localizable.strings/
        Localizable.strings
    it.lproj/
      Localizable.strings/
        Localizable.strings
  Services/
    CloudKitService.swift/
      CloudKitService.swift
    CloudKitSyncProxy.swift/
      CloudKitSyncProxy.swift
    QuoteService.swift/
      QuoteService.swift
  SnapTask.entitlements/
    SnapTask.entitlements
  UI/
    Components/
      StatView.swift/
        StatView.swift
      TimerProgressView.swift/
        TimerProgressView.swift
  Utils/
    HapticManager.swift/
      HapticManager.swift
  ViewModels/
    BiohackingViewModel.swift/
      BiohackingViewModel.swift
    FocusViewModel.swift/
      FocusViewModel.swift
    PomodoroViewModel.swift/
      PomodoroViewModel.swift
    QuoteViewModel.swift/
      QuoteViewModel.swift
    SettingsViewModel.swift/
      SettingsViewModel.swift
    StatisticsViewModel.swift/
      StatisticsViewModel.swift
    StatsViewModel.swift/
      StatsViewModel.swift
    TaskFormViewModel.swift/
      TaskFormViewModel.swift
    TaskViewModel.swift/
      TaskViewModel.swift
    TimelineViewModel.swift/
      TimelineViewModel.swift
  Views/
    BiohackingView.swift/
      BiohackingView.swift
    CategoriesView.swift/
      CategoriesView.swift
    CategoryEditorView.swift/
      CategoryEditorView.swift
    CategoryFormView.swift/
      CategoryFormView.swift
    CategoryPickerView.swift/
      CategoryPickerView.swift
    CategoryRow.swift/
      CategoryRow.swift
    Components/
      CloudSyncStatusView.swift/
        CloudSyncStatusView.swift
      ColorPickerGrid.swift/
        ColorPickerGrid.swift
      SubtaskCheckmark.swift/
        SubtaskCheckmark.swift
    ContentView.swift/
      ContentView.swift
    DayPickerView.swift/
      DayPickerView.swift
    DueTasksView.swift/
      DueTasksView.swift
    DurationPickerView.swift/
      DurationPickerView.swift
    FocusTabView.swift/
      FocusTabView.swift
    IconPickerView.swift/
      IconPickerView.swift
    MonthDayPicker.swift/
      MonthDayPicker.swift
    MotivationalQuoteView.swift/
      MotivationalQuoteView.swift
    PomodoroSettingsView.swift/
      PomodoroSettingsView.swift
    PomodoroTabView.swift/
      PomodoroTabView.swift
    PomodoroView.swift/
      PomodoroView.swift
    RecurrenceSettingsView.swift/
      RecurrenceSettingsView.swift
    SettingsView.swift/
      SettingsView.swift
    Statistics/
      TaskConsistencyView.swift/
        TaskConsistencyView.swift
    StatisticsView.swift/
      StatisticsView.swift
    StatsView.swift/
      StatsView.swift
    TaskCard.swift/
      TaskCard.swift
    TaskDetailView.swift/
      TaskDetailView.swift
    TaskFormView.swift/
      TaskFormView.swift
    TaskRow.swift/
      TaskRow.swift
    TaskRowView.swift/
      TaskRowView.swift
    TaskView.swift/
      TaskView.swift
    TimelineView.swift/
      TimelineView.swift
    WeekdayPicker.swift/
      WeekdayPicker.swift
SnapTask Watch App Watch App/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json/
        Contents.json
    AppIcon.appiconset/
      Contents.json/
        Contents.json
    Contents.json/
      Contents.json
  CloudKitService.swift/
    CloudKitService.swift
  ContentView.swift/
    ContentView.swift
  Info.plist/
    Info.plist
  Models/
    Category.swift/
      Category.swift
    PomodoroSettings.swift/
      PomodoroSettings.swift
    Priority.swift/
      Priority.swift
    Quote.swift/
      Quote.swift
    Recurrence.swift/
      Recurrence.swift
    RecurrenceExtension.swift/
      RecurrenceExtension.swift
    Subtask.swift/
      Subtask.swift
    TaskCompletion.swift/
      TaskCompletion.swift
    TaskManager.swift/
      TaskManager.swift
    TaskManagerExtension.swift/
      TaskManagerExtension.swift
    TodoTask.swift/
      TodoTask.swift
  QuoteManager.swift/
    QuoteManager.swift
  SnapTask Watch App Watch App.entitlements/
    SnapTask Watch App Watch App.entitlements
  SnapTaskWatchApp.swift/
    SnapTaskWatchApp.swift
  ViewModels/
    SettingsViewModel.swift/
      SettingsViewModel.swift
    StatisticsViewModel.swift/
      StatisticsViewModel.swift
    TaskFormViewModel.swift/
      TaskFormViewModel.swift
    TimelineViewModel.swift/
      TimelineViewModel.swift
  Views/
    CreateTaskView.swift/
      CreateTaskView.swift
    PomodoroListView.swift/
      PomodoroListView.swift
    QuickStatsView.swift/
      QuickStatsView.swift
    SettingsWatchView.swift/
      SettingsWatchView.swift
    TaskListView.swift/
      TaskListView.swift
    TimelineWatchView.swift/
      TimelineWatchView.swift
    WatchPomodoroView.swift/
      WatchPomodoroView.swift
    WatchStatisticsView.swift/
      WatchStatisticsView.swift
    WatchTaskDetailView.swift/
      WatchTaskDetailView.swift
    WatchTaskFormView.swift/
      WatchTaskFormView.swift
  WatchConnectivityManager.swift/
    WatchConnectivityManager.swift
SnapTask Watch App Watch AppTests/
  SnapTask_Watch_App_Watch_AppTests.swift/
    SnapTask_Watch_App_Watch_AppTests.swift
SnapTask Watch App Watch AppUITests/
  SnapTask_Watch_App_Watch_AppUITests.swift/
    SnapTask_Watch_App_Watch_AppUITests.swift
  SnapTask_Watch_App_Watch_AppUITestsLaunchTests.swift/
    SnapTask_Watch_App_Watch_AppUITestsLaunchTests.swift
SnapTask.xcodeproj/
  project.pbxproj/
    project.pbxproj
  project.xcworkspace/
    contents.xcworkspacedata/
      contents.xcworkspacedata
    xcshareddata/
      WorkspaceSettings.xcsettings/
        WorkspaceSettings.xcsettings
  xcuserdata/
    giovanni.xcuserdatad/
      xcschemes/
        xcschememanagement.plist/
          xcschememanagement.plist
    giovanniamadei.xcuserdatad/
      xcschemes/
        xcschememanagement.plist/
          xcschememanagement.plist
SnapTaskTests/
  SnapTaskTests.swift/
    SnapTaskTests.swift
SnapTaskUITests/
  SnapTaskUITests.swift/
    SnapTaskUITests.swift
  SnapTaskUITestsLaunchTests.swift/
    SnapTaskUITestsLaunchTests.swift
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore/.gitignore">
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accidental Mac files
.DS_Store

# Accidental temp files
*.swp
*~
</file>

<file path="Extensions/Color+Hex.swift/Color+Hex.swift">
import SwiftUI

extension Color {
    init?(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        var r: CGFloat = 0.0
        var g: CGFloat = 0.0
        var b: CGFloat = 0.0
        var a: CGFloat = 1.0
        
        let length = hexSanitized.count
        guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }
        
        if length == 6 {
            r = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
            g = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
            b = CGFloat(rgb & 0x0000FF) / 255.0
        } else if length == 8 {
            r = CGFloat((rgb & 0xFF000000) >> 24) / 255.0
            g = CGFloat((rgb & 0x00FF0000) >> 16) / 255.0
            b = CGFloat((rgb & 0x0000FF00) >> 8) / 255.0
            a = CGFloat(rgb & 0x000000FF) / 255.0
        } else {
            return nil
        }
        
        self.init(red: r, green: g, blue: b, opacity: a)
    }
    
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        return String(
            format: "#%02lX%02lX%02lX",
            lroundf(r * 255),
            lroundf(g * 255),
            lroundf(b * 255)
        )
    }
}
</file>

<file path="Extensions/Date+Utilities.swift/Date+Utilities.swift">
import Foundation

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}
</file>

<file path="Extensions/TaskManagerExtension.swift/TaskManagerExtension.swift">
import Foundation

extension TaskManager {
    // Esta función debe llamarse después de cada operación que modifique las tareas
    func synchronizeWithWatch() {
        WatchConnectivityManager.shared.updateWatchContext()
    }
}
</file>

<file path="Extensions/WatchConnectivityManager.swift/WatchConnectivityManager.swift">
import Foundation
import WatchConnectivity

class WatchConnectivityManager: NSObject, ObservableObject {
    static let shared = WatchConnectivityManager()
    
    private let session = WCSession.default
    @Published var isReachable = false
    
    private override init() {
        super.init()
        
        if WCSession.isSupported() {
            session.delegate = self
            session.activate()
        }
    }
    
    func sendTasksToWatch(tasks: [TodoTask]) {
        guard session.activationState == .activated, session.isReachable else {
            print("Watch is not reachable")
            return
        }
        
        do {
            let data = try JSONEncoder().encode(tasks)
            session.sendMessageData(data, replyHandler: nil) { error in
                print("Error sending tasks to Watch: \(error.localizedDescription)")
            }
        } catch {
            print("Error encoding tasks: \(error.localizedDescription)")
        }
    }
    
    func sendTaskToWatch(task: TodoTask) {
        guard session.activationState == .activated, session.isReachable else {
            print("Watch is not reachable")
            return
        }
        
        do {
            let taskData = try JSONEncoder().encode(task)
            let message: [String: Any] = [
                "type": "taskUpdate",
                "task": taskData
            ]
            
            session.sendMessage(message, replyHandler: nil) { error in
                print("Error sending task to Watch: \(error.localizedDescription)")
            }
        } catch {
            print("Error encoding task: \(error.localizedDescription)")
        }
    }
    
    func updateWatchContext() {
        guard session.activationState == .activated else {
            return
        }
        
        do {
            let tasks = TaskManager.shared.tasks
            let tasksData = try JSONEncoder().encode(tasks)
            
            let contextInfo: [String: Any] = [
                "tasksUpdated": Date().timeIntervalSince1970,
                "tasksCount": tasks.count
            ]
            
            session.transferUserInfo(contextInfo)
            
            // Si el reloj está alcanzable, envía las tareas directamente
            if session.isReachable {
                sendTasksToWatch(tasks: tasks)
            }
        } catch {
            print("Error updating watch context: \(error.localizedDescription)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        DispatchQueue.main.async {
            self.isReachable = session.isReachable
        }
    }
    
    func sessionDidBecomeInactive(_ session: WCSession) {
        // Necesario para iOS
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        // Necesario para iOS, reactivar la sesión
        session.activate()
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        DispatchQueue.main.async {
            self.isReachable = session.isReachable
            
            // Si el reloj acaba de volverse alcanzable, actualiza su contexto
            if session.isReachable {
                self.updateWatchContext()
            }
        }
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        if let type = message["type"] as? String {
            switch type {
            case "requestTasks":
                // El reloj solicitó tareas, envíalas
                do {
                    let tasks = TaskManager.shared.tasks
                    let tasksData = try JSONEncoder().encode(tasks)
                    replyHandler(["tasks": tasksData])
                } catch {
                    print("Error encoding tasks for watch: \(error.localizedDescription)")
                    replyHandler([:])
                }
                
            case "taskCompletion":
                // El reloj informó una actualización de finalización de tarea
                if let taskIdString = message["taskId"] as? String,
                   let taskId = UUID(uuidString: taskIdString),
                   let isCompleted = message["isCompleted"] as? Bool,
                   let dateValue = message["date"] as? TimeInterval {
                    
                    let date = Date(timeIntervalSince1970: dateValue)
                    
                    DispatchQueue.main.async {
                        TaskManager.shared.toggleTaskCompletion(taskId, on: date)
                    }
                    
                    replyHandler(["success": true])
                } else {
                    replyHandler(["success": false])
                }
                
            default:
                replyHandler([:])
            }
        } else {
            replyHandler([:])
        }
    }
}
</file>

<file path="README.md/README.md">
# SnapTask: Gestor de Tareas con Apple Watch

SnapTask es una aplicación completa de gestión de tareas con funcionalidades de temporizador Pomodoro, seguimiento de hábitos y estadísticas. Ahora incluye una app para Apple Watch que permite sincronizar y gestionar tareas desde la muñeca.

## Características

### Aplicación iOS
- Gestión de tareas con planificación diaria
- Temporizador Pomodoro integrado
- Sistema de seguimiento de hábitos recurrentes
- Estadísticas detalladas de productividad
- Categorización de tareas con iconos y colores
- Modo oscuro/claro
- Citas motivacionales

### Aplicación watchOS
- Visualización de tareas programadas para hoy
- Marcado de tareas como completadas
- Temporizador Pomodoro para tareas
- Vista rápida de estadísticas
- Sincronización bidireccional con la app de iOS

## Estructura del Proyecto

### Aplicación iOS (SnapTask/)
- **App/**: Punto de entrada de la aplicación
- **Models/**: Modelos de datos (TodoTask, TaskManager, etc.)
- **Views/**: Interfaces de usuario
- **ViewModels/**: Lógica de las vistas
- **Core/**: Componentes centrales como el temporizador
- **Extensions/**: Extensiones de tipos existentes
- **Services/**: Servicios como sincronización y notificaciones
- **Resources/**: Recursos localizados
- **Assets.xcassets/**: Recursos gráficos

### Aplicación watchOS (SnapTask Watch App/)
- **Models/**: Extensiones de modelos compartidos
- **Views/**: Interfaces de usuario específicas para watchOS
- **ViewModels/**: Lógica específica para watchOS
- **Assets.xcassets/**: Recursos gráficos para watch

## Sincronización iOS-watchOS

Las aplicaciones se sincronizan mediante el framework WatchConnectivity. Cuando ocurren cambios en iOS, estos se propagan automáticamente al Apple Watch. De igual manera, las acciones realizadas en el Apple Watch (como completar una tarea) se reflejan en la app de iOS.

## Configuración del Proyecto

Para configurar el proyecto correctamente, consulta el archivo `WATCH_INTEGRATION_GUIDE.md` que contiene instrucciones detalladas sobre cómo integrar la app de watchOS al proyecto Xcode.

## Requisitos

- iOS 16.0 o posterior
- watchOS 9.0 o posterior
- Xcode 15.0 o posterior

## Instalación

1. Clona este repositorio
2. Abre `SnapTask.xcodeproj` en Xcode
3. Configura los signing certificates para los targets de iOS y watchOS
4. Ejecuta la aplicación en un dispositivo o simulador

## Contacto

Para preguntas o sugerencias, por favor abrir un issue en este repositorio.
</file>

<file path="SnapTask/App/SnapTaskApp.swift/SnapTaskApp.swift">
import SwiftUI
import WatchConnectivity
import CloudKit
import UserNotifications

@main
struct SnapTaskApp: App {
    @StateObject private var quoteManager = QuoteManager.shared
    @StateObject private var taskManager = TaskManager.shared
    @StateObject private var connectivityManager = WatchConnectivityManager.shared
    @StateObject private var cloudKitService = CloudKitService.shared
    @Environment(\.scenePhase) var scenePhase
    @AppStorage("isDarkMode") private var isDarkMode = false
    
    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appDelegate
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .preferredColorScheme(isDarkMode ? .dark : .light)
                .onAppear {
                    Task {
                        await quoteManager.checkAndUpdateQuote()
                    }
                    
                    registerForRemoteNotifications()
                    
                    // COMMENTIAMO TEMPORANEAMENTE CLOUDKIT
                    // CloudKitSyncProxy.shared.setupCloudKit()
                    // CloudKitSyncProxy.shared.syncTasks()
                    
                    connectivityManager.updateWatchContext()
                }
                .onChange(of: scenePhase) { _, newPhase in
                    if newPhase == .active {
                        Task {
                            await quoteManager.checkAndUpdateQuote()
                        }
                        
                        // COMMENTIAMO TEMPORANEAMENTE CLOUDKIT
                        // CloudKitSyncProxy.shared.syncTasks()
                        
                        connectivityManager.updateWatchContext()
                    }
                }
        }
    }
    
    func registerForRemoteNotifications() {
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in
            if granted {
                DispatchQueue.main.async {
                    UIApplication.shared.registerForRemoteNotifications()
                }
            }
        }
    }
    
    func initializeCloudKit() throws {
        // COMMENTIAMO TEMPORANEAMENTE CLOUDKIT
        // CloudKitSyncProxy.shared.setupCloudKit()
        // CloudKitSyncProxy.shared.syncTasks()
    }
}

// MARK: - UIApplicationDelegate
class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
        if let cloudKitDict = userInfo as? [String: NSObject],
           let cloudKitNotification = CKNotification(fromRemoteNotificationDictionary: cloudKitDict) {
            if cloudKitNotification.subscriptionID == "SnapTaskZone" {
                // COMMENTIAMO TEMPORANEAMENTE CLOUDKIT
                // CloudKitSyncProxy.shared.syncTasks()
                completionHandler(.newData)
                return
            }
        }
        completionHandler(.noData)
    }
}
</file>

<file path="SnapTask/Assets.xcassets/AccentColor.colorset/Contents.json/Contents.json">
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask/Assets.xcassets/AppIcon.appiconset/Contents.json/Contents.json">
{
  "images" : [
    {
      "filename" : "icon.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "filename" : "icon 1.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "tinted"
        }
      ],
      "filename" : "icon 2.jpg",
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask/Assets.xcassets/Contents.json/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask/Core/Timer/TimerViewModel.swift/TimerViewModel.swift">
import Combine
import Foundation

@MainActor
protocol TimerViewModel: ObservableObject {
    associatedtype State: Equatable
    var timeRemaining: TimeInterval { get set }
    var progress: Double { get }
    var state: State { get set }
    
    func start()
    func pause()
    func reset()
}

@MainActor
extension TimerViewModel {
    func formatTime(_ interval: TimeInterval) -> String {
        let minutes = Int(interval) / 60
        let seconds = Int(interval) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}
</file>

<file path="SnapTask/Extensions/Color+Extensions.swift/Color+Extensions.swift">
import SwiftUI

extension Color {
    init(hex: String) {
        var cleanHex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        if cleanHex.hasPrefix("#") {
            cleanHex = String(cleanHex.dropFirst())
        }
        
        var rgb: UInt64 = 0
        Scanner(string: cleanHex).scanHexInt64(&rgb)
        
        let r = Double((rgb >> 16) & 0xFF) / 255.0
        let g = Double((rgb >> 8) & 0xFF) / 255.0
        let b = Double(rgb & 0xFF) / 255.0
        
        self.init(red: r, green: g, blue: b)
    }
    
    func toHex() -> String {
        let uiColor = UIColor(self)
        var red: CGFloat = 0
        var green: CGFloat = 0
        var blue: CGFloat = 0
        var alpha: CGFloat = 0
        
        uiColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        
        return String(
            format: "#%02X%02X%02X",
            Int(red * 255),
            Int(green * 255),
            Int(blue * 255)
        )
    }
}
</file>

<file path="SnapTask/Extensions/Color+Hex.swift/Color+Hex.swift">
import SwiftUI

extension Color {
    func toHex() -> String? {
        guard let components = UIColor(self).cgColor.components else { return nil }
        
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        return String(format: "#%02lX%02lX%02lX",
                     lroundf(r * 255),
                     lroundf(g * 255),
                     lroundf(b * 255))
    }
}
</file>

<file path="SnapTask/Extensions/Date+Extensions.swift/Date+Extensions.swift">
import Foundation

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}
</file>

<file path="SnapTask/Extensions/TimeInterval+Formatting.swift/TimeInterval+Formatting.swift">
import Foundation

extension TimeInterval {
    func formatted() -> String {
        let hours = Int(self) / 3600
        let minutes = Int(self) / 60 % 60
        
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        } else {
            return "\(minutes)m"
        }
    }
}
</file>

<file path="SnapTask/Extensions/View+CornerRadius.swift/View+CornerRadius.swift">
import SwiftUI

extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}
</file>

<file path="SnapTask/Extensions/WatchConnectivityManager.swift/WatchConnectivityManager.swift">
import Foundation
import WatchConnectivity

class WatchConnectivityManager: NSObject, ObservableObject {
    static let shared = WatchConnectivityManager()
    
    private let session = WCSession.default
    @Published var isReachable = false
    
    private override init() {
        super.init()
        
        if WCSession.isSupported() {
            session.delegate = self
            session.activate()
        }
    }
    
    func sendTasksToWatch(tasks: [TodoTask]) {
        guard session.activationState == .activated, session.isReachable else {
            print("Watch is not reachable")
            return
        }
        
        do {
            let data = try JSONEncoder().encode(tasks)
            session.sendMessageData(data, replyHandler: nil) { error in
                print("Error sending tasks to Watch: \(error.localizedDescription)")
            }
        } catch {
            print("Error encoding tasks: \(error.localizedDescription)")
        }
    }
    
    func sendTaskToWatch(task: TodoTask) {
        guard session.activationState == .activated, session.isReachable else {
            print("Watch is not reachable")
            return
        }
        
        do {
            let taskData = try JSONEncoder().encode(task)
            let message: [String: Any] = [
                "type": "taskUpdate",
                "task": taskData
            ]
            
            session.sendMessage(message, replyHandler: nil) { error in
                print("Error sending task to Watch: \(error.localizedDescription)")
            }
        } catch {
            print("Error encoding task: \(error.localizedDescription)")
        }
    }
    
    func updateWatchContext() {
        guard session.activationState == .activated else {
            return
        }
        
        do {
            let tasks = TaskManager.shared.tasks
            let tasksData = try JSONEncoder().encode(tasks)
            
            let contextInfo: [String: Any] = [
                "tasksUpdated": Date().timeIntervalSince1970,
                "tasksCount": tasks.count
            ]
            
            session.transferUserInfo(contextInfo)
            
            // Si el reloj está alcanzable, envía las tareas directamente
            if session.isReachable {
                sendTasksToWatch(tasks: tasks)
            }
        } catch {
            print("Error updating watch context: \(error.localizedDescription)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        DispatchQueue.main.async {
            self.isReachable = session.isReachable
        }
    }
    
    func sessionDidBecomeInactive(_ session: WCSession) {
        // Necesario para iOS
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        // Necesario para iOS, reactivar la sesión
        session.activate()
    }
    
    func sessionReachabilityDidChange(_ session: WCSession) {
        DispatchQueue.main.async {
            self.isReachable = session.isReachable
            
            // Si el reloj acaba de volverse alcanzable, actualiza su contexto
            if session.isReachable {
                self.updateWatchContext()
            }
        }
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any], replyHandler: @escaping ([String : Any]) -> Void) {
        if let type = message["type"] as? String {
            switch type {
            case "requestTasks":
                // El reloj solicitó tareas, envíalas
                do {
                    let tasks = TaskManager.shared.tasks
                    let tasksData = try JSONEncoder().encode(tasks)
                    replyHandler(["tasks": tasksData])
                } catch {
                    print("Error encoding tasks for watch: \(error.localizedDescription)")
                    replyHandler([:])
                }
                
            case "taskCompletion":
                // El reloj informó una actualización de finalización de tarea
                if let taskIdString = message["taskId"] as? String,
                   let taskId = UUID(uuidString: taskIdString),
                   let isCompleted = message["isCompleted"] as? Bool,
                   let dateValue = message["date"] as? TimeInterval {
                    
                    let date = Date(timeIntervalSince1970: dateValue)
                    
                    DispatchQueue.main.async {
                        TaskManager.shared.toggleTaskCompletion(taskId, on: date)
                    }
                    
                    replyHandler(["success": true])
                } else {
                    replyHandler(["success": false])
                }
                
            default:
                replyHandler([:])
            }
        } else {
            replyHandler([:])
        }
    }
}
</file>

<file path="SnapTask/Managers/CategoryManager.swift/CategoryManager.swift">
import Foundation
import Combine

class CategoryManager: ObservableObject {
    static let shared = CategoryManager()
    
    @Published private(set) var categories: [Category] = []
    private let categoriesKey = "savedCategories"
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        loadCategories()
        setupNotifications()
    }
    
    func updateCategory(_ category: Category) {
        if let index = categories.firstIndex(where: { $0.id == category.id }) {
            categories[index] = category
        } else {
            categories.append(category)
        }
        saveCategories()
        notifyCategoryUpdates()
    }
    
    func deleteCategory(_ category: Category) {
        categories.removeAll { $0.id == category.id }
        saveCategories()
        notifyCategoryUpdates()
    }
    
    func clearAllData() {
        categories = []
        UserDefaults.standard.removeObject(forKey: categoriesKey)
        UserDefaults.standard.synchronize()
        notifyCategoryUpdates()
    }
    
    private func loadCategories() {
        var shouldAddDefaults = true
        
        if let data = UserDefaults.standard.data(forKey: categoriesKey),
           let decoded = try? JSONDecoder().decode([Category].self, from: data) {
            categories = decoded
            // Check if we have the default categories
            let defaultNames = ["Work", "Personal Care", "Leisure"]
            shouldAddDefaults = categories.filter { defaultNames.contains($0.name) }.count != defaultNames.count
        }
        
        if shouldAddDefaults {
            addDefaultCategories()
        }
    }
    
    private func saveCategories() {
        if let encoded = try? JSONEncoder().encode(categories) {
            UserDefaults.standard.set(encoded, forKey: categoriesKey)
            UserDefaults.standard.synchronize() // Ensure changes are saved immediately
            notifyCategoryUpdates()
        }
    }
    
    private func notifyCategoryUpdates() {
        NotificationCenter.default.post(name: .categoriesDidUpdate, object: nil)
        objectWillChange.send()
    }
    
    private func setupNotifications() {
        NotificationCenter.default.publisher(for: .categoriesDidUpdate)
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
            
        // Add observer for UserDefaults changes
        NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification)
            .sink { [weak self] _ in
                self?.loadCategories()
            }
            .store(in: &cancellables)
    }
    
    private func addDefaultCategories() {
        let defaultCategories = [
            Category(id: UUID(), name: "Work", color: "#E74C3C"),        // Rosso più piacevole
            Category(id: UUID(), name: "Personal Care", color: "#2ECC71"), // Verde più piacevole
            Category(id: UUID(), name: "Leisure", color: "#3498DB")      // Blu più piacevole
        ]
        
        // Merge with existing categories, keeping any custom ones
        let existingCustomCategories = categories.filter { category in
            !defaultCategories.contains { $0.name == category.name }
        }
        
        categories = defaultCategories + existingCustomCategories
        saveCategories()
    }
}

extension Notification.Name {
    static let categoriesDidUpdate = Notification.Name("categoriesDidUpdate")
}
</file>

<file path="SnapTask/Managers/LanguageManager.swift/LanguageManager.swift">
import Foundation
import SwiftUI

class LanguageManager: ObservableObject {
    static let shared = LanguageManager()
    
    @AppStorage("selectedLanguage") private var selectedLanguageCode: String = Locale.current.language.languageCode?.identifier ?? "en"
    @Published var availableLanguages: [Language] = [
        Language(code: "en", name: "English"),
        Language(code: "it", name: "Italiano")
    ]
    
    var currentLanguage: Language {
        availableLanguages.first { $0.code == selectedLanguageCode } ?? availableLanguages[0]
    }
    
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(languageDidChange),
            name: NSNotification.Name("AppleLanguagesDidChange"),
            object: nil
        )
    }
    
    @objc private func languageDidChange() {
        objectWillChange.send()
    }
    
    func setLanguage(_ languageCode: String) {
        guard availableLanguages.contains(where: { $0.code == languageCode }) else { return }
        
        selectedLanguageCode = languageCode
        UserDefaults.standard.set([languageCode], forKey: "AppleLanguages")
        UserDefaults.standard.synchronize()
        
        // Notifica il cambiamento
        NotificationCenter.default.post(name: NSNotification.Name("AppleLanguagesDidChange"), object: nil)
    }
}

struct Language: Identifiable, Equatable {
    let id = UUID()
    let code: String // e.g., "en", "it"
    let name: String // e.g., "English", "Italiano"
    
    static func == (lhs: Language, rhs: Language) -> Bool {
        lhs.code == rhs.code
    }
}

// Extension for String localization that reacts to language changes dynamically
extension String {
    var localized: String {
        let bundle = Bundle.main
        let languageCode = LanguageManager.shared.currentLanguage.code
        
        // First try to get the string from a specific resource bundle
        if let path = bundle.path(forResource: languageCode, ofType: "lproj"),
           let langBundle = Bundle(path: path) {
            return NSLocalizedString(self, bundle: langBundle, comment: "")
        }
        
        // Fallback to default localization
        return NSLocalizedString(self, comment: "")
    }
}
</file>

<file path="SnapTask/Managers/QuoteManager.swift/QuoteManager.swift">
import Foundation
import SwiftUI
import Combine

class QuoteManager: ObservableObject {
    static let shared = QuoteManager()
    
    @Published private(set) var currentQuote: SnapTask.Quote
    @Published private(set) var isLoading = false
    private let service = QuoteService.shared
    
    private let lastUpdateDateKey = "lastQuoteUpdateDate"
    private let currentQuoteKey = "currentQuote"
    
    // Collection of fallback motivational quotes
    private let fallbackQuotes: [SnapTask.Quote] = [
        SnapTask.Quote(text: "The only way to do great work is to love what you do.", author: "Steve Jobs"),
        SnapTask.Quote(text: "Success is not final, failure is not fatal: It is the courage to continue that counts.", author: "Winston Churchill"),
        SnapTask.Quote(text: "Believe you can and you're halfway there.", author: "Theodore Roosevelt"),
        SnapTask.Quote(text: "Your time is limited, don't waste it living someone else's life.", author: "Steve Jobs"),
        SnapTask.Quote(text: "The future belongs to those who believe in the beauty of their dreams.", author: "Eleanor Roosevelt"),
        SnapTask.Quote(text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius"),
        SnapTask.Quote(text: "Don't watch the clock; do what it does. Keep going.", author: "Sam Levenson"),
        SnapTask.Quote(text: "The only limit to our realization of tomorrow is our doubts of today.", author: "Franklin D. Roosevelt"),
        SnapTask.Quote(text: "The way to get started is to quit talking and begin doing.", author: "Walt Disney"),
        SnapTask.Quote(text: "If you're going through hell, keep going.", author: "Winston Churchill")
    ]
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // Initialize with placeholder first
        self.currentQuote = SnapTask.Quote.placeholder
        
        // Then try to load saved quote
        if let savedQuote = loadSavedQuote() {
            self.currentQuote = savedQuote
        }
        
        // Check if we need to update the quote
        // Task {
        //     await checkAndUpdateQuote()
        // }
        
        // Set up a timer to refresh the quote daily
        // Timer.publish(every: 86400, on: .main, in: .common)
        //     .autoconnect()
        //     .sink { [weak self] _ in
        //         Task { [weak self] in
        //             await self?.checkAndUpdateQuote()
        //         }
        //     }
        //     .store(in: &cancellables)
    }
    
    @MainActor
    func checkAndUpdateQuote() async {
        // Only update if we haven't updated today
        guard shouldUpdateQuote() else { return }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let quote = try await service.fetchDailyQuote()
            currentQuote = quote
            saveCurrentQuote()
            updateLastUpdateDate()
        } catch {
            print("Error fetching quote: \(error)")
            // If there's an error, use a random fallback quote
            currentQuote = fallbackQuotes.randomElement() ?? SnapTask.Quote.placeholder
            saveCurrentQuote()
            updateLastUpdateDate()
        }
    }
    
    private func shouldUpdateQuote() -> Bool {
        guard let lastUpdate = UserDefaults.standard.object(forKey: lastUpdateDateKey) as? Date else {
            return true
        }
        return !Calendar.current.isDate(lastUpdate, inSameDayAs: Date())
    }
    
    private func updateLastUpdateDate() {
        UserDefaults.standard.set(Date(), forKey: lastUpdateDateKey)
    }
    
    private func saveCurrentQuote() {
        if let encoded = try? JSONEncoder().encode(currentQuote) {
            UserDefaults.standard.set(encoded, forKey: currentQuoteKey)
        }
    }
    
    private func loadSavedQuote() -> SnapTask.Quote? {
        guard let data = UserDefaults.standard.data(forKey: currentQuoteKey),
              let quote = try? JSONDecoder().decode(SnapTask.Quote.self, from: data) else {
            return nil
        }
        return quote
    }
    
    func refreshQuote() {
        Task {
            await checkAndUpdateQuote()
        }
    }
    
    @MainActor
    func forceUpdateQuote() async {
        // Notifichiamo che stiamo caricando
        isLoading = true
        
        do {
            // Tentiamo di ottenere una nuova citazione dall'API
            let quote = try await service.fetchDailyQuote()
            currentQuote = quote
            saveCurrentQuote()
            updateLastUpdateDate()
        } catch {
            print("Error fetching quote: \(error)")
            // Se c'è un errore, utilizziamo una citazione casuale dalla lista
            let randomQuote = fallbackQuotes.randomElement() ?? fallbackQuotes[0]
            // Assicuriamoci che non sia uguale a quella attuale se possibile
            if fallbackQuotes.count > 1 && randomQuote.text == currentQuote.text {
                let filteredQuotes = fallbackQuotes.filter { $0.text != currentQuote.text }
                currentQuote = filteredQuotes.randomElement() ?? randomQuote
            } else {
                currentQuote = randomQuote
            }
            saveCurrentQuote()
            updateLastUpdateDate()
        }
        
        // Completato il caricamento
        isLoading = false
    }
}
</file>

<file path="SnapTask/Models/Category.swift/Category.swift">
import Foundation

struct Category: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var color: String
}
</file>

<file path="SnapTask/Models/FocusMode.swift/FocusMode.swift">

</file>

<file path="SnapTask/Models/FocusSettings.swift/FocusSettings.swift">

</file>

<file path="SnapTask/Models/PomodoroSettings.swift/PomodoroSettings.swift">
import Foundation

struct PomodoroSettings: Codable, Equatable {
    var workDuration: Double
    var breakDuration: Double
    var longBreakDuration: Double
    var sessionsUntilLongBreak: Int
    
    static let defaultSettings = PomodoroSettings(
        workDuration: 25 * 60,    // 25 minutes in seconds
        breakDuration: 5 * 60,    // 5 minutes
        longBreakDuration: 15 * 60, // 15 minutes
        sessionsUntilLongBreak: 4
    )
    
    // Computed properties for session management
    var sessionDuration: Double {
        workDuration
    }
    
    var sessions: Int {
        sessionsUntilLongBreak
    }
}
</file>

<file path="SnapTask/Models/Priority.swift/Priority.swift">
import Foundation

enum Priority: String, CaseIterable, Codable {
    case low
    case medium
    case high
    
    var icon: String {
        switch self {
        case .low: return "arrow.down"
        case .medium: return "minus"
        case .high: return "arrow.up"
        }
    }
    
    var color: String {
        switch self {
        case .low: return "#00FF00"
        case .medium: return "#FFA500"
        case .high: return "#FF0000"
        }
    }
}
</file>

<file path="SnapTask/Models/Quote.swift/Quote.swift">
import Foundation

struct Quote: Identifiable, Codable, Equatable {
    let id: UUID
    var text: String
    var author: String
    var lastUpdated: Date
    
    init(id: UUID = UUID(), text: String, author: String, lastUpdated: Date = Date()) {
        self.id = id
        self.text = text
        self.author = author
        self.lastUpdated = lastUpdated
    }
    
    static let placeholder = Quote(
        text: "The journey of a thousand miles begins with a single step.",
        author: "Lao Tzu"
    )
}
</file>

<file path="SnapTask/Models/Recurrence.swift/Recurrence.swift">
import Foundation

struct Recurrence: Codable, Equatable {
    enum RecurrenceType: Codable, Equatable {
        case daily
        case weekly(days: Set<Int>)
        case monthly(days: Set<Int>)
    }
    
    private enum CodingKeys: String, CodingKey {
        case type, endDate, trackInStatistics, startDate
    }
    
    let type: RecurrenceType
    let startDate: Date
    let endDate: Date?
    let trackInStatistics: Bool
    
    init(type: RecurrenceType, startDate: Date, endDate: Date?, trackInStatistics: Bool = true) {
        self.type = type
        self.startDate = startDate
        self.endDate = endDate
        self.trackInStatistics = trackInStatistics
    }
    
    // Custom decoder to handle missing trackInStatistics in older data
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        type = try container.decode(RecurrenceType.self, forKey: .type)
        startDate = try container.decode(Date.self, forKey: .startDate)
        endDate = try container.decodeIfPresent(Date.self, forKey: .endDate)
        
        // Default to true if property doesn't exist in saved data
        trackInStatistics = try container.decodeIfPresent(Bool.self, forKey: .trackInStatistics) ?? true
    }
}

extension Recurrence {
    func shouldOccurOn(date: Date) -> Bool {
        let calendar = Calendar.current
        
        switch self.type {
        case .daily:
            return true
            
        case .weekly(let days):
            // Ottieni il giorno della settimana (1-7, dove 1 è Domenica)
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
            
        case .monthly(let days):
            // Ottieni il giorno del mese (1-31)
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
}
</file>

<file path="SnapTask/Models/Subtask.swift/Subtask.swift">
import Foundation

struct Subtask: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var isCompleted: Bool
    
    init(id: UUID = UUID(), name: String, isCompleted: Bool = false) {
        self.id = id
        self.name = name
        self.isCompleted = isCompleted
    }
}
</file>

<file path="SnapTask/Models/TaskCompletion.swift/TaskCompletion.swift">
import Foundation

struct TaskCompletion: Codable, Equatable {
    var isCompleted: Bool
    var completedSubtasks: Set<UUID>
    
    init(isCompleted: Bool = false, completedSubtasks: Set<UUID> = []) {
        self.isCompleted = isCompleted
        self.completedSubtasks = completedSubtasks
    }
}
</file>

<file path="SnapTask/Models/TaskManager.swift/TaskManager.swift">
import Foundation
import Combine
import WatchConnectivity

class TaskManager: ObservableObject {
    static let shared = TaskManager()
    
    @Published private(set) var tasks: [TodoTask] = []
    private let tasksKey = "savedTasks"
    
    init() {
        loadTasks()
    }
    
    func addTask(_ task: TodoTask) {
        print("Adding task: \(task.name)")
        print("Has recurrence: \(task.recurrence != nil)")
        tasks.append(task)
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con CloudKit in modo sicuro
        // CloudKitSyncProxy.shared.saveTask(task)
        
        // Sincronizza con Apple Watch
        synchronizeWithWatch()
    }
    
    func updateTask(_ updatedTask: TodoTask) {
        if let index = tasks.firstIndex(where: { $0.id == updatedTask.id }) {
            // Preserva i dati di completamento esistenti
            let existingCompletions = tasks[index].completions
            var task = updatedTask
            task.completions = existingCompletions
            tasks[index] = task
            
            saveTasks()
            notifyTasksUpdated()
            
            // Sincronizza con CloudKit in modo sicuro
            // CloudKitSyncProxy.shared.saveTask(task)
            
            // Sincronizza con Apple Watch
            synchronizeWithWatch()
        }
    }
    
    func updateAllTasks(_ newTasks: [TodoTask]) {
        tasks = newTasks
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con Apple Watch
        synchronizeWithWatch()
    }
    
    func removeTask(_ task: TodoTask) {
        tasks.removeAll { $0.id == task.id }
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con CloudKit in modo sicuro
        // CloudKitSyncProxy.shared.deleteTask(task)
        
        // Sincronizza con Apple Watch
        synchronizeWithWatch()
    }
    
    func toggleTaskCompletion(_ taskId: UUID, on date: Date = Date()) {
        if let index = tasks.firstIndex(where: { $0.id == taskId }) {
            var task = tasks[index]
            let startOfDay = date.startOfDay
            
            // Aggiorna il completion status
            if let completion = task.completions[startOfDay] {
                task.completions[startOfDay] = TaskCompletion(
                    isCompleted: !completion.isCompleted,
                    completedSubtasks: completion.completedSubtasks
                )
            } else {
                task.completions[startOfDay] = TaskCompletion(
                    isCompleted: true,
                    completedSubtasks: []
                )
            }
            
            // Aggiorna completionDates
            if task.completions[startOfDay]?.isCompleted == true {
                if !task.completionDates.contains(startOfDay) {
                    task.completionDates.append(startOfDay)
                }
            } else {
                task.completionDates.removeAll { $0 == startOfDay }
            }
            
            tasks[index] = task
            
            // Forza l'aggiornamento
            DispatchQueue.main.async { [weak self] in
                self?.saveTasks()
                self?.notifyTasksUpdated()
                self?.objectWillChange.send()
                
                // Sincronizza con CloudKit in modo sicuro
                // CloudKitSyncProxy.shared.saveTask(task)
                
                // Sincronizza con Apple Watch
                self?.synchronizeWithWatch()
            }
        }
    }
    
    func toggleSubtask(taskId: UUID, subtaskId: UUID, on date: Date = Date()) {
        guard let taskIndex = tasks.firstIndex(where: { $0.id == taskId }) else { return }
        
        var task = tasks[taskIndex]
        let startOfDay = date.startOfDay
        
        var completion = task.completions[startOfDay] ?? TaskCompletion(isCompleted: false, completedSubtasks: [])
        
        if completion.completedSubtasks.contains(subtaskId) {
            completion.completedSubtasks.remove(subtaskId)
        } else {
            completion.completedSubtasks.insert(subtaskId)
        }
        
        task.completions[startOfDay] = completion
        tasks[taskIndex] = task
        
        // Ensure UI updates happen on the main thread
        DispatchQueue.main.async { [weak self] in
            self?.saveTasks()
            self?.notifyTasksUpdated()
            self?.objectWillChange.send()
            
            // Sincronizza con CloudKit in modo sicuro
            // CloudKitSyncProxy.shared.saveTask(task)
            
            // Sincronizza con Apple Watch
            self?.synchronizeWithWatch()
        }
    }
    
    func syncWithCloudKit() {
        // Sincronizza in modo sicuro tramite proxy
        // CloudKitSyncProxy.shared.syncTasks()
    }
    
    private func saveTasks() {
        do {
            let data = try JSONEncoder().encode(tasks)
            UserDefaults.standard.set(data, forKey: tasksKey)
        } catch {
            print("Error saving tasks: \(error)")
        }
    }
    
    private func loadTasks() {
        if let data = UserDefaults.standard.data(forKey: tasksKey) {
            do {
                tasks = try JSONDecoder().decode([TodoTask].self, from: data)
            } catch {
                print("Error loading tasks: \(error)")
                tasks = []
            }
        }
    }
    
    private func notifyTasksUpdated() {
        NotificationCenter.default.post(name: .tasksDidUpdate, object: nil)
    }
    
    // Function to synchronize tasks with Apple Watch
    private func synchronizeWithWatch() {
        let connectivityManager = WatchConnectivityManager.shared
        connectivityManager.updateWatchContext()
    }
    
    // For debugging purposes only
    func resetUserDefaults() {
        UserDefaults.standard.removeObject(forKey: tasksKey)
        loadTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con CloudKit in modo sicuro
        // CloudKitSyncProxy.shared.syncTasks()
        
        // Sincronizza con Apple Watch
        synchronizeWithWatch()
    }
}

extension Notification.Name {
    static let tasksDidUpdate = Notification.Name("tasksDidUpdate")
}
</file>

<file path="SnapTask/Models/TodoTask.swift/TodoTask.swift">
import Foundation
import Combine

struct TodoTask: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var description: String?
    var startTime: Date
    var duration: TimeInterval
    var hasDuration: Bool
    var category: Category?
    var priority: Priority
    var icon: String
    var recurrence: Recurrence?
    var pomodoroSettings: PomodoroSettings?
    var completions: [Date: TaskCompletion] = [:]
    var subtasks: [Subtask] = []
    var completionDates: [Date] = []
    var creationDate: Date = Date()
    var lastModifiedDate: Date = Date()
    
    init(
        id: UUID = UUID(),
        name: String,
        description: String? = nil,
        startTime: Date,
        duration: TimeInterval = 0,
        hasDuration: Bool = false,
        category: Category? = nil,
        priority: Priority = .medium,
        icon: String = "circle",
        recurrence: Recurrence? = nil,
        pomodoroSettings: PomodoroSettings? = nil,
        subtasks: [Subtask] = []
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.startTime = startTime
        self.duration = duration
        self.hasDuration = hasDuration
        self.category = category
        self.priority = priority
        self.icon = icon
        self.recurrence = recurrence
        self.pomodoroSettings = pomodoroSettings
        self.subtasks = subtasks
    }
    
    var completionProgress: Double {
        guard !subtasks.isEmpty else { 
            if let completion = completions[Date().startOfDay] {
                return completion.isCompleted ? 1.0 : 0.0
            }
            return 0.0
        }
        return Double(subtasks.filter(\.isCompleted).count) / Double(subtasks.count)
    }
    
    func streakForDate(_ date: Date) -> Int {
        guard let recurrence = recurrence else { return 0 }
        
        let calendar = Calendar.current
        var currentDate = date.startOfDay
        var streak = 0
        
        if currentDate > Date().startOfDay {
            return 0
        }
        
        while true {
            if currentDate < calendar.startOfDay(for: startTime) {
                break
            }
            
            if let endDate = recurrence.endDate, currentDate > endDate {
                break
            }
            
            let shouldCheck = shouldCheckDate(currentDate, recurrence: recurrence)
            
            if shouldCheck {
                if let completion = completions[currentDate], completion.isCompleted {
                    streak += 1
                } else {
                    break
                }
            }
            
            guard let newDate = calendar.date(byAdding: .day, value: -1, to: currentDate) else { break }
            currentDate = newDate
        }
        
        return streak
    }
    
    private func shouldCheckDate(_ date: Date, recurrence: Recurrence) -> Bool {
        let calendar = Calendar.current
        
        switch recurrence.type {
        case .daily:
            return true
        case .weekly(let days):
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
        case .monthly(let days):
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
    
    var currentStreak: Int {
        streakForDate(Date())
    }
    
    static func == (lhs: TodoTask, rhs: TodoTask) -> Bool {
        lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.description == rhs.description &&
        lhs.startTime == rhs.startTime &&
        lhs.duration == rhs.duration &&
        lhs.hasDuration == rhs.hasDuration &&
        lhs.category == rhs.category &&
        lhs.priority == rhs.priority &&
        lhs.icon == rhs.icon &&
        lhs.recurrence == rhs.recurrence &&
        lhs.pomodoroSettings == rhs.pomodoroSettings &&
        lhs.completions == rhs.completions &&
        lhs.subtasks == rhs.subtasks &&
        lhs.completionDates == rhs.completionDates
    }
}
</file>

<file path="SnapTask/Preview Content/Preview Assets.xcassets/Contents.json/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask/Resources/en.lproj/Localizable.strings/Localizable.strings">
// Common
"app_name" = "SnapTask";
"cancel" = "Cancel";
"save" = "Save";
"edit" = "Edit";
"delete" = "Delete";
"done" = "Done";
"add" = "Add";

// Main tabs
"timeline" = "Timeline";
"statistics" = "Statistics";
"settings" = "Settings";

// Task related
"task" = "Task";
"tasks" = "Tasks";
"new_task" = "New Task";
"edit_task" = "Edit Task";
"task_name" = "Task Name";
"task_description" = "Description";
"task_category" = "Category";
"task_priority" = "Priority";
"task_duration" = "Duration";
"task_recurrence" = "Recurrence";
"subtasks" = "Subtasks";
"add_subtask" = "Add Subtask";
"no_subtasks" = "No Subtasks";
"task_completed" = "Task Completed";
"high_priority" = "High";
"medium_priority" = "Medium";
"low_priority" = "Low";

// Recurrence
"daily" = "Daily";
"weekly" = "Weekly";
"monthly" = "Monthly";
"recurrence_settings" = "Recurrence Settings";
"select_days" = "Select Days";

// Statistics
"time_spent" = "Time Spent";
"today" = "Today";
"week" = "Week";
"month" = "Month";
"year" = "Year";
"weekly_overview" = "Weekly Overview";
"streak" = "Streak";
"current_streak" = "Current Streak";
"best_streak" = "Best Streak";
"task_consistency" = "Task Consistency";
"progress_points" = "Progress Points";
"no_category_data" = "No category data available";
"complete_tasks_see_stats" = "Complete tasks with categories to see stats";
"tracking_consistency" = "Tracking consistency in completing recurring tasks";
"higher_points" = "Higher points indicate better consistency over time";
"no_recurring_tasks" = "No recurring tasks found";
"shows_consistency" = "Shows consistency for recurring tasks over time";
"x_axis_y_axis" = "X-axis: Days/Period • Y-axis: Accumulative progress points";
"how_to_read" = "How to read: ↑ Lines rise when tasks are completed, ↓ fall when missed";
"points_explanation" = "Each completed task = +1 point • Each missed task = -1 point";
"track_in_consistency" = "Track in consistency statistics";

// Categories
"categories" = "Categories";
"add_category" = "Add Category";
"edit_category" = "Edit Category";
"category_name" = "Category Name";
"category_color" = "Color";

// Settings
"quote_of_the_day" = "Quote of the Day";
"new_quote" = "New Quote";
"customization" = "Customization";
"appearance" = "Appearance";
"dark_mode" = "Dark Mode";
"priorities" = "Priorities";
"add_priority" = "Add Priority";
"language" = "Language";
"performance" = "Performance";
"biohacking" = "Biohacking";

// Pomodoro
"pomodoro" = "Pomodoro";
"pomodoro_settings" = "Pomodoro Settings";
"work_duration" = "Work Duration";
"short_break" = "Short Break";
"long_break" = "Long Break";
"sessions_before_long_break" = "Sessions Before Long Break";
</file>

<file path="SnapTask/Resources/it.lproj/Localizable.strings/Localizable.strings">
// Common
"app_name" = "SnapTask";
"cancel" = "Annulla";
"save" = "Salva";
"edit" = "Modifica";
"delete" = "Elimina";
"done" = "Fatto";
"add" = "Aggiungi";

// Main tabs
"timeline" = "Timeline";
"statistics" = "Statistiche";
"settings" = "Impostazioni";

// Task related
"task" = "Attività";
"tasks" = "Attività";
"new_task" = "Nuova Attività";
"edit_task" = "Modifica Attività";
"task_name" = "Nome Attività";
"task_description" = "Descrizione";
"task_category" = "Categoria";
"task_priority" = "Priorità";
"task_duration" = "Durata";
"task_recurrence" = "Ricorrenza";
"subtasks" = "Sottoattività";
"add_subtask" = "Aggiungi Sottoattività";
"no_subtasks" = "Nessuna Sottoattività";
"task_completed" = "Attività Completata";
"high_priority" = "Alta";
"medium_priority" = "Media";
"low_priority" = "Bassa";

// Recurrence
"daily" = "Giornaliera";
"weekly" = "Settimanale";
"monthly" = "Mensile";
"recurrence_settings" = "Impostazioni Ricorrenza";
"select_days" = "Seleziona Giorni";

// Statistics
"time_spent" = "Tempo Impiegato";
"today" = "Oggi";
"week" = "Settimana";
"month" = "Mese";
"year" = "Anno";
"weekly_overview" = "Panoramica Settimanale";
"streak" = "Serie";
"current_streak" = "Serie Attuale";
"best_streak" = "Serie Migliore";
"task_consistency" = "Costanza Attività";
"progress_points" = "Punti Progresso";
"no_category_data" = "Nessun dato di categoria disponibile";
"complete_tasks_see_stats" = "Completa attività con categorie per vedere le statistiche";
"tracking_consistency" = "Monitoraggio della costanza nel completare attività ricorrenti";
"higher_points" = "Punti più alti indicano una migliore costanza nel tempo";
"no_recurring_tasks" = "Nessuna attività ricorrente trovata";
"shows_consistency" = "Mostra la costanza per le attività ricorrenti nel tempo";
"x_axis_y_axis" = "Asse X: Giorni/Periodo • Asse Y: Punti progresso cumulativi";
"how_to_read" = "Come leggere: ↑ Le linee salgono quando le attività sono completate, ↓ scendono quando mancate";
"points_explanation" = "Ogni attività completata = +1 punto • Ogni attività mancata = -1 punto";
"track_in_consistency" = "Traccia nelle statistiche di consistenza";

// Categories
"categories" = "Categorie";
"add_category" = "Aggiungi Categoria";
"edit_category" = "Modifica Categoria";
"category_name" = "Nome Categoria";
"category_color" = "Colore";

// Settings
"quote_of_the_day" = "Citazione del Giorno";
"new_quote" = "Nuova Citazione";
"customization" = "Personalizzazione";
"appearance" = "Aspetto";
"dark_mode" = "Modalità Scura";
"priorities" = "Priorità";
"add_priority" = "Aggiungi Priorità";
"language" = "Lingua";
"performance" = "Prestazioni";
"biohacking" = "Biohacking";

// Pomodoro
"pomodoro" = "Pomodoro";
"pomodoro_settings" = "Impostazioni Pomodoro";
"work_duration" = "Durata Lavoro";
"short_break" = "Pausa Breve";
"long_break" = "Pausa Lunga";
"sessions_before_long_break" = "Sessioni Prima della Pausa Lunga";
</file>

<file path="SnapTask/Services/CloudKitService.swift/CloudKitService.swift">
import Foundation
import CloudKit
import Combine

class CloudKitService: ObservableObject {
    static let shared = CloudKitService()
    
    private let container: CKContainer
    private let privateDatabase: CKDatabase
    private let recordZone: CKRecordZone
    private let zoneID: CKRecordZone.ID
    
    private let taskRecordType = "TodoTask"
    private let deletedTasksKey = "deletedTaskIDs" // Key for tracking deleted tasks
    
    @Published var isSyncing = false
    @Published var lastSyncDate: Date?
    @Published var syncError: Error?
    
    private var subscriptions = Set<AnyCancellable>()
    private var changedRecordZoneIDs: [CKRecordZone.ID] = []
    
    // Tracking deleted task IDs
    private var deletedTaskIDs: Set<String> {
        get {
            if let data = UserDefaults.standard.data(forKey: deletedTasksKey),
               let ids = try? JSONDecoder().decode([String].self, from: data) {
                return Set(ids)
            }
            return Set<String>()
        }
        set {
            if let data = try? JSONEncoder().encode(Array(newValue)) {
                UserDefaults.standard.set(data, forKey: deletedTasksKey)
            }
        }
    }
    
    private init() {
        container = CKContainer.default() 
        privateDatabase = container.privateCloudDatabase
        zoneID = CKRecordZone.ID(zoneName: "SnapTaskZone", ownerName: CKCurrentUserDefaultName)
        recordZone = CKRecordZone(zoneID: zoneID)
        
        // Ripristiniamo queste chiamate
        // setupSubscriptions() // TEMPORANEAMENTE COMMENTATO PER TEST
        checkCloudKitAvailability()
    }
    
    // MARK: - Public Methods
    
    func setup() {
        createCustomZoneIfNeeded()
        subscribeToChanges()
    }
    
    func syncTasks() {
        isSyncing = true
        
        // Fetch local tasks
        let localTasks = TaskManager.shared.tasks
        
        // Fetch remote tasks
        fetchAllTasks { [weak self] remoteTasks, error in
            guard let self = self else { return }
            
            if let error = error {
                self.handleSyncError(error)
                return
            }
            
            // Use the safer merge implementation
            self.mergeTasksSafely(localTasks: localTasks, remoteTasks: remoteTasks ?? [])
        }
    }
    
    // Versione che non lancia eccezioni
    func syncTasksSafely() {
        do {
            isSyncing = true
            
            // Fetch local tasks safely
            let localTasks = TaskManager.shared.tasks
            
            // Fetch remote tasks with error handling
            fetchAllTasks { [weak self] remoteTasks, error in
                guard let self = self else { return }
                
                if let error = error {
                    print("CloudKit sync error: \(error.localizedDescription)")
                    self.handleSyncError(error)
                    return
                }
                
                do {
                    // Compare and merge tasks with error handling
                    self.mergeTasksSafely(localTasks: localTasks, remoteTasks: remoteTasks ?? [])
                } catch {
                    print("Error during task merging: \(error.localizedDescription)")
                    self.handleSyncError(error)
                }
            }
        } catch {
            print("Unexpected error in syncTasksSafely: \(error.localizedDescription)")
            self.handleSyncError(error)
        }
    }
    
    func saveTask(_ task: TodoTask) {
        let record = taskToRecord(task)
        
        saveRecord(record) { [weak self] success, error in
            if let error = error {
                self?.handleSyncError(error)
            }
        }
    }
    
    func deleteTask(_ task: TodoTask) {
        let recordID = CKRecord.ID(recordName: task.id.uuidString, zoneID: zoneID)
        
        print("CloudKitService: Attempting to delete task with ID: \(task.id.uuidString)")
        
        // Track this task as deleted even before server confirms
        addToDeletedTasks(taskID: task.id.uuidString)
        
        privateDatabase.delete(withRecordID: recordID) { [weak self] (recordID, error) in
            if let error = error as? CKError {
                // Don't report error if record not found - it's already deleted
                if error.code != .unknownItem {
                    print("CloudKitService: Error deleting task: \(error.localizedDescription)")
                    self?.handleSyncError(error)
                } else {
                    print("CloudKitService: Task already deleted or not found in CloudKit")
                }
            } else if let error = error {
                print("CloudKitService: Error deleting task: \(error.localizedDescription)")
                self?.handleSyncError(error)
            } else {
                print("CloudKitService: Task successfully deleted from CloudKit")
                // Update the last sync date to reflect the change
                DispatchQueue.main.async {
                    self?.lastSyncDate = Date()
                }
            }
        }
    }
    
    // Add a task ID to deleted tasks list
    private func addToDeletedTasks(taskID: String) {
        var ids = deletedTaskIDs
        ids.insert(taskID)
        deletedTaskIDs = ids
    }
    
    // Check if a task is in the deleted list
    private func isTaskDeleted(taskID: String) -> Bool {
        return deletedTaskIDs.contains(taskID)
    }
    
    // MARK: - Private Methods
    
    private func checkCloudKitAvailability() {
        container.accountStatus { [weak self] (status, error) in
            DispatchQueue.main.async {
                switch status {
                case .available:
                    self?.setup()
                case .noAccount:
                    self?.syncError = NSError(domain: "CloudKit", code: 1, userInfo: [NSLocalizedDescriptionKey: "No iCloud account found. Please sign in to your iCloud account."])
                case .restricted:
                    self?.syncError = NSError(domain: "CloudKit", code: 2, userInfo: [NSLocalizedDescriptionKey: "iCloud access is restricted."])
                case .couldNotDetermine:
                    if let error = error {
                        self?.syncError = error
                    } else {
                        self?.syncError = NSError(domain: "CloudKit", code: 3, userInfo: [NSLocalizedDescriptionKey: "Could not determine iCloud account status."])
                    }
                @unknown default:
                    self?.syncError = NSError(domain: "CloudKit", code: 4, userInfo: [NSLocalizedDescriptionKey: "Unknown iCloud account status."])
                }
            }
        }
    }
    
    private func createCustomZoneIfNeeded() {
        privateDatabase.fetch(withRecordZoneID: zoneID) { [weak self] (zone, error) in
            guard let self = self else { return }
            
            if let error = error as? CKError {
                if error.code == .zoneNotFound {
                    print("CloudKitService: Zone 'SnapTaskZone' not found. Attempting to create.")
                    self.createCustomZone()
                } else {
                    print("CloudKitService: Error fetching zone 'SnapTaskZone': \(error.localizedDescription)")
                    self.handleSyncError(error)
                }
            } else if let error = error { // Handle other non-CKError types
                print("CloudKitService: Non-CKError fetching zone 'SnapTaskZone': \(error.localizedDescription)")
                self.handleSyncError(error)
            } else {
                // Zone exists
                print("CloudKitService: Zone 'SnapTaskZone' already exists.")
            }
        }
    }
    
    private func createCustomZone() {
        print("CloudKitService: Executing createCustomZone() for 'SnapTaskZone'.")
        privateDatabase.save(recordZone) { [weak self] (zone, error) in
            guard let self = self else { return }
            if let error = error {
                print("CloudKitService: ERRORE durante la creazione della zona 'SnapTaskZone': \(error.localizedDescription)")
                self.handleSyncError(error)
            } else {
                print("CloudKitService: Zona 'SnapTaskZone' creata con successo. Clearing previous sync errors.")
                self.syncError = nil // Clear error before attempting sync
                // La zona è stata creata, possiamo provare a sincronizzare di nuovo
                // per popolare i dati o aggiornare lo stato dell'interfaccia.
                // Usiamo la versione safely per coerenza con il resto dell'approccio.
                self.syncTasksSafely() 
            }
        }
    }
    
    private func subscribeToChanges() {
        let subscription = CKRecordZoneSubscription(zoneID: zoneID)
        
        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        subscription.notificationInfo = notificationInfo
        
        privateDatabase.save(subscription) { [weak self] (subscription, error) in
            if let error = error {
                self?.handleSyncError(error)
            }
        }
    }
    
    private func setupSubscriptions() {
        NotificationCenter.default.publisher(for: .tasksDidUpdate)
            .sink { [weak self] _ in
                self?.handleLocalTasksUpdated()
            }
            .store(in: &subscriptions)
        
        NotificationCenter.default.publisher(for: .NSPersistentStoreRemoteChange)
            .sink { [weak self] _ in
                self?.handleRemoteChange()
            }
            .store(in: &subscriptions)
    }
    
    private func handleLocalTasksUpdated() {
        // Save all tasks to CloudKit
        for task in TaskManager.shared.tasks {
            saveTask(task)
        }
    }
    
    private func handleRemoteChange() {
        syncTasks()
    }
    
    private func fetchAllTasks(completion: @escaping ([TodoTask]?, Error?) -> Void) {
        let predicate = NSPredicate(value: true)
        let query = CKQuery(recordType: taskRecordType, predicate: predicate)
        
        print("CloudKitService: Fetching all tasks from CloudKit")
        
        do {
            privateDatabase.perform(query, inZoneWith: zoneID) { [weak self] (records, error) in
                guard let self = self else { 
                    completion(nil, NSError(domain: "CloudKitService", code: -1, userInfo: [NSLocalizedDescriptionKey: "Self is nil"]))
                    return
                }
                
                if let error = error {
                    print("CloudKitService: Error fetching tasks: \(error.localizedDescription)")
                    completion(nil, error)
                    return
                }
                
                guard let records = records else {
                    print("CloudKitService: No records found")
                    completion([], nil)
                    return
                }
                
                print("CloudKitService: Found \(records.count) records in CloudKit")
                
                // Process records in a safer way
                var tasks: [TodoTask] = []
                var recordProcessingErrors: [Error] = []
                
                for record in records {
                    do {
                        // Skip records for tasks we've deleted locally
                        if self.isTaskDeleted(taskID: record.recordID.recordName) {
                            print("CloudKitService: Skipping deleted task with ID: \(record.recordID.recordName)")
                            continue
                        }
                        
                        if let task = self.recordToTask(record) {
                            tasks.append(task)
                        }
                    } catch {
                        print("CloudKitService: Error processing record: \(error.localizedDescription)")
                        recordProcessingErrors.append(error)
                    }
                }
                
                if tasks.isEmpty && !recordProcessingErrors.isEmpty {
                    // If we have errors and no tasks, report the first error
                    completion(nil, recordProcessingErrors.first)
                } else {
                    // Otherwise return the tasks we successfully processed
                    completion(tasks, nil)
                }
            }
        } catch {
            print("CloudKitService: Unexpected error in fetchAllTasks: \(error.localizedDescription)")
            completion(nil, error)
        }
    }
    
    private func saveRecord(_ record: CKRecord, completion: @escaping (Bool, Error?) -> Void) {
        let modifyOperation = CKModifyRecordsOperation(recordsToSave: [record], recordIDsToDelete: nil)
        modifyOperation.savePolicy = .changedKeys

        modifyOperation.modifyRecordsCompletionBlock = { savedRecords, deletedRecordIDs, error in
            // It's important to dispatch UI updates or completions that interact with UI
            // back to the main thread. However, the completion handler for saveRecord
            // is often called from background logic that then dispatches to main if needed.
            // For CloudKitService internal logic, operating on the callback queue is fine.
            // If handleSyncError dispatches to main, that's handled there.
            if let error = error {
                print("CloudKitService: Error saving record with CKModifyRecordsOperation: \(error.localizedDescription)")
                completion(false, error)
                return
            }
            print("CloudKitService: Record saved successfully with CKModifyRecordsOperation. Saved records: \(savedRecords?.count ?? 0)")
            completion(true, nil)
        }
        
        // Imposta la qualità del servizio se necessario, ad esempio .userInitiated
        // modifyOperation.qualityOfService = .userInitiated
        
        privateDatabase.add(modifyOperation)
    }
    
    private func mergeTasksSafely(localTasks: [TodoTask], remoteTasks: [TodoTask]) {
        // localTasks: from TaskManager at start of sync
        // remoteTasks: from CloudKit, already filtered by this device's deletedTaskIDs list (tasks this device knows were deleted by it are not included)

        print("CloudKitService: mergeTasksSafely - Starting merge. Local: \(localTasks.count), Remote (filtered by local deletes): \(remoteTasks.count)")
        let localDeviceDeletedIDs = self.deletedTaskIDs // IDs this device knows MUST be deleted

        var finalLocalState = [UUID: TodoTask]() // Accumulator for new local state
        var recordsToSaveToCloudKit = [CKRecord]()
        var recordIDsToDeleteFromCloudKit = Set<CKRecord.ID>()

        // Ensure all tasks this device marked as deleted are indeed queued for server deletion
        localDeviceDeletedIDs.forEach { idString in
            recordIDsToDeleteFromCloudKit.insert(CKRecord.ID(recordName: idString, zoneID: self.zoneID))
        }

        let localTasksMap = Dictionary(localTasks.map { ($0.id, $0) }, uniquingKeysWith: { (first, _) in first })
        // remoteTasks are already filtered by localDeviceDeletedIDs during fetchAllTasks.
        // This means remoteTasksMap does not contain tasks that this device has deleted and recorded in its UserDefaults.
        let remoteTasksMap = Dictionary(remoteTasks.map { ($0.id, $0) }, uniquingKeysWith: { (first, _) in first })
        
        let allConsideredIDs = Set(localTasksMap.keys).union(remoteTasksMap.keys)

        for taskID in allConsideredIDs {
            let idString = taskID.uuidString
            let localTask = localTasksMap[taskID]
            let remoteTask = remoteTasksMap[taskID]

            if localDeviceDeletedIDs.contains(idString) {
                print("CKService (iOS): Merge - Task \\(idString) in local deleted list. Ensuring server delete.")
                // Already added to recordIDsToDeleteFromCloudKit via localDeviceDeletedIDs
                continue
            }

            if let lt = localTask, let rt = remoteTask {
                // Prioritize based on lastModifiedDate
                if lt.lastModifiedDate >= rt.lastModifiedDate { // MODIFIED
                    finalLocalState[taskID] = lt
                    if lt.lastModifiedDate > rt.lastModifiedDate { // MODIFIED
                        print("CKService (iOS): Merge - Local task '\\(lt.name)' is more recently modified. Scheduling for server update.")
                        recordsToSaveToCloudKit.append(self.taskToRecord(lt))
                    } else {
                        // Potentially check for content differences if dates are identical but not sure if synced.
                        // For now, assume synced if dates are identical.
                        print("CKService (iOS): Merge - Local task '\\(lt.name)' and remote task have same modification date.")
                    }
                } else {
                    finalLocalState[taskID] = rt
                    print("CKService (iOS): Merge - Remote task '\\(rt.name)' is more recently modified. Updating local state.")
                }
            } else if let lt = localTask {
                // Task exists locally, but not in remoteTasks (which are already filtered by *this device's* deletedTaskIDs).
                // This means:
                // a) It's a new task created on this device that hasn't successfully synced yet.
                // b) It *was* on the server, but was deleted by *another* device. This device doesn't know about that remote deletion yet.
                
                // We keep it in the local state because this device believes it exists.
                finalLocalState[taskID] = lt
                
                // We schedule it for upload.
                // If it's case (a), it gets to the server. Good.
                // If it's case (b), it might be temporarily resurrected on the server.
                // The other device, on its next sync, should re-delete it based on its local deletedTaskIDs.
                // This is preferable to new tasks never appearing.
                print("CloudKitService: Merge - Task '\(lt.name)' is local-only (or remotely deleted by another device). Keeping local and scheduling for upload/update on CloudKit.")
                recordsToSaveToCloudKit.append(self.taskToRecord(lt))

            } else if let rt = remoteTask {
                // Task exists in remoteTasks, but not locally (and not in localDeviceDeletedIDs).
                // This means it's a new task from the server / another device.
                finalLocalState[taskID] = rt
                print("CloudKitService: Merge - Remote task '\(rt.name)' is new to this device or was re-fetched. Adding/updating locally.")
            }
        }

        // Perform local and remote updates
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            let tasksForManager = Array(finalLocalState.values)
            print("CloudKitService: Merge - Finalizing. Updating TaskManager with \(tasksForManager.count) tasks.")
            TaskManager.shared.updateAllTasks(tasksForManager)

            // Consolidate recordIDsToDeleteFromCloudKit: ensure we don't try to delete what we're about to save if a task was rapidly changed.
            // However, given the logic, a task to be saved shouldn't also be in localDeviceDeletedIDs.
            let finalRecordIDsToDelete = Array(recordIDsToDeleteFromCloudKit)

            if !recordsToSaveToCloudKit.isEmpty || !finalRecordIDsToDelete.isEmpty {
                print("CloudKitService: Merge - Preparing to save \(recordsToSaveToCloudKit.count) records and delete \(finalRecordIDsToDelete.count) record IDs from CloudKit.")
                let modifyOp = CKModifyRecordsOperation(recordsToSave: recordsToSaveToCloudKit, recordIDsToDelete: finalRecordIDsToDelete)
                modifyOp.savePolicy = .changedKeys 
                // modifyOp.isAtomic = false // Consider atomicity if needed, default is true per zone.
                modifyOp.modifyRecordsCompletionBlock = { savedRecords, deletedRecordIDs, error in
                    DispatchQueue.main.async { // Ensure UI updates on main thread
                        if let error = error {
                            print("CloudKitService: Merge - CKModifyRecordsOperation error: \(error.localizedDescription)")
                            self.handleSyncError(error)
                        } else {
                            print("CloudKitService: Merge - CKModifyRecordsOperation success. Saved: \(savedRecords?.count ?? 0), Deleted: \(deletedRecordIDs?.count ?? 0).")
                            // Optionally, if you want to clean up UserDefaults after confirmed server deletion:
                            // deletedRecordIDs?.forEach { self.removeFromDeletedTasks(taskID: $0.recordName) }
                            self.syncError = nil
                        }
                        self.isSyncing = false
                        self.lastSyncDate = Date()
                    }
                }
                self.privateDatabase.add(modifyOp)
            } else {
                print("CloudKitService: Merge - No CloudKit operations needed.")
                self.isSyncing = false
                self.lastSyncDate = Date()
                self.syncError = nil
            }
        }
    }
    
    private func taskToRecord(_ task: TodoTask) -> CKRecord {
        let recordID = CKRecord.ID(recordName: task.id.uuidString, zoneID: zoneID)
        let record = CKRecord(recordType: taskRecordType, recordID: recordID)
        print("CloudKitService: taskToRecord - Creazione record per task: \(task.name)")

        // Basic properties - Explicitly cast all values to CKRecordValue
        record["name"] = task.name as CKRecordValue
        record["appCreationDate"] = task.creationDate as NSDate // Custom field for model's creation date
        record["lastModifiedDate"] = task.lastModifiedDate as NSDate // ADDED
        record["startTime"] = task.startTime as NSDate
        record["duration"] = task.duration as CKRecordValue
        record["hasDuration"] = task.hasDuration as CKRecordValue
        record["icon"] = task.icon as CKRecordValue
        
        // Store priority as String to avoid issues
        let priorityValue = task.priority.rawValue
        record["priority"] = priorityValue as CKRecordValue
        
        // Handle optional properties more safely
        if let description = task.description, !description.isEmpty {
            print("CloudKitService: Setting description for task: \(task.name)")
            record["description"] = description as CKRecordValue
        } else {
            print("CloudKitService: No description for task: \(task.name)")
            record["description"] = nil
        }
        
        // Complex properties - encode them as Data
        do {
            // Category
            if let category = task.category {
                let categoryData = try JSONEncoder().encode(category)
                record["category"] = categoryData as NSData
            }
            
            // Recurrence
            if let recurrence = task.recurrence {
                let recurrenceData = try JSONEncoder().encode(recurrence)
                record["recurrence"] = recurrenceData as NSData
            }
            
            // PomodoroSettings
            if let pomodoroSettings = task.pomodoroSettings {
                let pomodoroData = try JSONEncoder().encode(pomodoroSettings)
                record["pomodoroSettings"] = pomodoroData as NSData
            }
            
            // Subtasks
            if !task.subtasks.isEmpty {
                let subtasksData = try JSONEncoder().encode(task.subtasks)
                record["subtasks"] = subtasksData as NSData
            }
            
            // Completions
            if !task.completions.isEmpty {
                let completionsData = try JSONEncoder().encode(task.completions)
                record["completions"] = completionsData as NSData
            }
            
            // CompletionDates
            if !task.completionDates.isEmpty {
                let completionDatesData = try JSONEncoder().encode(task.completionDates)
                record["completionDates"] = completionDatesData as NSData
            }
        } catch {
            print("CloudKitService: Error encoding task data: \(error.localizedDescription)")
        }
        
        return record
    }
    
    private func recordToTask(_ record: CKRecord) -> TodoTask? {
        // Let's provide detailed logging for debugging
        print("CloudKitService: recordToTask - Processing record with ID: \(record.recordID.recordName)")
        
        do {
            // Extract name field safely
            guard let name = record["name"] as? String else {
                print("CloudKitService: recordToTask - Campo 'name' mancante o non valido, impossibile creare TodoTask.")
                return nil
            }
            
            print("CloudKitService: recordToTask - Extracting fields for task: \(name)")
            
            // Extract other fields with safe fallbacks
            let modelCreationDate = record["appCreationDate"] as? Date ?? record.creationDate ?? Date()
            let lastModifiedDate = record["lastModifiedDate"] as? Date ?? record.modificationDate ?? modelCreationDate // ADDED
            let startTime = record["startTime"] as? Date ?? modelCreationDate
            let duration = record["duration"] as? TimeInterval ?? 0.0
            let hasDuration = record["hasDuration"] as? Bool ?? false
            let icon = record["icon"] as? String ?? "circle.fill"
            let description = record["description"] as? String

            // Handle priority with better error checking
            var priority: Priority = .medium
            do {
                if let priorityRaw = record["priority"] as? String {
                    print("CloudKitService: recordToTask - Found priority (String): \(priorityRaw)")
                    priority = Priority(rawValue: priorityRaw) ?? .medium
                } else if let priorityRaw = record["priority"] as? Int {
                    print("CloudKitService: recordToTask - Found priority (Int): \(priorityRaw)")
                    let priorities: [Priority] = [.low, .medium, .high]
                    if priorityRaw >= 0 && priorityRaw < priorities.count {
                        priority = priorities[priorityRaw]
                    }
                } else {
                    print("CloudKitService: recordToTask - No valid priority found, using default")
                }
            } catch {
                print("CloudKitService: recordToTask - Error processing priority: \(error.localizedDescription)")
            }
            
            var category: Category? = nil
            if let categoryData = record["category"] as? Data {
                do {
                    category = try JSONDecoder().decode(Category.self, from: categoryData)
                } catch { print("CloudKitService: Errore decodifica category: \(error.localizedDescription)") }
            }
            
            var recurrence: Recurrence? = nil
            if let recurrenceData = record["recurrence"] as? Data {
                do {
                    recurrence = try JSONDecoder().decode(Recurrence.self, from: recurrenceData)
                } catch { print("CloudKitService: Errore decodifica recurrence: \(error.localizedDescription)") }
            }
            
            var pomodoroSettings: PomodoroSettings? = nil
            if let pomodoroData = record["pomodoroSettings"] as? Data {
                do {
                    pomodoroSettings = try JSONDecoder().decode(PomodoroSettings.self, from: pomodoroData)
                } catch { print("CloudKitService: Errore decodifica pomodoroSettings: \(error.localizedDescription)") }
            }
            
            var subtasks: [Subtask] = []
            if let subtasksData = record["subtasks"] as? Data {
                do {
                    subtasks = try JSONDecoder().decode([Subtask].self, from: subtasksData)
                } catch { print("CloudKitService: Errore decodifica subtasks: \(error.localizedDescription)") }
            }
            
            var completions: [Date: TaskCompletion] = [:]
            if let completionsData = record["completions"] as? Data {
                do {
                    completions = try JSONDecoder().decode([Date: TaskCompletion].self, from: completionsData)
                } catch { print("CloudKitService: Errore decodifica completions: \(error.localizedDescription)") }
            }
            
            var completionDates: [Date] = []
            if let completionDatesData = record["completionDates"] as? Data {
                do {
                    completionDates = try JSONDecoder().decode([Date].self, from: completionDatesData)
                } catch { print("CloudKitService: Errore decodifica completionDates: \(error.localizedDescription)") }
            }
            
            let uuid = UUID(uuidString: record.recordID.recordName) ?? UUID()
            
            var task = TodoTask(
                id: uuid,
                name: name,
                description: description,
                startTime: startTime,
                duration: duration,
                hasDuration: hasDuration,
                category: category,
                priority: priority,
                icon: icon,
                recurrence: recurrence,
                pomodoroSettings: pomodoroSettings,
                subtasks: subtasks
            )
            
            task.completions = completions
            task.completionDates = completionDates
            task.creationDate = modelCreationDate
            task.lastModifiedDate = lastModifiedDate // ADDED
            
            print("CloudKitService: recordToTask - Successfully created task: \(name)")
            return task
        } catch {
            print("CloudKitService: recordToTask - Unexpected error processing record: \(error.localizedDescription)")
            return nil
        }
    }
    
    private func handleSyncError(_ error: Error) {
        DispatchQueue.main.async { [weak self] in
            self?.syncError = error
            self?.isSyncing = false
        }
    }
}

extension Notification.Name {
    static let cloudKitDataChanged = Notification.Name("cloudKitDataChanged")
}
</file>

<file path="SnapTask/Services/CloudKitSyncProxy.swift/CloudKitSyncProxy.swift">
import Foundation
import CloudKit

/// Classe proxy per gestire in modo sicuro tutte le interazioni CloudKit
class CloudKitSyncProxy {
    static let shared = CloudKitSyncProxy()
    
    /// Flag che indica se la sincronizzazione CloudKit è stata disabilitata a causa di errori
    private var cloudKitDisabled = false
    
    private init() {}
    
    /// Inizializza CloudKit in modo sicuro
    func setupCloudKit() {
        guard !cloudKitDisabled else {
            print("CloudKit è stato disabilitato a causa di errori precedenti")
            return
        }
        
        // Wrappa tutto in un blocco do-catch per evitare errori non gestiti
        do {
            CloudKitService.shared.setup()
        } catch {
            handleError(error, operation: "CloudKit setup")
        }
    }
    
    /// Sincronizza le attività in modo sicuro
    func syncTasks() {
        guard !cloudKitDisabled else {
            print("CloudKit è stato disabilitato a causa di errori precedenti")
            return
        }
        
        // Wrappa tutto in un blocco do-catch per evitare errori non gestiti
        do {
            CloudKitService.shared.syncTasksSafely()
        } catch {
            handleError(error, operation: "Task synchronization")
        }
    }
    
    /// Salva un'attività in modo sicuro
    func saveTask(_ task: TodoTask) {
        guard !cloudKitDisabled else {
            print("CloudKit è stato disabilitato a causa di errori precedenti")
            return
        }
        
        // Wrappa tutto in un blocco do-catch per evitare errori non gestiti
        do {
            CloudKitService.shared.saveTask(task)
        } catch {
            handleError(error, operation: "Task saving")
        }
    }
    
    /// Elimina un'attività in modo sicuro
    func deleteTask(_ task: TodoTask) {
        guard !cloudKitDisabled else {
            print("CloudKit è stato disabilitato a causa di errori precedenti")
            return
        }
        
        // Wrappa tutto in un blocco do-catch per evitare errori non gestiti
        do {
            CloudKitService.shared.deleteTask(task)
        } catch {
            handleError(error, operation: "Task deletion")
        }
    }
    
    /// Gestisce gli errori CloudKit in modo unificato
    private func handleError(_ error: Error, operation: String) {
        print("ERRORE CloudKit durante \(operation): \(error.localizedDescription)")
        
        // In caso di errori persistenti, disabilitiamo CloudKit
        if let ckError = error as? CKError {
            switch ckError.code {
            case .notAuthenticated, .permissionFailure, .quotaExceeded, .serverRejectedRequest:
                cloudKitDisabled = true
                print("CloudKit disabilitato a causa di un errore critico: \(ckError.localizedDescription)")
            default:
                break
            }
        }
    }
}
</file>

<file path="SnapTask/Services/QuoteService.swift/QuoteService.swift">
import Foundation

class QuoteService {
    static let shared = QuoteService()
    
    private init() {}
    
    func fetchDailyQuote() async throws -> Quote {
        // Use a free API like https://api.quotable.io/random
        guard let url = URL(string: "https://api.quotable.io/random") else {
            throw URLError(.badURL)
        }
        
        let (data, _) = try await URLSession.shared.data(from: url)
        let quoteResponse = try JSONDecoder().decode(QuoteResponse.self, from: data)
        
        return Quote(
            text: quoteResponse.content,
            author: quoteResponse.author
        )
    }
}

struct QuoteResponse: Codable {
    let content: String
    let author: String
}
</file>

<file path="SnapTask/SnapTask.entitlements/SnapTask.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>aps-environment</key>
	<string>development</string>
	<key>com.apple.developer.icloud-container-identifiers</key>
	<array>
		<string>iCloud.com.giovanniamadei.SnapTask</string>
	</array>
	<key>com.apple.developer.icloud-services</key>
	<array>
		<string>CloudKit</string>
	</array>
</dict>
</plist>
</file>

<file path="SnapTask/UI/Components/StatView.swift/StatView.swift">
import SwiftUI

struct StatView: View {
    let icon: String
    let value: String
    let label: String
    
    var body: some View {
        VStack(spacing: 4) {
            HStack {
                Image(systemName: icon)
                Text(value)
                    .font(.headline)
            }
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(8)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(8)
    }
}
</file>

<file path="SnapTask/UI/Components/TimerProgressView.swift/TimerProgressView.swift">
import SwiftUI

struct TimerProgressView<State: Equatable>: View {
    let progress: Double
    let timeString: String
    let state: State
    let stateTitle: String
    let accentColor: Color
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth: 20)
                .opacity(0.3)
                .foregroundColor(accentColor)
            
            Circle()
                .trim(from: 0.0, to: progress)
                .stroke(style: StrokeStyle(lineWidth: 20, lineCap: .round))
                .foregroundColor(accentColor)
                .rotationEffect(Angle(degrees: -90))
                .animation(.linear(duration: 0.1), value: progress)
            
            VStack {
                Text(timeString)
                    .font(.system(size: 50, weight: .bold, design: .rounded))
                    .monospacedDigit()
                
                Text(stateTitle)
                    .font(.title3)
            }
        }
        .padding(40)
    }
}
</file>

<file path="SnapTask/Utils/HapticManager.swift/HapticManager.swift">
import UIKit

class HapticManager {
    static let shared = HapticManager()
    private init() {}
    
    func impact(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {
        let generator = UIImpactFeedbackGenerator(style: style)
        generator.prepare()
        generator.impactOccurred()
    }
    
    func notification(_ type: UINotificationFeedbackGenerator.FeedbackType) {
        let generator = UINotificationFeedbackGenerator()
        generator.prepare()
        generator.notificationOccurred(type)
    }
}
</file>

<file path="SnapTask/ViewModels/BiohackingViewModel.swift/BiohackingViewModel.swift">
import Foundation

struct BiohackingArticle: Identifiable {
    let id = UUID()
    let title: String
    let content: String
    let icon: String
    let sourceURL: URL
    let metrics: [Metric]
    
    struct Metric: Identifiable {
        let id = UUID()
        let label: String
        let value: String
        let icon: String
        let color: String
    }
}

@MainActor
class BiohackingViewModel: ObservableObject {
    @Published var articles: [BiohackingArticle] = [
        BiohackingArticle(
            title: "Sleep Optimization",
            content: """
            ## Productivity Impact
            Quality sleep improves decision-making accuracy by 38% and problem-solving speed by 31%. 
            Studies show well-rested individuals complete complex tasks 42% faster.
            
            ## Key Practices
            • Maintain 65°F bedroom temperature for optimal sleep quality
            • Use red light (620-750nm) after sunset to preserve melatonin
            • Implement 90-minute sleep cycles aligned with natural rhythms
            
            ## Quick Wins
            → 20-min power nap before 3PM boosts afternoon focus
            → 10-min morning sunlight regulates circadian rhythm
            """,
            icon: "moon.zzz",
            sourceURL: URL(string: "https://www.nih.gov/sleep-productivity")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Focus Gain", 
                    value: "+42%", 
                    icon: "brain.head.profile", 
                    color: "#6366F1"
                ),
                BiohackingArticle.Metric(
                    label: "Error Reduction", 
                    value: "-38%", 
                    icon: "xmark.circle", 
                    color: "#8B5CF6"
                )
            ]
        ),
        BiohackingArticle(
            title: "Grounding Practices",
            content: """
            Connect with nature to reduce stress and improve focus:
            - Walk barefoot on natural surfaces 20 mins/day
            - Use grounding mats while working
            - Practice earthing during breaks
            - Combine with sunlight exposure
            """,
            icon: "leaf",
            sourceURL: URL(string: "https://example.com/grounding-practices")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Focus Duration", 
                    value: "+18%", 
                    icon: "timer", 
                    color: "#10B981"
                ),
                BiohackingArticle.Metric(
                    label: "Stress Reduction", 
                    value: "-25%", 
                    icon: "heart.fill", 
                    color: "#34D399"
                )
            ]
        ),
        BiohackingArticle(
            title: "Brain-Boosting Nutrition",
            content: """
            Fuel your cognitive performance:
            - Intermittent fasting (16:8 pattern)
            - Omega-3 rich foods (wild salmon, walnuts)
            - Antioxidant berries (blueberries, acai)
            - Matcha green tea instead of coffee
            """,
            icon: "fork.knife",
            sourceURL: URL(string: "https://example.com/brain-boosting-nutrition")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Mental Clarity", 
                    value: "+35%", 
                    icon: "lightbulb", 
                    color: "#F59E0B"
                ),
                BiohackingArticle.Metric(
                    label: "Energy Slumps", 
                    value: "-40%", 
                    icon: "chart.line.downtrend.xyaxis", 
                    color: "#FCD34D"
                )
            ]
        ),
        BiohackingArticle(
            title: "Sunlight Exposure",
            content: """
            Morning light regulates circadian rhythm:
            - Get 10-30 mins morning sunlight
            - Use light therapy lamps in winter
            - Avoid bright lights after dark
            - Balance UV exposure with vitamin D
            """,
            icon: "sun.max",
            sourceURL: URL(string: "https://example.com/sunlight-exposure")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Alertness", 
                    value: "+28%", 
                    icon: "sun.max.fill", 
                    color: "#FCD34D"
                ),
                BiohackingArticle.Metric(
                    label: "Sleep Quality", 
                    value: "+22%", 
                    icon: "moon.zzz", 
                    color: "#8B5CF6"
                )
            ]
        ),
        BiohackingArticle(
            title: "Meditation Techniques",
            content: """
            Enhance mental clarity through mindfulness:
            - 10 mins morning breathwork (4-7-8 pattern)
            - Focused attention meditation
            - Binaural beats for deep work sessions
            - NSDR (Non-Sleep Deep Rest) breaks
            """,
            icon: "brain",
            sourceURL: URL(string: "https://example.com/meditation-techniques")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Focus Gain", 
                    value: "+45%", 
                    icon: "brain.head.profile", 
                    color: "#8B5CF6"
                ),
                BiohackingArticle.Metric(
                    label: "Stress Reduction", 
                    value: "-32%", 
                    icon: "waveform.path.ecg", 
                    color: "#C4B5FD"
                )
            ]
        ),
        BiohackingArticle(
            title: "Movement & Exercise",
            content: """
            Strategic physical activity boosts cognition:
            - Morning bodyweight exercises
            - Post-lunch walks (10-15 mins)
            - Isometric holds during breaks
            - Zone 2 cardio for mitochondrial health
            """,
            icon: "figure.walk",
            sourceURL: URL(string: "https://example.com/movement-exercise")!,
            metrics: [
                BiohackingArticle.Metric(
                    label: "Cognitive Speed", 
                    value: "+29%", 
                    icon: "bolt.heart", 
                    color: "#EF4444"
                ),
                BiohackingArticle.Metric(
                    label: "Creativity", 
                    value: "+33%", 
                    icon: "paintbrush.pointed", 
                    color: "#FCA5A5"
                )
            ]
        )
    ]
}
</file>

<file path="SnapTask/ViewModels/FocusViewModel.swift/FocusViewModel.swift">

</file>

<file path="SnapTask/ViewModels/PomodoroViewModel.swift/PomodoroViewModel.swift">
import Foundation
import SwiftUI
import Combine
import OSLog

class PomodoroViewModel: ObservableObject {
    enum PomodoroState {
        case notStarted
        case working
        case onBreak
        case paused
        case completed
    }
    
    // Shared instance for the active Pomodoro session
    static let shared = PomodoroViewModel(settings: PomodoroSettings.defaultSettings)
    
    // Current active task being tracked
    @Published var activeTask: TodoTask?
    
    @Published var state: PomodoroState = .notStarted
    @Published var timeRemaining: TimeInterval
    @Published var currentSession: Int = 1
    @Published var settings: PomodoroSettings
    
    let totalSessions: Int
    @MainActor private var timer: AnyCancellable? {
        didSet { Logger.pomodoro.debug("Timer state updated: \(self.timer != nil)") }
    }
    private var startDate: Date?
    private var pausedTimeRemaining: TimeInterval?
    
    @Published private var completedWorkSessions: Set<Int> = []
    @Published private var completedBreakSessions: Set<Int> = []
    
    init(settings: PomodoroSettings) {
        self.settings = settings
        self.timeRemaining = settings.workDuration
        self.totalSessions = settings.sessionsUntilLongBreak
    }
    
    var progress: Double {
        let total = state == .working ? settings.workDuration : 
                   (currentSession % settings.sessionsUntilLongBreak == 0 ? 
                    settings.longBreakDuration : settings.breakDuration)
        guard total > 0 else {
            Logger.pomodoro.error("Invalid timer duration configuration")
            return 0
        }
        return 1 - (timeRemaining / total)
    }
    
    // Set active task and configure settings
    @MainActor func setActiveTask(_ task: TodoTask) {
        // Check if this is already the active task
        if let activeTask = self.activeTask, activeTask.id == task.id {
            // The same task is already active, don't reset
            return
        }
        
        // It's a different task, reset and set up the new one
        stop()
        self.activeTask = task
        self.settings = task.pomodoroSettings ?? PomodoroSettings.defaultSettings
        self.timeRemaining = settings.workDuration
        self.currentSession = 1
        self.completedWorkSessions = []
        self.completedBreakSessions = []
        self.state = .notStarted
    }
    
    // Check if a specific task is the active one
    func isActiveTask(_ task: TodoTask) -> Bool {
        return activeTask?.id == task.id
    }
    
    // Check if a task is currently active
    var hasActiveTask: Bool {
        return activeTask != nil && (state == .working || state == .onBreak || state == .paused)
    }
    
    @MainActor
    func start() {
        guard timer == nil else { return }
        
        if state == .paused {
            state = pausedState ?? .working
        } else {
            state = .working
        }
        startDate = Date()
        
        timer = Timer.publish(every: 1, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                self?.updateTimer()
            }
    }
    
    @MainActor
    func pause() {
        timer?.cancel()
        timer = nil
        pausedTimeRemaining = timeRemaining
        pausedState = state
        state = .paused
    }
    
    @MainActor
    func resume() {
        guard state == .paused else { return }
        start()
    }
    
    @MainActor
    func skip() {
        if state == .working {
            completedWorkSessions.insert(currentSession - 1)
            state = .onBreak
            timeRemaining = currentSession % settings.sessionsUntilLongBreak == 0 ? 
                settings.longBreakDuration : settings.breakDuration
            start()
        } else {
            completedBreakSessions.insert(currentSession - 1)
            completeBreakSession()
        }
    }
    
    @MainActor
    func stop() {
        timer?.cancel()
        timer = nil
        state = .notStarted
        timeRemaining = settings.workDuration
        currentSession = 1
    }
    
    @MainActor
    private func updateTimer() {
        timeRemaining -= 1
        
        if timeRemaining <= 0 {
            if state == .working {
                completeWorkSession()
            } else {
                completeBreakSession()
            }
        }
    }
    
    @MainActor
    private func completeWorkSession() {
        timer?.cancel()
        timer = nil
        
        completedWorkSessions.insert(currentSession - 1)
        
        if currentSession >= totalSessions {
            state = .completed
            return
        }
        
        state = .onBreak
        timeRemaining = currentSession % settings.sessionsUntilLongBreak == 0 ? 
            settings.longBreakDuration : settings.breakDuration
        startDate = Date()
        start()
    }
    
    @MainActor
    private func completeBreakSession() {
        timer?.cancel()
        timer = nil
        
        completedBreakSessions.insert(currentSession - 1)
        currentSession += 1
        
        if currentSession > totalSessions {
            state = .completed
            return
        }
        
        state = .working
        timeRemaining = settings.workDuration
        startDate = Date()
        start()
    }
    
    private var pausedState: PomodoroState?
    
    func isSessionCompleted(session: Int, isWork: Bool) -> Bool {
        if isWork {
            return completedWorkSessions.contains(session)
        } else {
            return completedBreakSessions.contains(session)
        }
    }
    
    var totalSessionTime: TimeInterval {
        return settings.workDuration + 
            (currentSession % settings.sessionsUntilLongBreak == 0 ? 
                settings.longBreakDuration : settings.breakDuration)
    }
    
    deinit {
        timer?.cancel()
        Logger.pomodoro.info("PomodoroViewModel deinitialized")
    }
}

private extension Logger {
    static let pomodoro = Logger(subsystem: "com.yourapp.SnapTask", category: "Pomodoro")
}
</file>

<file path="SnapTask/ViewModels/QuoteViewModel.swift/QuoteViewModel.swift">
import Foundation

@MainActor
class QuoteViewModel: ObservableObject {
    @Published private(set) var currentQuote = Quote.placeholder
    @Published private(set) var isLoading = false
    
    private let service = QuoteService.shared
    private let defaults = UserDefaults.standard
    
    private struct StorageKeys {
        static let lastFetch = "quote_last_fetch"
        static let text = "quote_text"
        static let author = "quote_author"
    }
    
    init() {
        loadSavedQuote()
        fetchNewQuoteIfNeeded()
    }
    
    private func loadSavedQuote() {
        guard let lastFetch = defaults.object(forKey: StorageKeys.lastFetch) as? Date,
              Calendar.current.isDateInToday(lastFetch),
              let text = defaults.string(forKey: StorageKeys.text),
              let author = defaults.string(forKey: StorageKeys.author) else {
            return
        }
        
        currentQuote = Quote(text: text, author: author)
    }
    
    private func fetchNewQuoteIfNeeded() {
        guard !Calendar.current.isDateInToday(defaults.object(forKey: StorageKeys.lastFetch) as? Date ?? .distantPast) else {
            return
        }
        
        Task {
            isLoading = true
            defer { isLoading = false }
            
            do {
                let quote = try await service.fetchDailyQuote()
                currentQuote = quote
                saveQuote(quote)
            } catch {
                print("Error fetching quote: \(error)")
            }
        }
    }
    
    private func saveQuote(_ quote: Quote) {
        defaults.set(Date(), forKey: StorageKeys.lastFetch)
        defaults.set(quote.text, forKey: StorageKeys.text)
        defaults.set(quote.author, forKey: StorageKeys.author)
    }
    
    func refreshQuote() {
        fetchNewQuoteIfNeeded()
    }
}
</file>

<file path="SnapTask/ViewModels/SettingsViewModel.swift/SettingsViewModel.swift">
import Foundation
import Combine

class SettingsViewModel: ObservableObject {
    static let shared = SettingsViewModel()
    private let categoryManager = CategoryManager.shared
    @Published private(set) var priorities: [Priority] = []
    private let prioritiesKey = "savedPriorities"
    
    init() {
        loadPriorities()
        // Add default categories if none exist
        if categories.isEmpty {
            let defaultCategories = [
                Category(id: UUID(), name: "Work", color: "#FF6B6B"),
                Category(id: UUID(), name: "Study", color: "#4ECDC4"),
                Category(id: UUID(), name: "Sport", color: "#45B7D5")
            ]
            defaultCategories.forEach { addCategory($0) }
        }
    }
    
    // MARK: - Categories
    var categories: [Category] {
        categoryManager.categories
    }
    
    func addCategory(_ category: Category) {
        categoryManager.updateCategory(category)
    }
    
    func updateCategory(_ category: Category) {
        categoryManager.updateCategory(category)
    }
    
    func deleteCategory(_ category: Category) {
        categoryManager.deleteCategory(category)
    }
    
    func removeCategory(at indexSet: IndexSet) {
        indexSet.forEach { index in
            if index < categories.count {
                categoryManager.deleteCategory(categories[index])
            }
        }
    }
    
    // MARK: - Priorities
    func addPriority(_ priority: Priority) {
        if !priorities.contains(priority) {
            priorities.append(priority)
            savePriorities()
        }
    }
    
    func removePriority(at indexSet: IndexSet) {
        priorities.remove(atOffsets: indexSet)
        savePriorities()
    }
    
    private func loadPriorities() {
        if let data = UserDefaults.standard.data(forKey: prioritiesKey),
           let decoded = try? JSONDecoder().decode([Priority].self, from: data) {
            priorities = decoded
        } else {
            // Default priorities
            priorities = [.low, .medium, .high]
            savePriorities()
        }
    }
    
    private func savePriorities() {
        if let encoded = try? JSONEncoder().encode(priorities) {
            UserDefaults.standard.set(encoded, forKey: prioritiesKey)
        }
    }
}
</file>

<file path="SnapTask/ViewModels/StatisticsViewModel.swift/StatisticsViewModel.swift">
import SwiftUI
import Combine
import OSLog
import Foundation

class StatisticsViewModel: ObservableObject {
    struct CategoryStat: Identifiable {
        let id = UUID()
        let name: String
        let color: String
        let hours: Double
    }
    
    struct WeeklyStat: Identifiable {
        let id = UUID()
        let day: String
        let completedTasks: Int
        let totalTasks: Int
    }
    
    enum TimeRange: String, CaseIterable {
        case today = "Today"
        case week = "Week"
        case month = "Month"
        case year = "Year"
        
        var dateRange: (start: Date, end: Date) {
            let calendar = Calendar.current
            let now = Date()
            switch self {
            case .today:
                return (calendar.startOfDay(for: now), now)
            case .week:
                let weekStart = calendar.date(byAdding: .day, value: -7, to: now)!
                return (weekStart, now)
            case .month:
                let monthStart = calendar.date(byAdding: .month, value: -1, to: now)!
                return (monthStart, now)
            case .year:
                let yearStart = calendar.date(byAdding: .year, value: -1, to: now)!
                return (yearStart, now)
            }
        }
    }
    
    @Published private(set) var categoryStats: [CategoryStat] = []
    @Published private(set) var weeklyStats: [WeeklyStat] = []
    @Published private(set) var currentStreak: Int = 0
    @Published private(set) var bestStreak: Int = 0
    @Published var selectedTimeRange: TimeRange = .today
    @Published private(set) var recurringTasks: [TodoTask] = []
    
    // Tasks that should be included in consistency tracking
    var trackedRecurringTasks: [TodoTask] {
        recurringTasks.filter { task in
            if let recurrence = task.recurrence {
                return recurrence.trackInStatistics
            }
            return false
        }
    }
    
    // Make sure we use all recurring tasks in consistency view
    var consistency: [TodoTask] {
        // Use all recurring tasks for consistency view regardless of tracking setting
        recurringTasks
    }
    
    private var cancellables = Set<AnyCancellable>()
    private let taskManager: TaskManager
    private let categoryManager = CategoryManager.shared
    
    init(taskManager: TaskManager = .shared) {
        self.taskManager = taskManager
        setupObservers()
    }
    
    func refreshStats() {
        DispatchQueue.main.async { [weak self] in
            self?.updateStats()
        }
    }
    
    private func setupObservers() {
        // Listen for task updates
        NotificationCenter.default.publisher(for: .tasksDidUpdate)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.updateStats()
            }
            .store(in: &cancellables)
            
        // Listen for category updates
        NotificationCenter.default.publisher(for: .categoriesDidUpdate)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.updateStats()
            }
            .store(in: &cancellables)
        
        // Listen for category manager updates
        categoryManager.$categories
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.updateStats()
            }
            .store(in: &cancellables)
        
        // Listen for task manager updates
        taskManager.$tasks
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.updateStats()
            }
            .store(in: &cancellables)
        
        // Add time range observer
        $selectedTimeRange
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.updateStats()
            }
            .store(in: &cancellables)
    }
    
    private func updateStats() {
        updateCategoryStats()
        updateWeeklyStats()
        updateStreakStats()
        updateRecurringTasks()
        objectWillChange.send()
    }
    
    private func updateCategoryStats() {
        let categories = categoryManager.categories
        let allTasks = taskManager.tasks
        let (startDate, endDate) = selectedTimeRange.dateRange
        
        categoryStats = categories.map { category in
            let categoryTasks = allTasks.filter { task in
                task.category?.id == category.id
            }
            let totalHours = categoryTasks.reduce(0.0) { total, task in
                let taskHours = task.completions
                    .filter { $0.key >= startDate && $0.key <= endDate && $0.value.isCompleted }
                    .reduce(0.0) { sum, completion in
                        sum + (task.hasDuration ? task.duration / 3600.0 : 0)
                    }
                return total + taskHours
            }
            
            return CategoryStat(
                name: category.name,
                color: category.color,
                hours: totalHours
            )
        }.filter { $0.hours > 0 }
    }
    
    private func updateWeeklyStats() {
        let calendar = Calendar.current
        let today = Date()
        let weekStart = calendar.date(byAdding: .day, value: -6, to: today)!
        
        weeklyStats = (0...6).map { dayOffset in
            let date = calendar.date(byAdding: .day, value: dayOffset, to: weekStart)!
            let startOfDay = calendar.startOfDay(for: date)
            let endOfDay = calendar.date(byAdding: .day, value: 1, to: startOfDay)!.addingTimeInterval(-1)
            
            // 1. Filtra le task SINGLE (non ricorrenti) create specificamente per questo giorno
            let singleDayTasks = taskManager.tasks.filter { task in
                task.recurrence == nil && calendar.isDate(task.startTime, inSameDayAs: date)
            }
            
            // 2. Filtra le task RICORRENTI che dovrebbero essere attive in questo giorno
            let recurringDayTasks = taskManager.tasks.filter { task in
                guard let recurrence = task.recurrence else { return false }
                
                // Verifica che la task sia stata creata in o prima di questo giorno
                if task.startTime > endOfDay { return false }
                
                // Verifica la data di fine se esiste
                if let endDate = recurrence.endDate, endDate < startOfDay { return false }
                
                // Controlla il pattern di ricorrenza per questo giorno specifico
                switch recurrence.type {
                case .daily:
                    return true
                case .weekly(let days):
                    let weekday = calendar.component(.weekday, from: date)
                    return days.contains(weekday)
                case .monthly(let days):
                    let day = calendar.component(.day, from: date)
                    return days.contains(day)
                }
            }
            
            // Combina tutte le task attive per questo giorno
            let allDayTasks = singleDayTasks + recurringDayTasks
            
            // Conta quante task sono state completate per questo giorno
            let completedCount = allDayTasks.filter { task in
                if let completion = task.completions[startOfDay], completion.isCompleted {
                    return true
                }
                return false
            }.count
            
            return WeeklyStat(
                day: date.formatted(.dateTime.weekday(.abbreviated)),
                completedTasks: completedCount,
                totalTasks: allDayTasks.count
            )
        }
    }
    
    private func updateStreakStats() {
        // Improve date calculations using Calendar
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        guard let yearAgo = calendar.date(byAdding: .year, value: -1, to: today) else {
            Logger.stats.error("Date calculation failed")
            return
        }
        
        // Genera array di date dal passato a oggi
        var currentDate = yearAgo
        var dates: [Date] = []
        
        while currentDate <= today {
            guard let nextDate = calendar.date(byAdding: .day, value: 1, to: currentDate) else { break }
            dates.append(currentDate)
            currentDate = nextDate
        }
        
        var currentStreak = 0
        var bestStreak = 0
        var tempStreak = 0
        
        // Itera dal giorno più recente al più vecchio
        for date in dates.reversed() {
            let startOfDay = calendar.startOfDay(for: date)
            
            // Ottiene le task per il giorno, includendo quelle ricorrenti
            let dayTasks = taskManager.tasks.filter { task in
                // Verifica che la task sia stata creata in o prima di questo giorno
                guard task.startTime <= startOfDay else { return false }
                
                // Includi task specifiche per questo giorno
                if calendar.isDate(task.startTime, inSameDayAs: date) {
                    return true
                }
                
                // Includi task ricorrenti per questo giorno
                if let recurrence = task.recurrence {
                    // Verifica la data di fine se esiste
                    if let endDate = recurrence.endDate, endDate < startOfDay { return false }
                    
                    switch recurrence.type {
                    case .daily:
                        return true
                    case .weekly(let days):
                        let weekday = calendar.component(.weekday, from: date)
                        return days.contains(weekday)
                    case .monthly(let days):
                        let day = calendar.component(.day, from: date)
                        return days.contains(day)
                    }
                }
                return false
            }
            
            // Controlla se ci sono task per il giorno e se sono tutte completate
            let allCompletedForDay = !dayTasks.isEmpty && dayTasks.allSatisfy { task in
                if let completion = task.completions[startOfDay] {
                    return completion.isCompleted
                }
                return false
            }
            
            if allCompletedForDay {
                tempStreak += 1
                // Aggiorna la striscia migliore
                bestStreak = max(bestStreak, tempStreak)
                
                // Se siamo a oggi, questa è la striscia corrente
                if calendar.isDateInToday(date) {
                    currentStreak = tempStreak
                }
            } else {
                // Se c'è un'interruzione nella striscia
                if tempStreak > 0 && calendar.isDateInToday(date) {
                    // Se l'interruzione è proprio oggi, consideriamo la striscia corrente come 0
                    currentStreak = 0
                }
                tempStreak = 0
            }
        }
        
        self.currentStreak = currentStreak
        self.bestStreak = bestStreak
    }
    
    private func updateRecurringTasks() {
        // Include all recurring tasks regardless of trackInStatistics setting
        recurringTasks = taskManager.tasks.filter { task in 
            task.recurrence != nil
        }
    }
    
    func consistencyPoints(for task: TodoTask, in timeRange: TaskConsistencyChartView.TimeRange) -> [(x: CGFloat, y: CGFloat)] {
        guard let recurrence = task.recurrence else { 
            return [] 
        }
        
        let calendar = Calendar.current
        let today = Date()
        let taskCreationDay = calendar.startOfDay(for: task.startTime)
        var points: [(x: CGFloat, y: CGFloat)] = []
        
        // Determine time range to analyze
        let daysToAnalyze: Int
        switch timeRange {
        case .week:
            daysToAnalyze = 7
        case .month:
            daysToAnalyze = 30
        case .year:
            daysToAnalyze = 365
        }
        
        // Start with zero progress
        var cumulativeProgress: Int = 0
        var foundFirstValidDay = false
        
        // Calculate points for each day in the period
        for dayOffset in (1-daysToAnalyze)...0 {
            let date = calendar.date(byAdding: .day, value: dayOffset, to: today)!
            let startOfDay = calendar.startOfDay(for: date)
            
            // Normalize x position between 0 and 1
            let normalizedX = CGFloat(dayOffset + daysToAnalyze) / CGFloat(daysToAnalyze)
            
            // Skip days before task was created
            if startOfDay < taskCreationDay {
                continue
            }
            
            // We've found the first valid day for this task
            foundFirstValidDay = true
            
            // Check if task should occur on this date based on recurrence pattern
            if shouldTaskOccurOnDate(task: task, date: startOfDay) {
                // Check if task was completed on this day
                let isCompleted = task.completions[startOfDay]?.isCompleted == true
                
                // Update progress: +1 if completed, -1 if not completed
                if isCompleted {
                    cumulativeProgress += 1
                } else {
                    // Penalize missed tasks by decreasing the score
                    cumulativeProgress = max(0, cumulativeProgress - 1)
                }
                
                points.append((x: normalizedX, y: CGFloat(cumulativeProgress)))
            }
        }
        
        // If we have no points but the task exists in the time range, add a starting point
        if points.isEmpty && foundFirstValidDay {
            // Calculate normalized X for task creation date
            let daysDiff = calendar.dateComponents([.day], from: calendar.startOfDay(for: today.addingTimeInterval(-Double(daysToAnalyze-1) * 86400)), to: taskCreationDay).day ?? 0
            let startX = CGFloat(max(0, min(daysToAnalyze, daysDiff))) / CGFloat(daysToAnalyze)
            
            points.append((x: startX, y: 0))
            
            // Add another point at current date if we only have one point
            if points.count == 1 {
                points.append((x: 1.0, y: 0))
            }
        }
        
        return points
    }
    
    // Helper function to check if a task should occur on a specific date
    private func shouldTaskOccurOnDate(task: TodoTask, date: Date) -> Bool {
        guard let recurrence = task.recurrence else { return false }
        
        let calendar = Calendar.current
        
        // Check if task has started
        if date < calendar.startOfDay(for: task.startTime) {
            return false
        }
        
        // Check end date if it exists
        if let endDate = recurrence.endDate, date > endDate {
            return false
        }
        
        // Check recurrence pattern
        switch recurrence.type {
        case .daily:
            return true
        case .weekly(let days):
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
        case .monthly(let days):
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
}

// Add logger extension at the bottom of the file
private extension Logger {
    static let stats = Logger(subsystem: "com.yourapp.SnapTask", category: "Statistics")
}
</file>

<file path="SnapTask/ViewModels/StatsViewModel.swift/StatsViewModel.swift">
import SwiftUI
import Combine
import OSLog
import Foundation
import CoreGraphics

class StatsViewModel: ObservableObject {
    struct ConsistencyPoint {
        let date: Date
        let isCompleted: Bool
        let x: CGFloat
        let y: CGFloat
    }
    
    enum TimeRange: String, CaseIterable {
        case week = "Week"
        case month = "Month"
        case year = "Year"
    }
    
    @Published var selectedTimeRange: TimeRange = .week
    @Published private(set) var recurringTasks: [TodoTask] = []
    
    private let taskManager: TaskManager
    
    init(taskManager: TaskManager = .shared) {
        self.taskManager = taskManager
        updateRecurringTasks()
    }
    
    func refreshStats() {
        updateRecurringTasks()
    }
    
    private func updateRecurringTasks() {
        // Make sure we're getting all recurring tasks
        recurringTasks = taskManager.tasks.filter { $0.recurrence != nil }
        
        // Log for debugging
        print("Found \(recurringTasks.count) recurring tasks:")
        for task in recurringTasks {
            print("- \(task.name) (ID: \(task.id))")
        }
        
        // Force a UI update
        objectWillChange.send()
    }
    
    func consistencyPoints(for task: TodoTask, in timeRange: TimeRange) -> [(x: CGFloat, y: CGFloat)] {
        guard task.recurrence != nil else { 
            print("Task \(task.name) has no recurrence")
            return [] 
        }
        
        let calendar = Calendar.current
        let today = Date()
        var points: [(x: CGFloat, y: CGFloat)] = []
        
        // Determine time range to analyze
        let daysToAnalyze: Int
        switch timeRange {
        case .week:
            daysToAnalyze = 7
        case .month:
            daysToAnalyze = 30
        case .year:
            daysToAnalyze = 365
        }
        
        // Calculate points for each day in the period
        for dayOffset in (1-daysToAnalyze)...0 {
            let date = calendar.date(byAdding: .day, value: dayOffset, to: today)!.startOfDay
            
            // Check if task should occur on this date based on recurrence pattern
            if shouldTaskOccurOnDate(task: task, date: date) {
                // Calculate completion percentage
                let isCompleted = task.completions[date]?.isCompleted == true
                let completionValue: CGFloat = isCompleted ? 1.0 : 0.0
                
                // Normalize x position between 0 and 1
                let normalizedX = CGFloat(dayOffset + daysToAnalyze) / CGFloat(daysToAnalyze)
                
                points.append((x: normalizedX, y: completionValue))
            }
        }
        
        print("Generated \(points.count) points for task \(task.name)")
        return points
    }
    
    // Helper function to check if a task should occur on a specific date
    private func shouldTaskOccurOnDate(task: TodoTask, date: Date) -> Bool {
        guard let recurrence = task.recurrence else { return false }
        
        let calendar = Calendar.current
        
        // Check if task has started
        if date < calendar.startOfDay(for: task.startTime) {
            return false
        }
        
        // Check end date if it exists
        if let endDate = recurrence.endDate, date > endDate {
            return false
        }
        
        // Check recurrence pattern
        switch recurrence.type {
        case .daily:
            return true
        case .weekly(let days):
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
        case .monthly(let days):
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
}
</file>

<file path="SnapTask/ViewModels/TaskFormViewModel.swift/TaskFormViewModel.swift">
import Foundation
import SwiftUI
import Combine

class TaskFormViewModel: ObservableObject {
    @Published var name: String = ""
    @Published var description: String = ""
    @Published var startDate: Date = Date()
    @Published var hasDuration: Bool = false
    @Published var duration: TimeInterval = 3600
    @Published var icon: String = "circle.fill"
    @Published var selectedCategory: Category?
    @Published var selectedPriority: Priority = .medium
    @Published var subtasks: [Subtask] = []
    @Published var isRecurring: Bool = false
    @Published var isDailyRecurrence: Bool = true
    @Published var selectedDays: Set<Int> = []
    @Published var recurrenceEndDate: Date = Date().addingTimeInterval(86400 * 30)
    @Published var trackInStatistics: Bool = true
    @Published var isPomodoroEnabled: Bool = false
    @Published var pomodoroSettings = PomodoroSettings.defaultSettings
    @Published private(set) var categories: [Category] = []
    var taskId: UUID?
    
    private var cancellables = Set<AnyCancellable>()
    private let settingsViewModel = SettingsViewModel.shared
    
    init(initialDate: Date) {
        let calendar = Calendar.current
        let startDate = calendar.date(bySettingHour: 9, minute: 0, second: 0, of: initialDate) ?? initialDate
        self.startDate = startDate
        // Get initial categories
        categories = settingsViewModel.categories
        
        // Listen for category updates
        NotificationCenter.default.publisher(for: .categoriesDidUpdate)
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    self?.categories = SettingsViewModel.shared.categories
                }
            }
            .store(in: &cancellables)
            
        // Add CategoryManager observation
        CategoryManager.shared.$categories
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newCategories in
                self?.categories = newCategories
            }
            .store(in: &cancellables)
    }
    
    var isValid: Bool {
        !name.isEmpty
    }
    
    func createTask() -> TodoTask {
        let id = taskId ?? UUID()
        
        let recurrence: Recurrence? = isRecurring ? {
            if isDailyRecurrence {
                return Recurrence(type: .daily, startDate: self.startDate, endDate: recurrenceEndDate, trackInStatistics: trackInStatistics)
            } else {
                return Recurrence(type: .weekly(days: selectedDays), startDate: self.startDate, endDate: recurrenceEndDate, trackInStatistics: trackInStatistics)
            }
        }() : nil
        
        return TodoTask(
            id: id,
            name: name,
            description: description.isEmpty ? nil : description,
            startTime: startDate,
            duration: duration,
            hasDuration: hasDuration,
            category: selectedCategory,
            priority: selectedPriority,
            icon: icon,
            recurrence: recurrence,
            pomodoroSettings: isPomodoroEnabled ? pomodoroSettings : nil,
            subtasks: subtasks
        )
    }
    
    func addSubtask(name: String) {
        let subtask = Subtask(id: UUID(), name: name, isCompleted: false)
        subtasks.append(subtask)
    }
    
    func removeSubtask(at offsets: IndexSet) {
        subtasks.remove(atOffsets: offsets)
    }
}
</file>

<file path="SnapTask/ViewModels/TaskViewModel.swift/TaskViewModel.swift">
import Foundation
import Combine

class TaskViewModel: ObservableObject {
    @Published private(set) var currentStreak: Int = 0
    private let taskManager = TaskManager.shared
    
    func refreshTask(_ task: TodoTask, for date: Date) {
        currentStreak = task.streakForDate(date)
        objectWillChange.send()
    }
    
    func toggleCompletion(for task: TodoTask, on date: Date) {
        var updatedTask = task
        let startOfDay = date.startOfDay
        
        if let completion = updatedTask.completions[startOfDay]?.isCompleted {
            updatedTask.completions[startOfDay]?.isCompleted = !completion
            
            if !completion {
                if !updatedTask.completionDates.contains(startOfDay) {
                    updatedTask.completionDates.append(startOfDay)
                }
            } else {
                updatedTask.completionDates.removeAll { $0 == startOfDay }
            }
        } else {
            updatedTask.completions[startOfDay] = TaskCompletion(isCompleted: true)
            if !updatedTask.completionDates.contains(startOfDay) {
                updatedTask.completionDates.append(startOfDay)
            }
        }
        
        taskManager.updateTask(updatedTask)
        currentStreak = updatedTask.streakForDate(date)
        objectWillChange.send()
    }
}
</file>

<file path="SnapTask/ViewModels/TimelineViewModel.swift/TimelineViewModel.swift">
import Foundation
import SwiftUI
import Combine

class TimelineViewModel: ObservableObject {
    @Published private(set) var tasks: [TodoTask] = []
    @Published var selectedDate: Date = Date()
    @Published var timelineStartHour: Int = 6
    @Published var timelineEndHour: Int = 22
    private let taskManager = TaskManager.shared
    
    private let tasksKey = "saved_tasks"
    private var cancellables = Set<AnyCancellable>()
    
    @Published private(set) var monthYearString: String = ""
    
    init() {
        updateMonthYearString()
        
        // Observe TaskManager changes
        NotificationCenter.default.publisher(for: .tasksDidUpdate)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.refreshTasks()
            }
            .store(in: &cancellables)
        
        // Observe selected date changes
        $selectedDate
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.updateMonthYearString()
                self?.refreshTasks()
            }
            .store(in: &cancellables)
            
        // Initial load
        refreshTasks()
    }
    
    private func refreshTasks() {
        let calendar = Calendar.current
        _ = calendar.startOfDay(for: selectedDate)
        
        tasks = taskManager.tasks.filter { task in
            // Include tasks specifically for this day
            if calendar.isDate(task.startTime, inSameDayAs: selectedDate) {
                return true
            }
            
            // Include recurring tasks
            if let recurrence = task.recurrence {
                // Check if task has started
                if selectedDate < calendar.startOfDay(for: task.startTime) {
                    return false
                }
                
                // Check end date if it exists
                if let endDate = recurrence.endDate, selectedDate > endDate {
                    return false
                }
                
                switch recurrence.type {
                case .daily:
                    return true
                case .weekly(let days):
                    let weekday = calendar.component(.weekday, from: selectedDate)
                    return days.contains(weekday)
                case .monthly(let days):
                    let day = calendar.component(.day, from: selectedDate)
                    return days.contains(day)
                }
            }
            
            return false
        }.sorted { $0.startTime < $1.startTime }
        
        objectWillChange.send()
    }
    
    func addTask(_ task: TodoTask) {
        print("Adding task: \(task.name)")
        print("Start time: \(task.startTime)")
        print("Recurrence: \(String(describing: task.recurrence))")
        taskManager.addTask(task)
    }
    
    func toggleTaskCompletion(_ taskId: UUID) {
        TaskManager.shared.toggleTaskCompletion(taskId, on: selectedDate)
    }
    
    func toggleSubtask(taskId: UUID, subtaskId: UUID) {
        TaskManager.shared.toggleSubtask(taskId: taskId, subtaskId: subtaskId, on: selectedDate)
    }
    
    func getCompletion(for taskId: UUID, on date: Date) -> TaskCompletion? {
        if let task = tasks.first(where: { $0.id == taskId }) {
            return task.completions[date.startOfDay]
        }
        return nil
    }
    
    var dateString: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        return formatter.string(from: selectedDate)
    }
    
    var isToday: Bool {
        Calendar.current.isDateInToday(selectedDate)
    }
    
    func selectDate(_ offset: Int) {
        selectedDate = Calendar.current.date(
            byAdding: .day,
            value: offset,
            to: Date()
        ) ?? Date()
    }
    
    func tasksForSelectedDate() -> [TodoTask] {
        let calendar = Calendar.current
        let selectedStartOfDay = calendar.startOfDay(for: selectedDate)
        
        return tasks.filter { task in
            // For non-recurring tasks
            if task.recurrence == nil {
                return calendar.isDate(task.startTime, inSameDayAs: selectedDate)
            }
            
            // For recurring tasks
            guard let recurrence = task.recurrence else { return false }
            let taskStartOfDay = calendar.startOfDay(for: task.startTime)
            
            // Only show tasks that have started
            if selectedStartOfDay < taskStartOfDay {
                return false
            }
            
            // Check recurrence pattern
            switch recurrence.type {
            case .daily:
                return true
            case .weekly(let days):
                let weekday = calendar.component(.weekday, from: selectedDate)
                return days.contains(weekday)
            case .monthly(let days):
                let day = calendar.component(.day, from: selectedDate)
                return days.contains(day)
            }
        }
        .sorted { $0.startTime < $1.startTime }
    }
    
    func weekdayString(for offset: Int) -> String {
        guard let date = Calendar.current.date(byAdding: .day, value: offset, to: Date()) else {
            return ""
        }
        let formatter = DateFormatter()
        formatter.dateFormat = "EEE"
        return formatter.string(from: date).lowercased()
    }
    
    func dayString(for offset: Int) -> String {
        guard let date = Calendar.current.date(byAdding: .day, value: offset, to: Date()) else {
            return ""
        }
        let formatter = DateFormatter()
        formatter.dateFormat = "d"
        return formatter.string(from: date)
    }
    
    struct TaskIndicator: Identifiable {
        let id = UUID()
        let color: String
    }
    
    func taskIndicators(for offset: Int) -> [TaskIndicator] {
        guard let date = Calendar.current.date(byAdding: .day, value: offset, to: selectedDate) else {
            return []
        }
        
        return tasksForDate(date).map { task in
            TaskIndicator(color: task.category!.color)
        }
    }
    
    private func categoryColor(for task: TodoTask) -> Color {
        if let category = task.category {
            return Color(hex: category.color)
        }
        return .gray // Default color when no category is set
    }
    
    private func tasksForDate(_ date: Date) -> [TodoTask] {
        let calendar = Calendar.current
        let dateStartOfDay = calendar.startOfDay(for: date)
        
        return tasks.filter { task in
            // For non-recurring tasks
            if task.recurrence == nil {
                return calendar.isDate(task.startTime, inSameDayAs: date)
            }
            
            // For recurring tasks
            guard let recurrence = task.recurrence else { return false }
            let taskStartOfDay = calendar.startOfDay(for: task.startTime)
            
            // Only show tasks that have started
            if dateStartOfDay < taskStartOfDay {
                return false
            }
            
            // Check recurrence pattern without end date limitation
            switch recurrence.type {
            case .daily:
                return true
            case .weekly(let days):
                let weekday = calendar.component(.weekday, from: date)
                return days.contains(weekday)
            case .monthly(let days):
                let day = calendar.component(.day, from: date)
                return days.contains(day)
            }
        }
        .sorted { $0.startTime < $1.startTime }
    }
    
    var dueTasks: [TodoTask] {
        let calendar = Calendar.current
        let now = Date()
        _ = calendar.startOfDay(for: now)
        
        return tasks.filter { task in
            // Get completion status for today
            let completion = getCompletion(for: task.id, on: now)
            let isCompleted = completion?.isCompleted ?? false
            
            // Skip if task is completed
            if isCompleted {
                return false
            }
            
            // Check if task is due today or overdue
            if calendar.isDateInToday(task.startTime) || task.startTime < now {
                return true
            }
            
            // Check recurring tasks
            if let recurrence = task.recurrence {
                // Check if task has started
                if now < calendar.startOfDay(for: task.startTime) {
                    return false
                }
                
                // Check end date if it exists
                if let endDate = recurrence.endDate, now > endDate {
                    return false
                }
                
                // Check recurrence pattern
                switch recurrence.type {
                case .daily:
                    return true
                case .weekly(let days):
                    let weekday = calendar.component(.weekday, from: now)
                    return days.contains(weekday)
                case .monthly(let days):
                    let day = calendar.component(.day, from: now)
                    return days.contains(day)
                }
            }
            
            return false
        }.sorted { $0.startTime < $1.startTime }
    }
    
    var effectiveStartHour: Int {
        if tasks.isEmpty {
            return timelineStartHour
        }
        
        let tasksForDay = tasksForSelectedDate()
        let earliestTask = tasksForDay.min { task1, task2 in
            Calendar.current.component(.hour, from: task1.startTime) <
            Calendar.current.component(.hour, from: task2.startTime)
        }
        
        return earliestTask.map { Calendar.current.component(.hour, from: $0.startTime) } ?? timelineStartHour
    }
    
    var effectiveEndHour: Int {
        if tasks.isEmpty {
            return timelineEndHour
        }
        
        let tasksForDay = tasksForSelectedDate()
        let latestTask = tasksForDay.max { task1, task2 in
            let hour1 = Calendar.current.component(.hour, from: task1.startTime)
            let hour2 = Calendar.current.component(.hour, from: task2.startTime)
            return (hour1 + Int(task1.duration/3600)) <
                   (hour2 + Int(task2.duration/3600))
        }
        
        if let task = latestTask {
            let endHour = Calendar.current.component(.hour, from: task.startTime) +
                         Int(task.duration/3600)
            return min(max(endHour + 1, timelineStartHour), timelineEndHour)
        }
        return timelineEndHour
    }
    
    private func updateMonthYearString() {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        monthYearString = formatter.string(from: selectedDate)
    }
}
</file>

<file path="SnapTask/Views/BiohackingView.swift/BiohackingView.swift">
import SwiftUI

struct BiohackingView: View {
    @StateObject private var viewModel = BiohackingViewModel()
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        NavigationStack {
            List(viewModel.articles) { article in
                NavigationLink {
                    ArticleDetailView(article: article)
                } label: {
                    HStack(spacing: 12) {
                        // Icon with gradient background
                        ZStack {
                            Circle()
                                .fill(LinearGradient(
                                    colors: [
                                        Color(hex: articleColor(for: article.title)).opacity(colorScheme == .dark ? 0.6 : 0.2),
                                        Color(hex: articleColor(for: article.title)).opacity(0.05)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ))
                                .frame(width: 40, height: 40)
                            
                            Image(systemName: article.icon)
                                .font(.system(size: 18, weight: .semibold))
                                .foregroundColor(colorScheme == .dark ? .primary : Color(hex: articleColor(for: article.title)))
                        }
                        
                        Text(article.title)
                            .font(.headline)
                            .foregroundColor(.primary)
                        
                        Spacer()
                        
                        // Progress indicator
                        Circle()
                            .stroke(lineWidth: 2)
                            .frame(width: 12, height: 12)
                            .foregroundColor(.gray.opacity(0.3))
                    }
                    .padding(.vertical, 8)
                }
            }
            .navigationTitle("Biohacking")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
    
    private func articleColor(for title: String) -> String {
        switch title {
        case "Sleep Optimization": return "#6366F1"
        case "Grounding Practices": return "#10B981"
        case "Brain-Boosting Nutrition": return "#F59E0B"
        case "Sunlight Exposure": return "#FCD34D"
        case "Meditation Techniques": return "#8B5CF6"
        case "Movement & Exercise": return "#EF4444"
        default: return "#6B7280"
        }
    }
}

struct ArticleDetailView: View {
    let article: BiohackingArticle
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                headerSection
                productivityImpactSection
                keyPracticesSection
                quickWinsSection
                referenceSection
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 32)
        }
        .background(Color(.systemBackground))
        .navigationTitle(article.title)
        .navigationBarTitleDisplayMode(.inline)
    }
    
    private var headerSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text(article.title)
                .font(.system(.title, weight: .bold))
                .foregroundColor(.primary)
            
            HStack(spacing: 12) {
                ForEach(article.metrics) { metric in
                    MetricBadge(metric: metric)
                }
            }
        }
        .padding(.bottom, 24)
    }
    
    private var productivityImpactSection: some View {
        contentSection(
            title: "Productivity Impact",
            content: article.content.components(separatedBy: "## Productivity Impact").last?.components(separatedBy: "## ").first ?? ""
        )
    }
    
    private var keyPracticesSection: some View {
        contentSection(
            title: "Key Practices",
            content: article.content.components(separatedBy: "## Key Practices").last?.components(separatedBy: "## ").first ?? ""
        )
    }
    
    private var quickWinsSection: some View {
        contentSection(
            title: "Quick Wins",
            content: article.content.components(separatedBy: "## Quick Wins").last?.components(separatedBy: "## ").first ?? ""
        )
    }
    
    private func contentSection(title: String, content: String) -> some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(title)
                .font(.headline)
                .foregroundColor(.primary)
            
            Text(content)
                .font(.body)
                .foregroundColor(.secondary)
                .lineSpacing(6)
        }
        .padding()
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(12)
    }
    
    private var referenceSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Divider()
            ReferenceLink(sourceURL: article.sourceURL)
        }
    }
}

// MARK: - Subviews
private struct MetricBadge: View {
    let metric: BiohackingArticle.Metric
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: metric.icon)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(Color(hex: metric.color))
            
            VStack(alignment: .leading) {
                Text(metric.value)
                    .font(.system(.subheadline, weight: .bold))
                Text(metric.label)
                    .font(.caption2)
            }
        }
        .padding(8)
        .background(Color(.tertiarySystemBackground))
        .cornerRadius(8)
    }
}

// MARK: - View Extensions
private extension Image {
    func iconStyle() -> some View {
        self
            .font(.system(size: 28, weight: .medium))
            .foregroundColor(.accentColor)
            .frame(width: 44, height: 44)
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(12)
    }
    
    func metricIconStyle(color: Color) -> some View {
        self
            .font(.system(size: 20, weight: .medium))
            .foregroundColor(color)
            .frame(width: 36, height: 36)
            .background(Color(.tertiarySystemBackground))
            .cornerRadius(8)
    }
}

private extension Text {
    func valueStyle() -> some View {
        self
            .font(.body.weight(.semibold))
    }
    
    func labelStyle() -> some View {
        self
            .font(.caption)
            .foregroundColor(.secondary)
    }
    
    func sectionHeaderStyle() -> some View {
        self
            .font(.headline)
            .foregroundColor(.primary)
            .padding(.bottom, 4)
    }
    
    func sectionContentStyle() -> some View {
        self
            .font(.body)
            .foregroundColor(.secondary)
            .lineSpacing(6)
    }
}

private extension View {
    func metricContainerStyle() -> some View {
        self
            .padding(12)
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(Color(.secondarySystemBackground))
            .cornerRadius(12)
    }
    
    func sectionContainerStyle() -> some View {
        self
            .padding()
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(Color(.secondarySystemBackground))
            .cornerRadius(12)
    }
}

// MARK: - Helper Extension
private extension BiohackingArticle {
    var contentComponents: [String] {
        content.components(separatedBy: "## ").filter { !$0.isEmpty }
    }
}

private struct MetricCard: View {
    let metric: BiohackingArticle.Metric
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: metric.icon)
                .font(.system(size: 24, weight: .medium))
                .frame(width: 44, height: 44)
                .background(Color(.tertiarySystemBackground))
                .cornerRadius(8)
            
            VStack(spacing: 4) {
                Text(metric.value)
                    .font(.system(size: 20, weight: .bold, design: .rounded))
                    .layoutPriority(1)
                
                Text(metric.label)
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
            }
        }
        .padding(16)
        .frame(width: 150, height: 150)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(16)
        .accessibilityElement(children: .combine)
    }
}

private struct ReferenceLink: View {
    let sourceURL: URL
    
    var body: some View {
        HStack {
            Image(systemName: "book.closed.fill")
                .foregroundColor(.accentColor)
            
            Link("Scientific Reference", destination: sourceURL)
                .font(.subheadline)
                .foregroundColor(.accentColor)
        }
        .padding(.vertical, 12)
        .padding(.horizontal, 16)
        .background(Color(.tertiarySystemBackground))
        .cornerRadius(12)
    }
}
</file>

<file path="SnapTask/Views/CategoriesView.swift/CategoriesView.swift">
import SwiftUI

struct CategoriesView: View {
    @ObservedObject var viewModel: SettingsViewModel
    @State private var showingNewCategorySheet = false
    @State private var editingCategory: Category? = nil
    
    var body: some View {
        List {
            ForEach(viewModel.categories) { category in
                HStack {
                    Circle()
                        .fill(Color(hex: category.color))
                        .frame(width: 12, height: 12)
                    Text(category.name)
                    Spacer()
                    Button(action: { editingCategory = category }) {
                        Image(systemName: "pencil")
                            .foregroundColor(.gray)
                    }
                }
            }
            .onDelete { indexSet in
                viewModel.removeCategory(at: indexSet)
            }
            
            Button(action: { showingNewCategorySheet = true }) {
                Label("Add Category", systemImage: "plus")
            }
        }
        .navigationTitle("Categories")
        .sheet(isPresented: $showingNewCategorySheet) {
            NavigationStack {
                CategoryFormView { category in
                    viewModel.addCategory(category)
                }
            }
        }
        .sheet(item: $editingCategory) { category in
            NavigationStack {
                CategoryFormView(
                    editingCategory: category
                ) { updatedCategory in
                    viewModel.updateCategory(updatedCategory)
                }
            }
        }
    }
}
</file>

<file path="SnapTask/Views/CategoryEditorView.swift/CategoryEditorView.swift">
import SwiftUI

struct CategoryEditorView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = SettingsViewModel.shared
    @State private var newCategoryName = ""
    @State private var selectedColor = "#FF0000"
    @State private var showingColorPicker = false
    @State private var editingCategory: Category? = nil
    
    var body: some View {
        List {
            Section("Add New Category") {
                HStack {
                    TextField("Category Name", text: $newCategoryName)
                    Button("Add") {
                        let newCategory = Category(
                            id: UUID(),
                            name: newCategoryName,
                            color: selectedColor
                        )
                        viewModel.addCategory(newCategory)
                        newCategoryName = ""
                    }
                    .disabled(newCategoryName.isEmpty)
                }
            }
            
            Section("Color") {
                ColorPicker("Select Color", selection: Binding(
                    get: { Color(hex: selectedColor) },
                    set: { selectedColor = $0.toHex() ?? "#FF0000" }
                ))
                .padding(.vertical, 8)
            }
            
            Section {
                ForEach(viewModel.categories) { category in
                    HStack {
                        Button {
                            editingCategory = category
                        } label: {
                            Circle()
                                .fill(Color(hex: category.color))
                                .frame(width: 24, height: 24)
                        }
                        .buttonStyle(.plain)
                        Text(category.name)
                        Spacer()
                        Button(action: {
                            editingCategory = category
                        }) {
                            Image(systemName: "pencil")
                                .foregroundColor(.gray)
                        }
                    }
                }
                .onDelete { indexSet in
                    viewModel.removeCategory(at: indexSet)
                }
            }
        }
        .navigationTitle("Categories")
        .sheet(item: $editingCategory) { category in
            NavigationStack {
                CategoryFormView(
                    editingCategory: category
                ) { updatedCategory in
                    viewModel.updateCategory(updatedCategory)
                }
            }
        }
    }
}

struct ColorPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedColor: String
    let onColorSelected: (String) -> Void
    
    private let colors = [
        "#FF69B4", "#FF0000", "#FFA500", "#FFFF00", 
        "#00FF00", "#0000FF", "#800080", "#A52A2A",
        "#808080", "#000000"
    ]
    
    var body: some View {
        List {
            ForEach(colors, id: \.self) { color in
                Button {
                    onColorSelected(color)
                } label: {
                    HStack {
                        Circle()
                            .fill(Color(hex: color))
                            .frame(width: 24, height: 24)
                        Spacer()
                        if color == selectedColor {
                            Image(systemName: "checkmark")
                                .foregroundColor(.pink)
                        }
                    }
                }
            }
        }
        .navigationTitle("Select Color")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") {
                    dismiss()
                }
            }
        }
    } 
    }
</file>

<file path="SnapTask/Views/CategoryFormView.swift/CategoryFormView.swift">
import SwiftUI

struct CategoryFormView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var name: String
    @State private var color: Color
    private let editingCategory: Category?
    var onSave: (Category) -> Void
    
    init(editingCategory: Category? = nil, onSave: @escaping (Category) -> Void) {
        self.editingCategory = editingCategory
        self.onSave = onSave
        _name = State(initialValue: editingCategory?.name ?? "")
        _color = State(initialValue: editingCategory.map { Color(hex: $0.color) } ?? .red)
    }
    
    var body: some View {
        Form {
            Section {
                TextField("Category Name", text: $name)
                    .autocapitalization(.words)
            }
            
            Section("Color") {
                ColorPicker("Select Color", selection: $color)
                    .padding(.vertical, 8)
            }
        }
        .navigationTitle(editingCategory == nil ? "New Category" : "Edit Category")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") { dismiss() }
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Save") {
                    let category = Category(
                        id: editingCategory?.id ?? UUID(),
                        name: name,
                        color: color.toHex() ?? "#FF0000"
                    )
                    onSave(category)
                    dismiss()
                }
                .disabled(name.isEmpty)
            }
        }
    }
}
</file>

<file path="SnapTask/Views/CategoryPickerView.swift/CategoryPickerView.swift">
import SwiftUI

struct CategoryPickerView: View {
    @Binding var selectedCategory: Category?
    @Environment(\.dismiss) private var dismiss
    @StateObject private var settingsViewModel = SettingsViewModel.shared
    @State private var showingCategoryEditor = false
    @State private var editingCategory: Category? = nil
    
    var body: some View {
        List {
            ForEach(settingsViewModel.categories) { category in
                HStack {
                    Circle()
                        .fill(Color(hex: category.color))
                        .frame(width: 20, height: 20)
                    Text(category.name)
                    Spacer()
                    if selectedCategory?.id == category.id {
                        Image(systemName: "checkmark")
                            .foregroundColor(.accentColor)
                    }
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    if selectedCategory?.id == category.id {
                        selectedCategory = nil
                    } else {
                        selectedCategory = category
                    }
                    dismiss()
                }
            }
            
            Button {
                editingCategory = Category(id: UUID(), name: "", color: "#FF0000")
            } label: {
                Label("Add New Category", systemImage: "plus")
                    .foregroundColor(.accentColor)
            }
        }
        .navigationTitle("Select Category")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Edit") {
                    showingCategoryEditor = true
                }
            }
        }
        .sheet(isPresented: $showingCategoryEditor) {
            NavigationStack {
                CategoryEditorView()
            }
        }
        .sheet(item: $editingCategory) { category in
            NavigationStack {
                CategoryFormView(editingCategory: category) { updatedCategory in
                    if let _ = settingsViewModel.categories.firstIndex(where: { $0.id == updatedCategory.id }) {
                        settingsViewModel.updateCategory(updatedCategory)
                    } else {
                        settingsViewModel.addCategory(updatedCategory)
                        selectedCategory = updatedCategory
                    }
                }
            }
        }
    }
}
</file>

<file path="SnapTask/Views/CategoryRow.swift/CategoryRow.swift">
import SwiftUI

struct CategoryRow: View {
    let category: Category
    
    var body: some View {
        HStack {
            Circle()
                .fill(Color(hex: category.color))
                .frame(width: 20, height: 20)
            Text(category.name)
        }
    }
}
</file>

<file path="SnapTask/Views/Components/CloudSyncStatusView.swift/CloudSyncStatusView.swift">
import SwiftUI

struct CloudSyncStatusView: View {
    @ObservedObject var cloudKitService = CloudKitService.shared
    @State private var isShowingDetails = false
    
    var body: some View {
        VStack {
            HStack {
                if cloudKitService.isSyncing {
                    ProgressView()
                        .padding(.trailing, 5)
                } else if cloudKitService.syncError != nil {
                    Image(systemName: "exclamationmark.icloud.fill")
                        .foregroundColor(.red)
                } else {
                    Image(systemName: "checkmark.icloud.fill")
                        .foregroundColor(.green)
                }
                
                Text(statusText)
                    .font(.footnote)
                
                Spacer()
                
                Button(action: {
                    CloudKitService.shared.syncTasks()
                }) {
                    Image(systemName: "arrow.clockwise")
                        .foregroundColor(.blue)
                }
                .disabled(cloudKitService.isSyncing)
            }
            .padding(.horizontal)
            .contentShape(Rectangle())
            .onTapGesture {
                isShowingDetails.toggle()
            }
            
            if isShowingDetails {
                VStack(alignment: .leading, spacing: 8) {
                    if let error = cloudKitService.syncError {
                        Text("Errore di sincronizzazione:")
                            .font(.caption)
                            .bold()
                        Text(error.localizedDescription)
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                    
                    if let lastSync = cloudKitService.lastSyncDate {
                        Text("Ultima sincronizzazione: \(timeAgoString(from: lastSync))")
                            .font(.caption)
                    }
                    
                    Button("Forza sincronizzazione") {
                        CloudKitService.shared.syncTasks()
                    }
                    .padding(.top, 5)
                    .font(.footnote)
                    .disabled(cloudKitService.isSyncing)
                }
                .padding(.horizontal)
                .padding(.bottom, 10)
                .transition(.move(edge: .top).combined(with: .opacity))
                .animation(.easeInOut, value: isShowingDetails)
            }
        }
        .padding(.vertical, 5)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(8)
    }
    
    private var statusText: String {
        if cloudKitService.isSyncing {
            return "Sincronizzazione in corso..."
        } else if let error = cloudKitService.syncError {
            let errorMessage = error.localizedDescription
            if errorMessage.count > 40 {
                return String(errorMessage.prefix(40)) + "..."
            }
            return errorMessage
        } else if let lastSync = cloudKitService.lastSyncDate {
            return "Sincronizzato \(timeAgoString(from: lastSync))"
        } else {
            return "In attesa di sincronizzazione"
        }
    }
    
    private func timeAgoString(from date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .short
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}

#Preview {
    CloudSyncStatusView()
}
</file>

<file path="SnapTask/Views/Components/ColorPickerGrid.swift/ColorPickerGrid.swift">
import SwiftUI

struct ColorPickerGrid: View {
    @Binding var selectedColor: String
    
    private let presetColors: [[Color]] = [
        [.red, .orange, .yellow, .green],
        [.mint, .teal, .cyan, .blue],
        [.indigo, .purple, .pink, .brown],
        [.gray, .black, .white, .clear]
    ]
    
    var body: some View {
        VStack(spacing: 12) {
            ForEach(presetColors, id: \.self) { row in
                HStack(spacing: 12) {
                    ForEach(row, id: \.self) { color in
                        Button {
                            selectedColor = color.toHex()
                        } label: {
                            Circle()
                                .fill(color)
                                .overlay(
                                    Circle()
                                        .strokeBorder(Color.primary.opacity(0.2), lineWidth: 1)
                                )
                                .overlay(
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.white)
                                        .opacity(selectedColor == color.toHex() ? 1 : 0)
                                )
                                .frame(width: 44, height: 44)
                        }
                    }
                }
            }
            
            ColorPicker("Custom Color", selection: Binding(
                get: { Color(hex: selectedColor) },
                set: { selectedColor = $0.toHex() }
            ))
        }
        .padding(.vertical, 8)
    }
}
</file>

<file path="SnapTask/Views/Components/SubtaskCheckmark.swift/SubtaskCheckmark.swift">
import SwiftUI

struct TaskSubtaskCheckmark: View {
    let isCompleted: Bool
    var onToggle: () -> Void
    
    var body: some View {
        Button(action: onToggle) {
            ZStack {
                Circle()
                    .strokeBorder(isCompleted ? Color.accentColor : Color.gray, lineWidth: 1.5)
                    .frame(width: 24, height: 24)
                
                if isCompleted {
                    Circle()
                        .fill(Color.accentColor)
                        .frame(width: 16, height: 16)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}

#Preview {
    VStack(spacing: 20) {
        TaskSubtaskCheckmark(isCompleted: false, onToggle: {})
        TaskSubtaskCheckmark(isCompleted: true, onToggle: {})
    }
    .padding()
}
</file>

<file path="SnapTask/Views/ContentView.swift/ContentView.swift">
import SwiftUI

struct ContentView: View {
    @StateObject private var timelineViewModel = TimelineViewModel()
    @AppStorage("selectedTab") private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            TimelineView(viewModel: timelineViewModel)
                .tabItem {
                    Label("Timeline", systemImage: "calendar")
                }
                .tag(0)
            
            PomodoroTabView()
                .tabItem {
                    Label("Pomodoro", systemImage: "timer")
                }
                .tag(1)
            
            TaskStatisticsView()
                .tabItem {
                    Label("Stats", systemImage: "chart.bar")
                }
                .tag(2)
            
            SettingsView()
                .tabItem {
                    Label("Settings", systemImage: "gear")
                }
                .tag(3)
        }
    }
}
</file>

<file path="SnapTask/Views/DayPickerView.swift/DayPickerView.swift">
import SwiftUI

struct DayPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var selectedDays: Set<Int>
    
    let weekdays = [
        (1, "Monday"),
        (2, "Tuesday"),
        (3, "Wednesday"),
        (4, "Thursday"),
        (5, "Friday"),
        (6, "Saturday"),
        (7, "Sunday")
    ]
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(weekdays, id: \.0) { day in
                    Button(action: {
                        if selectedDays.contains(day.0) {
                            selectedDays.remove(day.0)
                        } else {
                            selectedDays.insert(day.0)
                        }
                    }) {
                        HStack {
                            Text(day.1)
                            Spacer()
                            if selectedDays.contains(day.0) {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.pink)
                            }
                        }
                    }
                    .foregroundColor(.primary)
                }
            }
            .navigationTitle("Select Days")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
</file>

<file path="SnapTask/Views/DueTasksView.swift/DueTasksView.swift">
import SwiftUI

struct DueTasksView: View {
    @StateObject private var viewModel = TimelineViewModel()
    @State private var currentDate = Date()
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(viewModel.dueTasks) { task in
                    TaskView(
                        task: task,
                        onToggleComplete: { viewModel.toggleTaskCompletion(task.id) },
                        onToggleSubtask: { subtaskId in
                            viewModel.toggleSubtask(taskId: task.id, subtaskId: subtaskId)
                        }
                    )
                    .listRowInsets(EdgeInsets())
                    .listRowBackground(Color.clear)
                    .padding(.vertical, 4)
                }
            }
            .listStyle(.plain)
            .navigationTitle("Due Tasks")
            .overlay(
                Group {
                    if viewModel.dueTasks.isEmpty {
                        ContentUnavailableView(
                            "No Tasks Due",
                            systemImage: "checkmark.circle",
                            description: Text("All caught up!")
                        )
                    }
                }
            )
            .onReceive(Timer.publish(every: 60, on: .main, in: .common).autoconnect()) { _ in
                currentDate = Date()
                // The tasks will update automatically through TaskManager
            }
        }
    }
}
</file>

<file path="SnapTask/Views/DurationPickerView.swift/DurationPickerView.swift">
import SwiftUI

struct DurationPickerView: View {
    @Environment(\.dismiss) private var dismiss
    @Binding var duration: TimeInterval
    @State private var selectedHours: Int
    @State private var selectedMinutes: Int
    
    init(duration: Binding<TimeInterval>) {
        self._duration = duration
        let hours = Int(duration.wrappedValue) / 3600
        let minutes = (Int(duration.wrappedValue) % 3600) / 60
        self._selectedHours = State(initialValue: hours)
        self._selectedMinutes = State(initialValue: minutes)
    }
    
    var body: some View {
        NavigationStack {
            VStack {
                HStack {
                    Picker("Hours", selection: $selectedHours) {
                        ForEach(0...23, id: \.self) { hour in
                            Text("\(hour)h").tag(hour)
                        }
                    }
                    .pickerStyle(.wheel)
                    
                    Picker("Minutes", selection: $selectedMinutes) {
                        ForEach(Array(stride(from: 0, through: 55, by: 5)), id: \.self) { minute in
                            Text("\(minute)m").tag(minute)
                        }
                    }
                    .pickerStyle(.wheel)
                }
                .padding()
            }
            .navigationTitle("Set Duration")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Done") {
                        duration = TimeInterval(selectedHours * 3600 + selectedMinutes * 60)
                        dismiss()
                    }
                }
            }
        }
        .presentationDetents([.height(300)])
    }
}

#Preview {
    DurationPickerView(duration: .constant(3600))
}
</file>

<file path="SnapTask/Views/FocusTabView.swift/FocusTabView.swift">

</file>

<file path="SnapTask/Views/IconPickerView.swift/IconPickerView.swift">
import SwiftUI

struct IconPickerView: View {
    @Binding var selectedIcon: String
    @Environment(\.dismiss) private var dismiss
    
    private let icons = [
        "alarm", "book.fill", "dumbbell.fill", "cup.and.saucer.fill",
        "fork.knife", "bed.double.fill", "car.fill", "airplane",
        "briefcase.fill", "cart.fill", "gift.fill", "heart.fill",
        "house.fill", "lightbulb.fill", "music.note", "pawprint.fill",
        "phone.fill", "star.fill", "gamecontroller.fill", "pencil"
    ]
    
    var body: some View {
        List {
            ForEach(icons, id: \.self) { icon in
                HStack {
                    Image(systemName: icon)
                        .font(.title2)
                    Spacer()
                    if icon == selectedIcon {
                        Image(systemName: "checkmark")
                            .foregroundColor(.blue)
                    }
                }
                .contentShape(Rectangle())
                .onTapGesture {
                    selectedIcon = icon
                    dismiss()
                }
            }
        }
        .navigationTitle("Choose Icon")
        .navigationBarTitleDisplayMode(.inline)
    }
}
</file>

<file path="SnapTask/Views/MonthDayPicker.swift/MonthDayPicker.swift">
import SwiftUI

struct MonthDayPicker: View {
    @Binding var selectedDays: Set<Int>
    
    private let columns = Array(repeating: GridItem(.flexible(), spacing: 8), count: 7)
    private let days = Array(1...31)
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Repeat on days")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            LazyVGrid(columns: columns, spacing: 8) {
                ForEach(days, id: \.self) { day in
                    Button(action: {
                        if selectedDays.contains(day) {
                            selectedDays.remove(day)
                        } else {
                            selectedDays.insert(day)
                        }
                    }) {
                        Text("\(day)")
                            .font(.caption)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 8)
                            .background(selectedDays.contains(day) ? Color.accentColor : Color.secondary.opacity(0.2))
                            .foregroundColor(selectedDays.contains(day) ? .white : .primary)
                            .clipShape(RoundedRectangle(cornerRadius: 8))
                    }
                }
            }
        }
        .padding(.vertical, 8)
    }
}
</file>

<file path="SnapTask/Views/MotivationalQuoteView.swift/MotivationalQuoteView.swift">
import SwiftUI

struct MotivationalQuoteView: View {
    @ObservedObject private var quoteManager = QuoteManager.shared
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("Daily Inspiration")
                    .font(.headline)
                
                Spacer()
                
                // Refresh button
                Button {
                    // Add haptic feedback
                    let generator = UIImpactFeedbackGenerator(style: .medium)
                    generator.impactOccurred()
                    
                    // Refresh the quote
                    Task {
                        await quoteManager.checkAndUpdateQuote()
                    }
                } label: {
                    Image(systemName: "arrow.clockwise")
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.accentColor)
                        .padding(8)
                        .background(
                            Circle()
                                .fill(Color.accentColor.opacity(0.1))
                        )
                }
                .buttonStyle(BorderlessButtonStyle())
            }
            
            if quoteManager.isLoading {
                HStack {
                    Spacer()
                    ProgressView()
                    Spacer()
                }
                .padding(.vertical, 20)
            } else {
                Text("\"\(quoteManager.currentQuote.text)\"")
                    .font(.system(.body, design: .serif, weight: .regular))
                    .italic()
                    .padding(.vertical, 4)
                    .lineSpacing(4)
                
                Text("— \(quoteManager.currentQuote.author)")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .trailing)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.systemBackground))
                .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
        )
        .padding(.horizontal)
    }
}
</file>

<file path="SnapTask/Views/PomodoroSettingsView.swift/PomodoroSettingsView.swift">
import SwiftUI

struct PomodoroSettingsView: View {
    @Binding var settings: PomodoroSettings
    
    var body: some View {
        Form {
            Section("Work Session") {
                Stepper(
                    value: Binding(
                        get: { settings.workDuration / 60 },
                        set: { settings.workDuration = $0 * 60 }
                    ),
                    in: 1...120,
                    step: 5
                ) {
                    HStack {
                        Text("Duration")
                        Spacer()
                        Text("\(Int(settings.workDuration / 60)) min")
                            .foregroundColor(.secondary)
                    }
                }
            }
            
            Section("Break") {
                Stepper(
                    value: Binding(
                        get: { settings.breakDuration / 60 },
                        set: { settings.breakDuration = $0 * 60 }
                    ),
                    in: 1...60,
                    step: 1
                ) {
                    HStack {
                        Text("Short Break")
                        Spacer()
                        Text("\(Int(settings.breakDuration / 60)) min")
                            .foregroundColor(.secondary)
                    }
                }
                
                Stepper(
                    value: Binding(
                        get: { settings.longBreakDuration / 60 },
                        set: { settings.longBreakDuration = $0 * 60 }
                    ),
                    in: 1...120,
                    step: 5
                ) {
                    HStack {
                        Text("Long Break")
                        Spacer()
                        Text("\(Int(settings.longBreakDuration / 60)) min")
                            .foregroundColor(.secondary)
                    }
                }
            }
            
            Section("Sessions") {
                Stepper(
                    value: $settings.sessionsUntilLongBreak,
                    in: 1...10
                ) {
                    HStack {
                        Text("Sessions until long break")
                        Spacer()
                        Text("\(settings.sessionsUntilLongBreak)")
                            .foregroundColor(.secondary)
                    }
                }
            }
        }
        .navigationTitle("Pomodoro Settings")
        .navigationBarTitleDisplayMode(.inline)
    }
}
</file>

<file path="SnapTask/Views/PomodoroTabView.swift/PomodoroTabView.swift">
import SwiftUI

struct PomodoroTabView: View {
    @StateObject private var viewModel = PomodoroViewModel.shared
    
    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Timer Display
                ZStack {
                    // Progress Circle
                    Circle()
                        .stroke(lineWidth: 20)
                        .opacity(0.3)
                        .foregroundColor(viewModel.state == .working ? .blue : .green)
                    
                    Circle()
                        .trim(from: 0.0, to: viewModel.progress)
                        .stroke(style: StrokeStyle(
                            lineWidth: 20,
                            lineCap: .round
                        ))
                        .foregroundColor(viewModel.state == .working ? .blue : .green)
                        .rotationEffect(Angle(degrees: -90))
                        .animation(.linear(duration: 0.1), value: viewModel.progress)
                    
                    // Time and Session Display
                    VStack {
                        Text(timeString(from: viewModel.timeRemaining))
                            .font(.system(size: 50, weight: .bold, design: .rounded))
                            .monospacedDigit()
                        
                        Text(viewModel.state == .working ? "Work" : "Break")
                            .font(.title3)
                            .foregroundColor(viewModel.state == .working ? .blue : .green)
                        
                        if viewModel.state != .notStarted {
                            Text("Session \(viewModel.currentSession) of \(viewModel.totalSessions)")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .padding(40)
                
                // Controls
                HStack(spacing: 30) {
                    if viewModel.state == .paused {
                        Button(action: viewModel.resume) {
                            Image(systemName: "play.circle.fill")
                                .font(.system(size: 50))
                        }
                    } else if viewModel.state != .notStarted {
                        Button(action: viewModel.pause) {
                            Image(systemName: "pause.circle.fill")
                                .font(.system(size: 50))
                        }
                    }
                    
                    Button(action: viewModel.start) {
                        Image(systemName: "play.circle.fill")
                            .font(.system(size: 50))
                    }
                    .disabled(viewModel.state == .working || viewModel.state == .onBreak)
                    
                    Button(action: viewModel.skip) {
                        Image(systemName: "forward.end.circle.fill")
                            .font(.system(size: 50))
                    }
                    .disabled(viewModel.state == .notStarted)
                }
                
                Spacer()
            }
            .padding()
            .navigationTitle("Pomodoro")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    NavigationLink {
                        PomodoroSettingsView(settings: $viewModel.settings)
                    } label: {
                        Image(systemName: "gear")
                    }
                }
            }
        }
    }
    
    private func timeString(from timeInterval: TimeInterval) -> String {
        let minutes = Int(timeInterval) / 60
        let seconds = Int(timeInterval) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}
</file>

<file path="SnapTask/Views/PomodoroView.swift/PomodoroView.swift">
import SwiftUI

struct PomodoroView: View {
    let task: TodoTask
    @StateObject private var viewModel = PomodoroViewModel.shared
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme
    
    init(task: TodoTask) {
        self.task = task
    }
    
    var body: some View {
        VStack(spacing: 16) {
            // Top section with task info
            TaskInfoHeader(task: task)
            
            // Timer Display
            ZStack {
                // Background circle
                Circle()
                    .stroke(lineWidth: 20)
                    .opacity(0.08)
                    .foregroundColor(viewModel.state == .working ? .blue : .green)
                
                // Progress circle
                Circle()
                    .trim(from: 0.0, to: viewModel.progress)
                    .stroke(style: StrokeStyle(
                        lineWidth: 20,
                        lineCap: .round
                    ))
                    .foregroundColor(viewModel.state == .working ? .blue : .green)
                    .rotationEffect(Angle(degrees: -90))
                    .animation(.linear(duration: 0.1), value: viewModel.progress)
                
                // Time and Session Display
                VStack(spacing: 6) {
                    // Session state
                    Text(viewModel.state == .working ? "Focus Time" : "Break Time")
                        .font(.system(.headline, design: .rounded))
                        .foregroundColor(.secondary)
                    
                    // Time remaining
                    Text(timeString(from: viewModel.timeRemaining))
                        .font(.system(size: 52, weight: .bold, design: .rounded))
                        .monospacedDigit()
                        .foregroundColor(viewModel.state == .working ? .blue : .green)
                    
                    // Session progress
                    Text("Session \(viewModel.currentSession) of \(viewModel.totalSessions)")
                        .font(.system(.subheadline, design: .rounded))
                        .foregroundColor(.secondary)
                }
            }
            .frame(height: 220)
            
            // Compact info below time
            HStack(spacing: 16) {
                if let category = task.category {
                    HStack(spacing: 4) {
                        Circle()
                            .fill(Color(hex: category.color))
                            .frame(width: 8, height: 8)
                        
                        Text(category.name)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                if task.hasDuration && task.duration > 0 {
                    HStack(spacing: 4) {
                        Image(systemName: "clock")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Text(formatDuration(task.duration))
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
                
                // Show expected completion time
                if viewModel.state != .notStarted {
                    let completionTime = Date().addingTimeInterval(viewModel.timeRemaining)
                    HStack(spacing: 4) {
                        Image(systemName: "flag.checkered")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Text(formatTimeOnly(completionTime))
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(.horizontal, 16)
            
            // Session Timeline Visualization
            SessionTimelineView(viewModel: viewModel)
                .padding(.horizontal, 16)
            
            Spacer()
            
            // Controls
            HStack(spacing: 30) {
                // Stop Button
                Button(action: {
                    viewModel.stop()
                }) {
                    ZStack {
                        Circle()
                            .fill(Color.red.opacity(0.12))
                            .frame(width: 60, height: 60)
                        
                        Image(systemName: "stop.fill")
                            .font(.system(size: 24))
                            .foregroundColor(.red)
                    }
                }
                .disabled(viewModel.state == .notStarted || viewModel.state == .completed)
                
                // Play/Pause Button (Larger)
                Button(action: {
                    if viewModel.state == .notStarted || viewModel.state == .paused {
                        viewModel.start()
                    } else {
                        viewModel.pause()
                    }
                }) {
                    ZStack {
                        Circle()
                            .fill(viewModel.state == .working ? Color.blue.opacity(0.12) : 
                                  viewModel.state == .onBreak ? Color.green.opacity(0.12) : 
                                  Color.primary.opacity(0.08))
                            .frame(width: 80, height: 80)
                        
                        Image(systemName: viewModel.state == .working || viewModel.state == .onBreak ? 
                              "pause.fill" : "play.fill")
                            .font(.system(size: 30))
                            .foregroundColor(viewModel.state == .working ? .blue : 
                                             viewModel.state == .onBreak ? .green : .primary)
                    }
                    .shadow(color: colorScheme == .dark ? Color.clear : 
                                (viewModel.state == .working ? Color.blue.opacity(0.3) : 
                                 viewModel.state == .onBreak ? Color.green.opacity(0.3) : 
                                 Color.primary.opacity(0.1)),
                            radius: 10, x: 0, y: 5)
                }
                .symbolEffect(.pulse, options: .repeating, isActive: viewModel.state == .working || viewModel.state == .onBreak)
                
                // Skip Button
                Button(action: {
                    viewModel.skip()
                }) {
                    ZStack {
                        Circle()
                            .fill(viewModel.state == .working ? Color.blue.opacity(0.12) : 
                                  viewModel.state == .onBreak ? Color.green.opacity(0.12) : 
                                  Color.primary.opacity(0.08))
                            .frame(width: 60, height: 60)
                        
                        Image(systemName: "forward.fill")
                            .font(.system(size: 24))
                            .foregroundColor(viewModel.state == .working ? .blue : 
                                             viewModel.state == .onBreak ? .green : .primary)
                    }
                }
                .disabled(viewModel.state == .notStarted || viewModel.state == .completed)
            }
            .padding(.bottom, 30)
        }
        .navigationTitle("")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button {
                    dismiss()
                } label: {
                    Text("Done")
                        .fontWeight(.medium)
                }
            }
        }
        .onAppear {
            viewModel.setActiveTask(task)
        }
    }
    
    private func formatTimeOnly(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }
    
    private func timeString(from timeInterval: TimeInterval) -> String {
        let minutes = Int(timeInterval) / 60
        let seconds = Int(timeInterval) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
    
    private func formatDuration(_ minutes: TimeInterval) -> String {
        let hours = Int(minutes) / 60
        let mins = Int(minutes) % 60
        if hours > 0 {
            return "\(hours)h \(mins)m"
        }
        return "\(mins)m"
    }
}

// Task information header
struct TaskInfoHeader: View {
    let task: TodoTask
    
    var body: some View {
        HStack(spacing: 12) {
            // Category color indicator
            if let category = task.category {
                Circle()
                    .fill(Color(hex: category.color))
                    .frame(width: 12, height: 12)
            }
            
            // Task name
            Text(task.name)
                .font(.system(.title3, design: .rounded).weight(.semibold))
                .lineLimit(1)
            
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 4)
    }
}

// Session Timeline Visualization
struct SessionTimelineView: View {
    @ObservedObject var viewModel: PomodoroViewModel
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Segment label with time remaining
            Text("\(formatTime(viewModel.timeRemaining)) remaining")
                .font(.subheadline)
                .foregroundColor(.secondary)
                .padding(.bottom, 4)
            
            // Continuous timeline with proportional segments
            GeometryReader { geo in
                ZStack(alignment: .leading) {
                    // Background track - single continuous bar with visually distinct segments
                    Capsule()
                        .fill(Color.secondary.opacity(0.1))
                        .frame(height: 8)
                    
                    // Progress fill - a single continuous progress bar
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [.blue, .green, .blue, .green],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: calculateTotalProgress(width: geo.size.width), height: 8)
                }
            }
            .frame(height: 8)
            
            // Unified list of segments with connected progress bars
            VStack(spacing: 0) {
                ForEach(0..<viewModel.totalSessions, id: \.self) { sessionIndex in
                    let session = sessionIndex + 1
                                    
                    VStack(spacing: 0) {
                        // Work session
                        UnifiedSessionRow(
                            label: "Focus \(session)",
                            duration: viewModel.settings.workDuration,
                            isActive: session == viewModel.currentSession && viewModel.state == .working,
                            isCompleted: session < viewModel.currentSession || (session == viewModel.currentSession && viewModel.state == .onBreak),
                            progress: session == viewModel.currentSession && viewModel.state == .working ? viewModel.progress : (session < viewModel.currentSession || (session == viewModel.currentSession && viewModel.state == .onBreak) ? 1.0 : 0.0),
                            color: .blue,
                            showConnector: session < viewModel.totalSessions
                        )
                        
                        // Break session (except after last session)
                        if session < viewModel.totalSessions {
                            UnifiedSessionRow(
                                label: "Break \(session)",
                                duration: breakDuration(for: session, viewModel: viewModel),
                                isActive: session == viewModel.currentSession && viewModel.state == .onBreak,
                                isCompleted: session < viewModel.currentSession,
                                progress: session == viewModel.currentSession && viewModel.state == .onBreak ? viewModel.progress : (session < viewModel.currentSession ? 1.0 : 0.0),
                                color: .green,
                                showConnector: true
                            )
                        }
                    }
                }
            }
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color.secondary.opacity(0.03))
            )
        }
    }
    
    private func calculateTotalProgress(width: CGFloat) -> CGFloat {
        // Calculate completed segments
        var progress: CGFloat = 0
        
        // Add completed work sessions
        for session in 1..<viewModel.currentSession {
            progress += calculateSegmentWidth(width, isWork: true, session: session)
            
            if session < viewModel.totalSessions {
                progress += calculateSegmentWidth(width, isWork: false, session: session)
            }
        }
        
        // Add current session progress
        if viewModel.currentSession <= viewModel.totalSessions {
            if viewModel.state == .working {
                progress += calculateSegmentWidth(width, isWork: true, session: viewModel.currentSession) * CGFloat(viewModel.progress)
            } else if viewModel.state == .onBreak {
                // Work segment for current session is completed
                progress += calculateSegmentWidth(width, isWork: true, session: viewModel.currentSession)
                
                // Add break progress
                progress += calculateSegmentWidth(width, isWork: false, session: viewModel.currentSession) * CGFloat(viewModel.progress)
            }
        }
        
        return progress
    }
    
    private func calculateSegmentWidth(_ totalWidth: CGFloat, isWork: Bool, session: Int) -> CGFloat {
        let totalDuration = calculateTotalSessionsDuration()
        let segmentDuration = isWork ? viewModel.settings.workDuration : 
                              (session % viewModel.settings.sessionsUntilLongBreak == 0 ? 
                               viewModel.settings.longBreakDuration : 
                               viewModel.settings.breakDuration)
        
        return totalWidth * (segmentDuration / totalDuration)
    }
    
    private func calculateTotalSessionsDuration() -> TimeInterval {
        var total: TimeInterval = 0
        
        // Add all work segments
        total += viewModel.settings.workDuration * Double(viewModel.totalSessions)
        
        // Add all break segments (one less than total sessions)
        for session in 1..<viewModel.totalSessions {
            total += breakDuration(for: session, viewModel: viewModel)
        }
        
        return total
    }
    
    private func formatTime(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        return "\(minutes) min"
    }
}

// Unified session row with connecting lines
struct UnifiedSessionRow: View {
    let label: String
    let duration: TimeInterval
    let isActive: Bool
    let isCompleted: Bool
    let progress: Double
    let color: Color
    let showConnector: Bool
    
    var body: some View {
        HStack(spacing: 0) {
            // Left connector column
            ZStack {
                if showConnector {
                    Rectangle()
                        .fill(isCompleted ? color : Color.secondary.opacity(0.2))
                        .frame(width: 2)
                }
                
                Circle()
                    .fill(isCompleted ? color : (isActive ? color : Color.secondary.opacity(0.2)))
                    .frame(width: 12, height: 12)
            }
            .frame(width: 20)
            
            // Main content
            VStack(alignment: .leading, spacing: 6) {
                // Label row with progress indicator
                HStack {
                    // Label
                    Text(label)
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(isActive ? color : .primary)
                    
                    Spacer()
                    
                    // Time indicator or checkmark
                    if isCompleted {
                        Image(systemName: "checkmark")
                            .font(.system(size: 12, weight: .bold))
                            .foregroundColor(color)
                    } else {
                        Text("\(Int(duration / 60))m")
                            .font(.system(size: 13))
                            .foregroundColor(.secondary)
                    }
                }
                
                // Progress bar
                ZStack(alignment: .leading) {
                    // Background
                    Capsule()
                        .fill(color.opacity(0.1))
                        .frame(height: 6)
                    
                    // Progress fill
                    Capsule()
                        .fill(color.opacity(isActive ? 1.0 : 0.6))
                        .frame(width: max(0, CGFloat(progress) * UIScreen.main.bounds.width * 0.7), height: 6)
                }
            }
            .padding(.vertical, 10)
            .padding(.horizontal, 12)
            .padding(.leading, 4)
        }
    }
}

func breakDuration(for session: Int, viewModel: PomodoroViewModel) -> TimeInterval {
    return session % viewModel.settings.sessionsUntilLongBreak == 0 ?
        viewModel.settings.longBreakDuration :
        viewModel.settings.breakDuration
}

// Mini Floating Pomodoro Widget
struct MiniPomodoroWidget: View {
    @ObservedObject var viewModel: PomodoroViewModel
    let onTap: () -> Void
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 10) {
                // Status indicator with task type
                HStack(spacing: 4) {
                    Circle()
                        .fill(viewModel.state == .working ? Color.blue : Color.green)
                        .frame(width: 8, height: 8)
                        .opacity(viewModel.state == .paused ? 0.5 : 1.0)
                        .symbolEffect(.pulse, options: .repeating, isActive: viewModel.state == .working || viewModel.state == .onBreak)
                    
                    // Session type
                    Text(viewModel.state == .working ? "Focus" : "Break")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundColor(.secondary)
                        .fixedSize(horizontal: true, vertical: false)
                }
                
                // Time remaining
                Text(timeString(from: viewModel.timeRemaining))
                    .font(.system(size: 14, weight: .semibold, design: .rounded))
                    .monospacedDigit()
                    .foregroundColor(.primary)
                
                // Progress bar
                Capsule()
                    .fill(Color.secondary.opacity(0.2))
                    .frame(height: 4)
                    .overlay(
                        GeometryReader { geo in
                            Capsule()
                                .fill(viewModel.state == .working ? Color.blue : Color.green)
                                .frame(width: max(4, geo.size.width * viewModel.progress))
                        }
                    )
                    .frame(width: 36)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(
                RoundedRectangle(cornerRadius: 20)
                    .fill(colorScheme == .dark ? Color(.systemGray6) : Color.white)
                    .shadow(color: Color.black.opacity(0.15), radius: 6, x: 0, y: 3)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .frame(height: 32)
    }
    
    private func timeString(from timeInterval: TimeInterval) -> String {
        let minutes = Int(timeInterval) / 60
        let seconds = Int(timeInterval) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}
</file>

<file path="SnapTask/Views/RecurrenceSettingsView.swift/RecurrenceSettingsView.swift">
import SwiftUI

struct RecurrenceSettingsView: View {
    @Binding var isDailyRecurrence: Bool
    @Binding var selectedDays: Set<Int>
    
    private let weekdays = [
        (1, "Monday"),
        (2, "Tuesday"),
        (3, "Wednesday"),
        (4, "Thursday"),
        (5, "Friday"),
        (6, "Saturday"),
        (7, "Sunday")
    ]
    
    var body: some View {
        Form {
            Section {
                Toggle("Daily", isOn: $isDailyRecurrence)
                
                if !isDailyRecurrence {
                    ForEach(weekdays, id: \.0) { day in
                        Toggle(day.1, isOn: Binding(
                            get: { selectedDays.contains(day.0) },
                            set: { isSelected in
                                if isSelected {
                                    selectedDays.insert(day.0)
                                } else {
                                    selectedDays.remove(day.0)
                                }
                            }
                        ))
                    }
                }
            }
        }
        .navigationTitle("Repeat Settings")
        .navigationBarTitleDisplayMode(.inline)
    }
}
</file>

<file path="SnapTask/Views/SettingsView.swift/SettingsView.swift">
import SwiftUI

struct SettingsView: View {
    @StateObject private var viewModel = SettingsViewModel()
    @StateObject private var quoteManager = QuoteManager.shared
    @StateObject private var languageManager = LanguageManager.shared
    @StateObject private var cloudKitService = CloudKitService.shared
    @Environment(\.colorScheme) private var colorScheme
    @AppStorage("isDarkMode") private var isDarkMode = false
    @State private var showingLanguagePicker = false
    
    var body: some View {
        NavigationStack {
            List {
                Section("quote_of_the_day".localized) {
                    VStack(alignment: .leading, spacing: 8) {
                        if quoteManager.isLoading {
                            ProgressView()
                                .frame(maxWidth: .infinity, alignment: .center)
                                .padding(.vertical, 8)
                        } else {
                            Text(quoteManager.currentQuote.text)
                                .font(.body)
                                .italic()
                            
                            Text("- \(quoteManager.currentQuote.author)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Button {
                            Task {
                                await quoteManager.forceUpdateQuote()
                            }
                        } label: {
                            Label("new_quote".localized, systemImage: "arrow.clockwise")
                                .font(.caption)
                                .foregroundColor(.accentColor)
                        }
                        .buttonStyle(BorderlessButtonStyle())
                        .padding(.top, 4)
                    }
                    .padding(.vertical, 4)
                }
                
                Section("iCloud Sync") {
                    CloudSyncStatusView()
                        .listRowInsets(EdgeInsets())
                        .padding(.vertical, 5)
                }
                
                Section("customization".localized) {
                    NavigationLink {
                        CategoriesView(viewModel: viewModel)
                    } label: {
                        Label("categories".localized, systemImage: "folder.fill")
                    }
                    
                    NavigationLink {
                        PrioritiesView(viewModel: viewModel)
                    } label: {
                        Label("priorities".localized, systemImage: "flag.fill")
                    }
                }
                
                Section("appearance".localized) {
                    Toggle("dark_mode".localized, isOn: $isDarkMode)
                    
                    Button {
                        showingLanguagePicker = true
                    } label: {
                        HStack {
                            Label("language".localized, systemImage: "globe")
                            Spacer()
                            Text(languageManager.currentLanguage.name)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                Section("performance".localized) {
                    NavigationLink {
                        BiohackingView()
                    } label: {
                        Label("biohacking".localized, systemImage: "bolt.heart")
                    }
                }
            }
            .navigationTitle("settings".localized)
            .onAppear {
                Task {
                    await quoteManager.checkAndUpdateQuote()
                }
                
                // Verifica la sincronizzazione con CloudKit
                cloudKitService.syncTasks()
            }
            .actionSheet(isPresented: $showingLanguagePicker) {
                ActionSheet(
                    title: Text("language".localized),
                    message: Text("Choose a language"),
                    buttons: languageManager.availableLanguages.map { language in
                        .default(Text(language.name)) {
                            languageManager.setLanguage(language.code)
                        }
                    } + [.cancel()]
                )
            }
        }
    }
}

struct PrioritiesView: View {
    @ObservedObject var viewModel: SettingsViewModel
    @State private var showingNewPrioritySheet = false
    
    var body: some View {
        List {
            ForEach(viewModel.priorities, id: \.self) { priority in
                HStack {
                    Image(systemName: priority.icon)
                        .foregroundColor(Color(hex: priority.color))
                    Text(priority.rawValue.capitalized)
                    Spacer()
                }
            }
            .onDelete { indexSet in
                viewModel.removePriority(at: indexSet)
            }
            
            Button(action: { showingNewPrioritySheet = true }) {
                Label("Add Priority", systemImage: "plus")
            }
        }
        .navigationTitle("Priorities")
        .sheet(isPresented: $showingNewPrioritySheet) {
            NavigationStack {
                PriorityFormView { priority in
                    viewModel.addPriority(priority)
                }
            }
        }
    }
}

struct PriorityFormView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var name = ""
    var onSave: (Priority) -> Void
    
    var body: some View {
        Form {
            TextField("Priority Name", text: $name)
            
            // Preview how the priority will look
            if let priority = Priority(rawValue: name.lowercased()) {
                HStack {
                    Image(systemName: priority.icon)
                        .foregroundColor(Color(hex: priority.color))
                    Text("Preview")
                        .foregroundColor(.secondary)
                }
            }
        }
        .navigationTitle("New Priority")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel") { dismiss() }
            }
            ToolbarItem(placement: .confirmationAction) {
                Button("Save") {
                    if let priority = Priority(rawValue: name.lowercased()) {
                        onSave(priority)
                    }
                    dismiss()
                }
                .disabled(Priority(rawValue: name.lowercased()) == nil)
            }
        }
    }
}
</file>

<file path="SnapTask/Views/Statistics/TaskConsistencyView.swift/TaskConsistencyView.swift">
import SwiftUI
import Charts

// Completamente ridisegnato per rimuovere tutti i contenitori limitanti
struct TaskConsistencyView: View {
    @ObservedObject var viewModel: StatisticsViewModel
    @State private var timeRange: TaskConsistencyChartView.TimeRange = .week
    @State private var selectedTaskId: UUID? = nil
    
    var body: some View {
        // Break down the complex view into smaller components
        ConsistencyContentView(
            viewModel: viewModel,
            timeRange: $timeRange,
            selectedTaskId: $selectedTaskId
        )
        .background(Color.clear)
        .listRowBackground(Color.clear)
        .listRowInsets(EdgeInsets())
        .padding(0)
        .frame(width: UIScreen.main.bounds.width)
    }
}

// Extracted content view to simplify the main view
private struct ConsistencyContentView: View {
    @ObservedObject var viewModel: StatisticsViewModel
    @Binding var timeRange: TaskConsistencyChartView.TimeRange
    @Binding var selectedTaskId: UUID?
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("task_consistency".localized)
                .font(.title3.bold())
                .padding(.horizontal, 16)
            
            if viewModel.consistency.isEmpty {
                EmptyConsistencyView()
            } else {
                // Time range selector
                ConsistencyTimeRangeSelector(timeRange: $timeRange)
                
                // Chart with task lines
                ConsistencyChartContainer(
                    viewModel: viewModel,
                    timeRange: timeRange,
                    selectedTaskId: $selectedTaskId
                )
                
                // Task legend
                ConsistencyLegendGrid(
                    tasks: viewModel.consistency,
                    selectedTaskId: $selectedTaskId
                )
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Text("shows_consistency".localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text("x_axis_y_axis".localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text("how_to_read".localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text("points_explanation".localized)
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            .padding(.horizontal, 16)
        }
    }
}

// Time range selector component
private struct ConsistencyTimeRangeSelector: View {
    @Binding var timeRange: TaskConsistencyChartView.TimeRange
    
    var body: some View {
        Picker("Time Range", selection: $timeRange) {
            ForEach(TaskConsistencyChartView.TimeRange.allCases, id: \.self) { range in
                Text(range.rawValue.localized).tag(range)
            }
        }
        .pickerStyle(.segmented)
        .padding(.horizontal, 16)
    }
}

// Chart container component
private struct ConsistencyChartContainer: View {
    @ObservedObject var viewModel: StatisticsViewModel
    let timeRange: TaskConsistencyChartView.TimeRange
    @Binding var selectedTaskId: UUID?
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background grid lines with Y-axis labels
                VStack(spacing: geometry.size.height / 4) {
                    ForEach(0..<5) { index in
                        ZStack {
                            // Grid line
                            Divider().background(Color.gray.opacity(0.2))
                            
                            // Y-axis label
                            if index < 4 { // Skip the bottom line label (0)
                                Text("\(4-index)")
                                    .font(.system(size: 10))
                                    .foregroundColor(.secondary)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .padding(.leading, 4)
                                    .zIndex(1)
                            }
                        }
                    }
                }
                
                // Y-axis title
                Text("Progress")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .rotationEffect(Angle(degrees: -90))
                    .position(x: 8, y: geometry.size.height / 2)
                
                // X-axis date labels
                DateLabelsView(
                    timeRange: timeRange,
                    width: geometry.size.width,
                    height: geometry.size.height
                )
                
                // Task lines
                TaskLinesContainer(
                    tasks: viewModel.consistency,
                    timeRange: timeRange,
                    viewModel: viewModel,
                    width: geometry.size.width - 20,
                    height: geometry.size.height - 40,
                    selectedTaskId: selectedTaskId
                )
                .padding(.leading, 20) // Make space for Y-axis labels
            }
        }
        .frame(height: 300)
    }
}

// Date labels component
private struct DateLabelsView: View {
    let timeRange: TaskConsistencyChartView.TimeRange
    let width: CGFloat
    let height: CGFloat
    
    var body: some View {
        VStack {
            // Date markers
            HStack(spacing: 0) {
                ForEach(getDateLabels(for: timeRange), id: \.self) { label in
                    Text(label)
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .frame(maxWidth: .infinity)
                }
            }
            .padding(.horizontal, 10)
            
            // X-axis title
            Text(getAxisTitle(for: timeRange))
                .font(.caption2)
                .foregroundColor(.secondary)
                .frame(maxWidth: .infinity)
                .padding(.top, 4)
        }
        .offset(y: height / 2 - 15)
    }
    
    // Helper for generating date labels
    private func getDateLabels(for timeRange: TaskConsistencyChartView.TimeRange) -> [String] {
        let formatter = DateFormatter()
        
        let calendar = Calendar.current
        let today = Date()
        
        switch timeRange {
        case .week:
            formatter.dateFormat = "d MMM"
            let dates = [-6, -4, -2, 0].map { offset in
                let date = calendar.date(byAdding: .day, value: offset, to: today)!
                return formatter.string(from: date)
            }
            return dates
        case .month:
            formatter.dateFormat = "d MMM"
            let dates = [-30, -20, -10, 0].map { offset in
                let date = calendar.date(byAdding: .day, value: offset, to: today)!
                return formatter.string(from: date)
            }
            return dates
        case .year:
            formatter.dateFormat = "MMM"
            let dates = [-12, -9, -6, -3, 0].map { offset in
                let date = calendar.date(byAdding: .month, value: offset, to: today)!
                return formatter.string(from: date)
            }
            return dates
        }
    }
    
    // Return a title for the x-axis based on time range
    private func getAxisTitle(for timeRange: TaskConsistencyChartView.TimeRange) -> String {
        switch timeRange {
        case .week:
            return "Last 7 days"
        case .month:
            return "Last 30 days"
        case .year:
            return "Last 12 months"
        }
    }
}

// Task lines container
private struct TaskLinesContainer: View {
    let tasks: [TodoTask]
    let timeRange: TaskConsistencyChartView.TimeRange
    let viewModel: StatisticsViewModel
    let width: CGFloat
    let height: CGFloat
    let selectedTaskId: UUID?
    
    var body: some View {
        ForEach(Array(tasks.enumerated()), id: \.element.id) { index, task in
            let isSelected = selectedTaskId == nil || selectedTaskId == task.id
            
            TaskLineView(
                task: task,
                timeRange: timeRange,
                viewModel: viewModel,
                width: width,
                height: height,
                taskIndex: index,
                isSelected: isSelected
            )
            .padding(.horizontal, 10)
            .opacity(isSelected ? 1.0 : 0.3)
            .animation(.easeInOut(duration: 0.2), value: isSelected)
        }
    }
}

// Rename this to avoid the redeclaration
struct TaskLineView: View {
    let task: TodoTask
    let timeRange: TaskConsistencyChartView.TimeRange
    let viewModel: StatisticsViewModel
    let width: CGFloat
    let height: CGFloat
    let taskIndex: Int
    let isSelected: Bool
    
    // Array of colors to use if task has no category
    private let fallbackColors: [Color] = [.blue, .green, .orange, .purple, .pink, .yellow, .red]
    
    var body: some View {
        let points = viewModel.consistencyPoints(for: task, in: timeRange)
        let taskColor = task.category.map { Color(hex: $0.color) } ?? fallbackColors[taskIndex % fallbackColors.count]
        
        // Only draw if we have points
        if !points.isEmpty {
            ZStack {
                // Draw the line
                Path { path in
                    // Start from the first point
                    let firstPoint = points[0]
                    let x = firstPoint.x * width
                    
                    let maxProgress = points.map { $0.y }.max() ?? 1.0
                    let scale = min(height / (maxProgress + 1), 20.0)
                    let y = height - (firstPoint.y * scale)
                    
                    path.move(to: CGPoint(x: x, y: y))
                    
                    // Connect all points
                    for i in 1..<points.count {
                        let point = points[i]
                        let x = point.x * width
                        let y = height - (point.y * scale)
                        path.addLine(to: CGPoint(x: x, y: y))
                    }
                }
                .stroke(
                    taskColor.opacity(isSelected ? 0.9 : 0.5),
                    style: StrokeStyle(
                        lineWidth: isSelected ? 3 : 2,
                        lineCap: .round,
                        lineJoin: .round
                    )
                )
                
                // Draw dots at each point
                ForEach(0..<points.count, id: \.self) { i in
                    let point = points[i]
                    let x = point.x * width
                    let maxProgress = points.map { $0.y }.max() ?? 1.0
                    let scale = min(height / (maxProgress + 1), 20.0)
                    let y = height - (point.y * scale)
                    
                    Circle()
                        .fill(taskColor)
                        .frame(width: isSelected ? 8 : 5, height: isSelected ? 8 : 5)
                        .position(x: x, y: y)
                }
            }
            .offset(y: CGFloat(taskIndex % 3) * 1.0)
        }
    }
}

// Legend grid component
private struct ConsistencyLegendGrid: View {
    let tasks: [TodoTask]
    @Binding var selectedTaskId: UUID?
    
    var body: some View {
        LazyVGrid(columns: [
            GridItem(.adaptive(minimum: 150, maximum: 200), spacing: 8)
        ], spacing: 8) {
            ForEach(tasks) { task in
                LegendButton(
                    task: task,
                    isSelected: selectedTaskId == task.id,
                    action: {
                        withAnimation {
                            if selectedTaskId == task.id {
                                selectedTaskId = nil
                            } else {
                                selectedTaskId = task.id
                            }
                        }
                    }
                )
            }
        }
        .padding(.horizontal, 16)
    }
}

// Individual legend button
private struct LegendButton: View {
    let task: TodoTask
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                Circle()
                    .fill(task.category.map { Color(hex: $0.color) } ?? .blue)
                    .frame(width: 8, height: 8)
                
                Text(task.name)
                    .font(.caption)
                    .foregroundColor(.primary)
                    .lineLimit(1)
                
                Spacer()
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 10)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isSelected ? 
                          Color.accentColor.opacity(0.15) : 
                          Color.gray.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .strokeBorder(
                                isSelected ? Color.accentColor : Color.clear,
                                lineWidth: 1
                            )
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}

// Semplifichiamo la struttura rimuovendo componenti non necessari
struct EmptyConsistencyView: View {
    var body: some View {
        Text("No consistency data available")
            .foregroundColor(.secondary)
            .frame(maxWidth: .infinity)
            .frame(height: 300)
    }
}

// Simplified chart view
struct SimpleChartView: View {
    let tasks: [TodoTask]
    @Binding var selectedTaskId: UUID?
    
    var body: some View {
        Chart {
            ForEach(tasks) { task in
                let completionRate = calculateCompletionRate(for: task)
                let isSelected = selectedTaskId == task.id || selectedTaskId == nil
                
                BarMark(
                    x: .value("Task", task.name),
                    y: .value("Completion Rate", completionRate)
                )
                .foregroundStyle(
                    isSelected 
                        ? Color.pink.gradient 
                        : Color.pink.opacity(0.3).gradient
                )
                .annotation(position: .top) {
                    Text("\(Int(completionRate * 100))%")
                        .font(.caption)
                        .foregroundColor(isSelected ? .secondary : .secondary.opacity(0.5))
                }
                .opacity(isSelected ? 1.0 : 0.6)
            }
        }
        .chartLegend(.hidden)
        .chartYAxis {
            AxisMarks(position: .leading)
        }
        .chartXAxis {
            AxisMarks(position: .bottom)
        }
        .padding(4)
        .animation(.easeInOut, value: selectedTaskId)
        .overlay(
            GeometryReader { geometry in
                Color.clear.contentShape(Rectangle())
                    .gesture(
                        DragGesture(minimumDistance: 0)
                            .onEnded { value in
                                handleTap(at: value.location, in: geometry.size, tasks: tasks)
                            }
                    )
            }
        )
    }
    
    private func handleTap(at location: CGPoint, in size: CGSize, tasks: [TodoTask]) {
        let barWidth = size.width / CGFloat(tasks.count)
        let index = Int(location.x / barWidth)
        
        if index >= 0 && index < tasks.count {
            withAnimation {
                let tappedTaskId = tasks[index].id
                if selectedTaskId == tappedTaskId {
                    selectedTaskId = nil
                } else {
                    selectedTaskId = tappedTaskId
                }
            }
        }
    }
    
    private func calculateCompletionRate(for task: TodoTask) -> Double {
        let completions = task.completions.values
        if completions.isEmpty {
            return 0.0
        }
        
        let completedCount = completions.filter { $0.isCompleted }.count
        return Double(completedCount) / Double(completions.count)
    }
}

// Keep the original ConsistencyChartView for backward compatibility
struct ConsistencyChartView: View {
    let consistencyData: [TodoTask]
    
    var body: some View {
        if consistencyData.isEmpty {
            EmptyConsistencyView()
        } else {
            SimpleChartView(tasks: consistencyData, selectedTaskId: .constant(nil))
                .frame(height: 300)
        }
    }
}
</file>

<file path="SnapTask/Views/StatisticsView.swift/StatisticsView.swift">
import SwiftUI
import Charts

struct StatisticsView: View {
    @StateObject private var viewModel = StatisticsViewModel()
    @Environment(\.scenePhase) private var scenePhase
    
    var body: some View {
        NavigationStack {
            List {
                Section {
                    VStack(spacing: 8) {
                        HStack(spacing: 8) {
                            ForEach(StatisticsViewModel.TimeRange.allCases, id: \.self) { range in
                                TimeRangeButton(
                                    range: range,
                                    isSelected: viewModel.selectedTimeRange == range,
                                    action: {
                                        withAnimation(.easeInOut(duration: 0.2)) {
                                            viewModel.selectedTimeRange = range
                                        }
                                    }
                                )
                            }
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 4)
                        
                        Chart(viewModel.categoryStats) { stat in
                            SectorMark(
                                angle: .value("Hours", stat.hours),
                                innerRadius: .ratio(0.618),
                                angularInset: 1.5
                            )
                            .cornerRadius(3)
                            .foregroundStyle(Color(hex: stat.color))
                        }
                        .frame(height: 200)
                        
                        ForEach(viewModel.categoryStats) { stat in
                            HStack {
                                Circle()
                                    .fill(Color(hex: stat.color))
                                    .frame(width: 12, height: 12)
                                Text(stat.name)
                                Spacer()
                                Text(String(format: "%.1f hrs", stat.hours))
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                } header: {
                    Text("Time Spent \(viewModel.selectedTimeRange.rawValue)")
                }
                
                Section("Task Completion Rate") {
                    Chart(viewModel.weeklyStats) { stat in
                        BarMark(
                            x: .value("Day", stat.day),
                            y: .value("Tasks", stat.completedTasks)
                        )
                        .foregroundStyle(Color.pink.gradient)
                    }
                    .frame(height: 200)
                }
                
                Section("Streak") {
                    HStack {
                        VStack(alignment: .leading) {
                            Text("\(viewModel.currentStreak)")
                                .font(.system(size: 34, weight: .bold, design: .rounded))
                            Text("Current Streak")
                                .foregroundColor(.secondary)
                        }
                        Spacer()
                        VStack(alignment: .trailing) {
                            Text("\(viewModel.bestStreak)")
                                .font(.system(size: 34, weight: .bold, design: .rounded))
                            Text("Best Streak")
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
            .navigationTitle("Statistics")
        }
        .onAppear {
            viewModel.refreshStats()
        }
        .onChange(of: scenePhase) { oldPhase, newPhase in
            if newPhase == .active {
                viewModel.refreshStats()
            }
        }
        .refreshable {
            viewModel.refreshStats()
        }
    }
}

private struct TimeRangeButton: View {
    let range: StatisticsViewModel.TimeRange
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(range.rawValue)
                .font(.system(.subheadline, design: .rounded, weight: isSelected ? .semibold : .medium))
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .frame(maxWidth: .infinity)
                .background(
                    RoundedRectangle(cornerRadius: 10)
                        .fill(isSelected ? 
                            Color.accentColor.opacity(0.15) : 
                            Color.gray.opacity(0.1))
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .strokeBorder(
                                    isSelected ? Color.accentColor : Color.clear,
                                    lineWidth: 1.5
                                )
                        )
                )
                .foregroundColor(isSelected ? .accentColor : .primary)
        }
        .buttonStyle(.plain)
        .animation(.easeInOut(duration: 0.2), value: isSelected)
    }
}
</file>

<file path="SnapTask/Views/StatsView.swift/StatsView.swift">
import SwiftUI
import Charts

struct TaskStatisticsView: View {
    @StateObject private var viewModel = StatisticsViewModel()
    @Environment(\.scenePhase) private var scenePhase
    
    var body: some View {
        NavigationStack {
            List {
                Section {
                    VStack(spacing: 8) {
                        // Time range selector
                        timeRangeSelector
                        
                        // Category chart
                        categoryChart
                        
                        // Category legend
                        categoryLegend
                    }
                }
                
                Section {
                    // Weekly stats
                    weeklyStatsView
                }
                
                // Remove the Section wrapper completely
                TaskConsistencyView(viewModel: viewModel)
                    .listRowInsets(EdgeInsets()) // Remove all insets
                    .padding(0) // Remove all padding
                    .background(Color.clear) // Clear background
                    .listRowBackground(Color.clear) // Clear row background
                
                Section {
                    // Streak info
                    streakInfoView
                }
            }
            .listStyle(.plain)
            .navigationTitle("Statistics")
            .onAppear {
                viewModel.refreshStats()
            }
            .onChange(of: scenePhase) { _, newPhase in
                if newPhase == .active {
                    viewModel.refreshStats()
                }
            }
            .onChange(of: viewModel.selectedTimeRange) { _, _ in
                viewModel.refreshStats()
            }
        }
    }
    
    // Suddividiamo la vista in componenti più piccoli per evitare problemi di compilazione
    private var timeRangeSelector: some View {
        HStack(spacing: 8) {
            ForEach(StatisticsViewModel.TimeRange.allCases, id: \.self) { range in
                TimeRangeButton(
                    range: range,
                    isSelected: viewModel.selectedTimeRange == range,
                    action: {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            viewModel.selectedTimeRange = range
                        }
                    }
                )
            }
        }
        .padding(.vertical, 8)
        .padding(.horizontal, 4)
    }
    
    private var categoryChart: some View {
        ZStack {
            if viewModel.categoryStats.isEmpty {
                VStack(spacing: 8) {
                    Image(systemName: "chart.pie")
                        .font(.system(size: 40))
                        .foregroundColor(.secondary.opacity(0.5))
                    
                    Text("No category data available")
                        .font(.headline)
                        .foregroundColor(.secondary)
                    
                    Text("Complete tasks with categories to see stats")
                        .font(.caption)
                        .foregroundColor(.secondary.opacity(0.7))
                        .multilineTextAlignment(.center)
                }
                .padding(20)
                .frame(height: 200)
            } else {
                Chart(viewModel.categoryStats) { stat in
                    SectorMark(
                        angle: .value("Hours", stat.hours),
                        innerRadius: .ratio(0.618),
                        angularInset: 1.5
                    )
                    .cornerRadius(3)
                    .foregroundStyle(Color(hex: stat.color))
                }
                .frame(height: 200)
            }
        }
    }
    
    private var categoryLegend: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                ForEach(viewModel.categoryStats) { stat in
                    HStack(spacing: 4) {
                        Circle()
                            .fill(Color(hex: stat.color))
                            .frame(width: 8, height: 8)
                        Text(stat.name)
                            .font(.caption)
                        Text(String(format: "%.1f h", stat.hours))
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    .padding(.vertical, 4)
                    .padding(.horizontal, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
            }
            .padding(.top, 4)
        }
    }
    
    private var weeklyStatsView: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Weekly Overview")
                .font(.headline)
            
            HStack(spacing: 8) {
                ForEach(viewModel.weeklyStats) { stat in
                    VStack(spacing: 4) {
                        Text(stat.day)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        ZStack(alignment: .bottom) {
                            RoundedRectangle(cornerRadius: 4)
                                .fill(Color.gray.opacity(0.2))
                                .frame(width: 30, height: 100)
                            
                            RoundedRectangle(cornerRadius: 4)
                                .fill(Color.accentColor)
                                .frame(width: 30, height: stat.totalTasks > 0 ? CGFloat(stat.completedTasks) / CGFloat(stat.totalTasks) * 100 : 0)
                        }
                        
                        Text("\(stat.completedTasks)/\(stat.totalTasks)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }
            }
            .padding(.vertical, 8)
        }
    }
    
    private var streakInfoView: some View {
        HStack(spacing: 24) {
            VStack {
                Text("\(viewModel.currentStreak)")
                    .font(.system(.title, design: .rounded, weight: .bold))
                    .foregroundColor(.accentColor)
                Text("Current Streak")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            Divider()
                .frame(height: 40)
            
            VStack {
                Text("\(viewModel.bestStreak)")
                    .font(.system(.title, design: .rounded, weight: .bold))
                    .foregroundColor(.accentColor)
                Text("Best Streak")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding(.vertical, 8)
    }
}

// Nuovo componente per il grafico di consistenza
struct TaskConsistencyChartView: View {
    @ObservedObject var viewModel: StatisticsViewModel
    @State private var timeRange: TimeRange = .week
    
    enum TimeRange: String, CaseIterable {
        case week = "week"
        case month = "month"
        case year = "year"
    }
    
    var body: some View {
        VStack(spacing: 12) {
            Text("Task Consistency")
                .font(.headline)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal)
            
            // Integrated time range selector
            Picker("Time Range", selection: $timeRange) {
                ForEach(TimeRange.allCases, id: \.self) { range in
                    Text(range.rawValue).tag(range)
                }
            }
            .pickerStyle(.segmented)
            .padding(.horizontal)
            
            // Chart Container
            GeometryReader { geometry in
                ZStack(alignment: .bottomLeading) {
                    // Background grid
                    VStack(spacing: 0) {
                        ForEach(0..<4) { i in
                            Spacer()
                            HStack {
                                // Y-axis label
                                Text("\(3-i)")
                                    .font(.system(size: 9))
                                    .foregroundColor(.secondary)
                                    .frame(width: 10)
                                
                                Rectangle()
                                    .frame(height: 1)
                                    .foregroundColor(.gray.opacity(0.2))
                            }
                        }
                    }
                    
                    // Y-axis label
                    Text("Progress")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                        .rotationEffect(Angle(degrees: -90))
                        .position(x: 15, y: geometry.size.height / 2)
                    
                    // X-axis (bottom line)
                    Rectangle()
                        .frame(height: 1.5)
                        .foregroundColor(.gray.opacity(0.4))
                        .frame(width: geometry.size.width - 35)
                        .position(x: (geometry.size.width - 35) / 2 + 25, y: geometry.size.height - 10)
                    
                    // X-axis date labels
                    HStack(spacing: 0) {
                        ForEach(getDateLabels(for: timeRange), id: \.self) { dateLabel in
                            Text(dateLabel)
                                .font(.caption2)
                                .foregroundColor(.secondary)
                                .frame(width: (geometry.size.width - 35) / CGFloat(getDateLabels(for: timeRange).count))
                        }
                    }
                    .padding(.horizontal, 10)
                    .padding(.leading, 15)
                    .position(x: geometry.size.width / 2, y: geometry.size.height - 2)
                    
                    // Draw individual task lines
                    if viewModel.consistency.isEmpty {
                        Text("No recurring tasks found")
                            .foregroundColor(.secondary)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                    } else {
                        // Task lines
                        ForEach(Array(viewModel.consistency.enumerated()), id: \.element.id) { index, task in
                            SingleTaskLineView(
                                task: task,
                                timeRange: timeRange,
                                viewModel: viewModel,
                                width: geometry.size.width - 35,
                                height: geometry.size.height - 20,
                                taskIndex: index
                            )
                            .padding(.horizontal, 10)
                            .padding(.leading, 15)
                        }
                    }
                }
                .padding(.bottom, 10) // Space for X-axis labels
            }
            .frame(height: 220)
            
            // Description 
            VStack(alignment: .leading, spacing: 4) {
                Text("Tracking consistency in completing recurring tasks")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                Text("Y-axis: Progress points (+1 for each completed task)")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .leading)
                
                Text("Higher points indicate better consistency over time")
                    .font(.caption2)
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
            .padding(.horizontal)
            
            // Improved task legend with scrollable grid
            ScrollView {
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 120))], spacing: 8) {
                    ForEach(Array(viewModel.consistency.enumerated()), id: \.element.id) { index, task in
                        HStack(spacing: 6) {
                            let color = task.category.map { Color(hex: $0.color) } ?? 
                                      [Color.blue, .green, .orange, .purple, .pink, .yellow, .red][index % 7]
                            
                            Circle()
                                .fill(color)
                                .frame(width: 8, height: 8)
                            
                            Text(task.name)
                                .font(.caption)
                                .lineLimit(1)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, 4)
                        .padding(.horizontal, 8)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(6)
                    }
                }
                .padding(.horizontal)
            }
            .frame(height: min(CGFloat(viewModel.consistency.count) * 20, 80))
        }
        .padding(.vertical)
        .background(Color(.secondarySystemBackground))
        .cornerRadius(10)
        .padding(.horizontal)
    }
    
    // Helper for generating date labels (keep existing implementation)
    private func getDateLabels(for timeRange: TimeRange) -> [String] {
        let formatter = DateFormatter()
        formatter.dateFormat = "d MMM"
        
        let shortFormatter = DateFormatter()
        shortFormatter.dateFormat = "d"
        
        let calendar = Calendar.current
        let today = Date()
        
        switch timeRange {
        case .week:
            return (-6...0).map { offset in
                let date = calendar.date(byAdding: .day, value: offset, to: today)!
                return shortFormatter.string(from: date)
            }
        case .month:
            let labels = [-30, -25, -20, -15, -10, -5, 0].map { offset in
                let date = calendar.date(byAdding: .day, value: offset, to: today)!
                return shortFormatter.string(from: date)
            }
            return labels
        case .year:
            let labels = [-12, -10, -8, -6, -4, -2, 0].map { offset in
                let date = calendar.date(byAdding: .month, value: offset, to: today)!
                return formatter.string(from: date)
            }
            return labels
        }
    }
    
    private func convertTimeRange(_ statsTimeRange: StatisticsViewModel.TimeRange) -> TaskConsistencyChartView.TimeRange {
        switch statsTimeRange {
        case .today:
            return .week // Default to week for "today" since TaskConsistencyChartView doesn't have a "today" option
        case .week:
            return .week
        case .month:
            return .month
        case .year:
            return .year
        }
    }
}

// Reimplementazione di SingleTaskLineView per renderla più pulita
struct SingleTaskLineView: View {
    let task: TodoTask
    let timeRange: TaskConsistencyChartView.TimeRange
    let viewModel: StatisticsViewModel
    let width: CGFloat
    let height: CGFloat
    let taskIndex: Int
    
    // Array of colors to use if task has no category
    private let fallbackColors: [Color] = [.blue, .green, .orange, .purple, .pink, .yellow, .red]
    
    var body: some View {
        let points = viewModel.consistencyPoints(for: task, in: timeRange)
        let taskColor = task.category.map { Color(hex: $0.color) } ?? fallbackColors[taskIndex % fallbackColors.count]
        
        // Only draw if we have points
        if !points.isEmpty {
            ZStack {
                // Draw the line
                Path { path in
                    // Start from the first point
                    let firstPoint = points[0]
                    let x = firstPoint.x * width
                    
                    // Y in base al progresso, partendo dal basso (asse X)
                    // Il valore y più grande è height (top), il più piccolo è 0 (bottom)
                    let maxProgress = points.map { $0.y }.max() ?? 1.0
                    let scale = min(height / (maxProgress + 1), 20.0) // Scale factor per point of progress
                    let y = height - (firstPoint.y * scale)
                    
                    path.move(to: CGPoint(x: x, y: y))
                    
                    // Connect all points
                    for i in 1..<points.count {
                        let point = points[i]
                        let x = point.x * width
                        let y = height - (point.y * scale)
                        path.addLine(to: CGPoint(x: x, y: y))
                    }
                }
                .stroke(
                    taskColor.opacity(0.7),
                    style: StrokeStyle(lineWidth: 2, lineCap: .round, lineJoin: .round)
                )
                
                // Draw dots at each point
                ForEach(0..<points.count, id: \.self) { i in
                    let point = points[i]
                    let x = point.x * width
                    let maxProgress = points.map { $0.y }.max() ?? 1.0
                    let scale = min(height / (maxProgress + 1), 20.0)
                    let y = height - (point.y * scale)
                    
                    Circle()
                        .fill(taskColor)
                        .frame(width: 5, height: 5)
                        .position(x: x, y: y)
                }
            }
            .offset(y: CGFloat(taskIndex % 3) * 1.0) // Leggerissimo offset per distinguere linee sovrapposte
        }
    }
}

private struct TimeRangeButton: View {
    let range: StatisticsViewModel.TimeRange
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(range.rawValue)
                .font(.system(.subheadline, design: .rounded, weight: isSelected ? .semibold : .medium))
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .frame(maxWidth: .infinity)
                .background(
                    RoundedRectangle(cornerRadius: 10)
                        .fill(isSelected ? 
                            Color.accentColor.opacity(0.15) : 
                            Color.gray.opacity(0.1))
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .strokeBorder(
                                    isSelected ? Color.accentColor : Color.clear,
                                    lineWidth: 1.5
                                )
                        )
                )
                .foregroundColor(isSelected ? .accentColor : .primary)
        }
        .buttonStyle(.plain)
        .animation(.easeInOut(duration: 0.2), value: isSelected)
    }
}
</file>

<file path="SnapTask/Views/TaskCard.swift/TaskCard.swift">
import SwiftUI
import Foundation

struct TaskCard: View {
    let task: TodoTask
    let onToggleComplete: () -> Void
    let onToggleSubtask: (UUID) -> Void
    @ObservedObject var viewModel: TimelineViewModel
    @State private var isExpanded = false
    @State private var showingPomodoro = false
    
    // Calcola se la task è completata per la data corrente
    private var isCompleted: Bool {
        if let completion = task.completions[Date().startOfDay] {
            return completion.isCompleted
        }
        return false
    }
    
    // Calcola le subtask completate per la data corrente
    private var completedSubtasks: Set<UUID> {
        if let completion = task.completions[Date().startOfDay] {
            return completion.completedSubtasks
        }
        return []
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            // Header della task
            HStack(alignment: .center) {
                // Checkmark
                Button(action: onToggleComplete) {
                    TaskCheckmark(isCompleted: isCompleted)
                }
                .buttonStyle(BorderlessButtonStyle())
                .contentShape(Rectangle())
                .frame(width: 24, height: 24)
                
                // Titolo e categoria
                VStack(alignment: .leading, spacing: 2) {
                    Text(task.name)
                        .font(.headline)
                        .foregroundColor(isCompleted ? .secondary : .primary)
                        .strikethrough(isCompleted)
                    
                    if let category = task.category {
                        HStack(spacing: 4) {
                            Circle()
                                .fill(Color(hex: category.color))
                                .frame(width: 8, height: 8)
                            Text(category.name)
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                Spacer()
                
                // Pulsante Pomodoro (se disponibile)
                if task.pomodoroSettings != nil {
                    Button(action: {
                        PomodoroViewModel.shared.setActiveTask(task)
                        showingPomodoro = true
                    }) {
                        ZStack {
                            Circle()
                                .fill(Color.accentColor.opacity(0.15))
                                .frame(width: 36, height: 36)
                                
                            Image(systemName: "timer")
                                .font(.system(size: 16, weight: .medium))
                                .foregroundColor(.accentColor)
                        }
                        .overlay(
                            Circle()
                                .strokeBorder(Color.accentColor.opacity(0.5), lineWidth: 1)
                        )
                        .shadow(color: Color.accentColor.opacity(0.2), radius: 2, x: 0, y: 1)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
                
                // Pulsante espandi (se ci sono subtask)
                if !task.subtasks.isEmpty {
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            isExpanded.toggle()
                        }
                    }) {
                        Image(systemName: "chevron.down")
                            .rotationEffect(.degrees(isExpanded ? 180 : 0))
                            .foregroundColor(.secondary)
                            .padding(8)
                    }
                    .buttonStyle(BorderlessButtonStyle())
                    .padding(.leading, -8) // Spostato più a sinistra
                }
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
            
            // Subtasks (se espanso)
            if isExpanded {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(task.subtasks) { subtask in
                        SubtaskRow(
                            subtask: subtask,
                            isCompleted: completedSubtasks.contains(subtask.id),
                            onToggle: {
                                onToggleSubtask(subtask.id)
                            }
                        )
                        .padding(.horizontal, 12)
                    }
                }
                .padding(.vertical, 8)
                .transition(.move(edge: .top).combined(with: .opacity))
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(.secondarySystemBackground))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
        .sheet(isPresented: $showingPomodoro) {
            PomodoroView(task: task)
        }
    }
}

// MARK: - TaskCheckmark
struct TaskCheckmark: View {
    let isCompleted: Bool
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(isCompleted ? Color.accentColor : Color.gray.opacity(0.5), lineWidth: 1.5)
                .frame(width: 22, height: 22)
            
            if isCompleted {
                Circle()
                    .fill(Color.accentColor)
                    .frame(width: 22, height: 22)
                
                Image(systemName: "checkmark")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(.white)
            }
        }
    }
}

// MARK: - SubtaskRow
struct SubtaskRow: View {
    let subtask: Subtask
    let isCompleted: Bool
    let onToggle: () -> Void
    
    var body: some View {
        HStack {
            Button(action: onToggle) {
                SubtaskCheckmark(isCompleted: isCompleted)
            }
            .buttonStyle(BorderlessButtonStyle())
            .contentShape(Rectangle())
            .frame(width: 20, height: 20)
            
            Text(subtask.name)
                .font(.subheadline)
                .foregroundColor(isCompleted ? .secondary : .primary)
                .strikethrough(isCompleted)
            
            Spacer()
        }
    }
}

// MARK: - SubtaskCheckmark
struct SubtaskCheckmark: View {
    let isCompleted: Bool
    
    var body: some View {
        ZStack {
            Circle()
                .stroke(isCompleted ? Color.accentColor : Color.gray.opacity(0.5), lineWidth: 1.5)
                .frame(width: 18, height: 18)
            
            if isCompleted {
                Circle()
                    .fill(Color.accentColor)
                    .frame(width: 18, height: 18)
                
                Image(systemName: "checkmark")
                    .font(.system(size: 10, weight: .bold))
                    .foregroundColor(.white)
            }
        }
    }
}
</file>

<file path="SnapTask/Views/TaskDetailView.swift/TaskDetailView.swift">
import SwiftUI

struct TaskDetailView: View {
    let task: TodoTask
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Task details implementation
                Text(task.name)
                    .font(.title)
                
                if let description = task.description {
                    Text(description)
                        .foregroundColor(.secondary)
                }
                
                // Add more task details as needed
            }
            .padding()
        }
        .navigationTitle("Task Details")
    }
}
</file>

<file path="SnapTask/Views/TaskFormView.swift/TaskFormView.swift">
import SwiftUI

struct TaskFormView: View {
    @ObservedObject var viewModel: TaskFormViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var newSubtaskName = ""
    @State private var showingPomodoroSettings = false
    @State private var showDurationPicker = false
    @State private var showDayPicker = false
    var onSave: (TodoTask) -> Void
    
    var body: some View {
        NavigationStack {
            Form {
                Section("Task Details") {
                    TextField("Task Name", text: $viewModel.name)
                    TextField("Description", text: $viewModel.description, axis: .vertical)
                        .lineLimit(3...6)
                    NavigationLink {
                        IconPickerView(selectedIcon: $viewModel.icon)
                    } label: {
                        HStack {
                            Text("Icon")
                            Spacer()
                            Image(systemName: viewModel.icon)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                
                Section("Time") {
                    DatePicker("Start Time", selection: $viewModel.startDate)
                    HStack {
                        Text("Duration")
                        Spacer()
                        HStack(spacing: 8) {
                            if viewModel.hasDuration {
                                Button(action: { showDurationPicker = true }) {
                                    let hours = Int(viewModel.duration) / 3600
                                    let minutes = (Int(viewModel.duration) % 3600) / 60
                                    Text(hours > 0 ? "\(hours)h \(minutes)m" : "\(minutes)m")
                                        .foregroundColor(.secondary)
                                }
                            }
                            Toggle("", isOn: $viewModel.hasDuration)
                        }
                    }
                }
                
                Section("Category & Priority") {
                    NavigationLink {
                        CategoryPickerView(selectedCategory: $viewModel.selectedCategory)
                    } label: {
                        HStack {
                            Text("Category")
                            Spacer()
                            if let category = viewModel.selectedCategory {
                                Circle()
                                    .fill(Color(hex: category.color))
                                    .frame(width: 20, height: 20)
                                    .overlay(
                                        Circle()
                                            .strokeBorder(Color.primary.opacity(0.2), lineWidth: 1)
                                    )
                                Text(category.name)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    
                    Picker("Priority", selection: $viewModel.selectedPriority) {
                        ForEach(Priority.allCases, id: \.self) { priority in
                            Label(priority.rawValue.capitalized, systemImage: priority.icon)
                                .foregroundColor(Color(hex: priority.color))
                                .tag(priority)
                        }
                    }
                }
                
                Section("Recurrence") {
                    Toggle("Repeat Task", isOn: $viewModel.isRecurring)
                    if viewModel.isRecurring {
                        NavigationLink {
                            RecurrenceSettingsView(
                                isDailyRecurrence: $viewModel.isDailyRecurrence,
                                selectedDays: $viewModel.selectedDays
                            )
                        } label: {
                            HStack {
                                Text("Frequency")
                                Spacer()
                                Text(viewModel.isDailyRecurrence ? "Daily" : "\(viewModel.selectedDays.count) days")
                                    .foregroundColor(.secondary)
                            }
                        }
                        
                        Toggle("track_in_consistency".localized, isOn: $viewModel.trackInStatistics)
                            .font(.subheadline)
                            .padding(.top, 4)
                    }
                }
                
                Section("Subtasks") {
                    HStack {
                        TextField("New Subtask", text: $newSubtaskName)
                        Button("Add") {
                            if !newSubtaskName.isEmpty {
                                viewModel.addSubtask(name: newSubtaskName)
                                newSubtaskName = ""
                            }
                        }
                    }
                    
                    ForEach(viewModel.subtasks) { subtask in
                        Text(subtask.name)
                    }
                    .onDelete { indexSet in
                        viewModel.removeSubtask(at: indexSet)
                    }
                }
                
                Section {
                    Toggle("Pomodoro Mode", isOn: $viewModel.isPomodoroEnabled)
                    
                    if viewModel.isPomodoroEnabled {
                        NavigationLink("Pomodoro Settings") {
                            PomodoroSettingsView(settings: $viewModel.pomodoroSettings)
                        }
                    }
                }
            }
            .navigationTitle("New Task")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        let task = viewModel.createTask()
                        if viewModel.taskId != nil {
                            TaskManager.shared.updateTask(task)
                        } else {
                            TaskManager.shared.addTask(task)
                        }
                        dismiss()
                    }
                    .disabled(!viewModel.isValid)
                }
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
            .sheet(isPresented: $showDurationPicker) {
                DurationPickerView(duration: $viewModel.duration)
            }
        }
    }
    
    private func formatDuration(_ minutes: Int) -> String {
        let hours = minutes / 60
        let mins = minutes % 60
        if hours > 0 {
            return "\(hours)h \(mins)m"
        }
        return "\(mins)m"
    }
}

extension TaskFormView {
    init(initialTask: TodoTask) {
        let viewModel = TaskFormViewModel(initialDate: initialTask.startTime)
        viewModel.taskId = initialTask.id
        viewModel.name = initialTask.name
        viewModel.description = initialTask.description ?? ""
        viewModel.startDate = initialTask.startTime
        viewModel.hasDuration = initialTask.hasDuration
        viewModel.duration = initialTask.duration
        viewModel.selectedCategory = initialTask.category
        viewModel.selectedPriority = initialTask.priority
        viewModel.icon = initialTask.icon
        viewModel.subtasks = initialTask.subtasks
        viewModel.isRecurring = initialTask.recurrence != nil
        if let recurrence = initialTask.recurrence {
            switch recurrence.type {
            case .daily:
                viewModel.isDailyRecurrence = true
            case .weekly(let days):
                viewModel.isDailyRecurrence = false
                viewModel.selectedDays = Set(days)
            case .monthly:
                break // Gestire se necessario
            }
            viewModel.recurrenceEndDate = recurrence.endDate ?? Date().addingTimeInterval(86400 * 30)
            viewModel.trackInStatistics = recurrence.trackInStatistics
        }
        viewModel.isPomodoroEnabled = initialTask.pomodoroSettings != nil
        if let pomodoroSettings = initialTask.pomodoroSettings {
            viewModel.pomodoroSettings = pomodoroSettings
        }
        
        self.init(
            viewModel: viewModel,
            onSave: { updatedTask in
                TaskManager.shared.updateTask(updatedTask)
            }
        )
    }
}

#Preview {
    TaskFormView(
        viewModel: TaskFormViewModel(initialDate: Date()),
        onSave: { _ in }
    )
}
</file>

<file path="SnapTask/Views/TaskRow.swift/TaskRow.swift">
import SwiftUI

struct TaskRow: View {
    let task: TodoTask
    var onToggleComplete: () -> Void
    var onToggleSubtask: (UUID) -> Void
    
    var body: some View {
        TaskView(
            task: task,
            onToggleComplete: onToggleComplete,
            onToggleSubtask: onToggleSubtask
        )
    }
}
</file>

<file path="SnapTask/Views/TaskRowView.swift/TaskRowView.swift">
import SwiftUI

struct TaskRowView: View {
    @Binding var task: TodoTask
    @StateObject private var viewModel = TaskViewModel()
    @Environment(\.scenePhase) private var scenePhase
    @State private var showingEditSheet = false
    let date: Date
    @State private var offset: CGFloat = 0
    
    var body: some View {
        List {
            VStack(spacing: 8) {
                HStack {
                    // Task completion indicator
                    Button(action: {
                        viewModel.toggleCompletion(for: task, on: date)
                    }) {
                        Image(systemName: task.completions[date.startOfDay]?.isCompleted == true ? "checkmark.circle.fill" : "circle")
                            .foregroundColor(task.completions[date.startOfDay]?.isCompleted == true ? .green : .gray)
                            .font(.title2)
                    }
                    
                    VStack(alignment: .leading, spacing: 6) {
                        // Task name and category
                        HStack {
                            Text(task.name)
                                .font(.headline)
                            
                            if let category = task.category {
                                Circle()
                                    .fill(Color(hex: category.color))
                                    .frame(width: 8, height: 8)
                            }
                        }
                        
                        if ((task.description?.isNilOrEmpty) == nil) {
                            Text(task.description ?? "")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .lineLimit(2)
                        }
                        
                        // Task details
                        if task.hasDuration {
                            Text(formatDuration(task.duration))
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                    
                    Spacer()
                    
                    // Streak indicator
                    if task.recurrence != nil {
                        let streak = task.streakForDate(date)
                        HStack(spacing: 4) {
                            Image(systemName: "flame.fill")
                                .foregroundColor(.orange)
                            Text("\(streak)")
                                .font(.system(.caption, design: .rounded).bold())
                                .foregroundColor(.orange)
                        }
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.orange.opacity(0.15))
                        )
                    }
                    
                    // Priority indicator
                    Circle()
                        .fill(priorityColor(task.priority))
                        .frame(width: 8, height: 8)
                        .padding(.leading, 4)
                }
                
                // Subtasks section
                if !task.subtasks.isEmpty {
                    VStack(alignment: .leading, spacing: 4) {
                        ForEach(task.subtasks) { subtask in
                            HStack {
                                Image(systemName: task.completions[date.startOfDay]?.completedSubtasks.contains(subtask.id) == true ? "checkmark.circle.fill" : "circle")
                                    .foregroundColor(task.completions[date.startOfDay]?.completedSubtasks.contains(subtask.id) == true ? .green : .gray)
                                    .font(.subheadline)
                                Text(subtask.name)
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    .padding(.leading)
                }
            }
            .frame(minHeight: 250)
            .padding(.vertical, 16)
            .padding(.horizontal, 12)
            .background(Color(.systemBackground))
            .cornerRadius(12)
            .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
            .contentShape(Rectangle())
            .offset(x: offset)
            .gesture(
                DragGesture()
                    .onChanged { gesture in
                        if gesture.translation.width < 0 {
                            withAnimation(.spring()) {
                                offset = max(-100, gesture.translation.width)
                            }
                        }
                    }
                    .onEnded { gesture in
                        withAnimation(.spring()) {
                            if offset < -50 {
                                offset = -100
                            } else {
                                offset = 0
                            }
                        }
                    }
            )
            .overlay(
                HStack(spacing: -8) {
                    Button {
                        withAnimation(.spring()) {
                            editTask()
                            offset = 0
                        }
                    } label: {
                        Image(systemName: "pencil.circle.fill")
                            .font(.system(size: 44))
                            .foregroundStyle(.blue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Button {
                        withAnimation(.spring()) {
                            deleteTask()
                            offset = 0
                        }
                    } label: {
                        Image(systemName: "trash.circle.fill")
                            .font(.system(size: 44))
                            .foregroundStyle(.red)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.trailing, 16)
                .opacity(offset < 0 ? 1 : 0)
                .frame(maxWidth: .infinity, alignment: .trailing)
                , alignment: .trailing
            )
            .listRowBackground(Color.clear)
            .listRowInsets(EdgeInsets())
        }
        .listStyle(PlainListStyle())
        .sheet(isPresented: $showingEditSheet) {
            NavigationStack {
                TaskFormView(initialTask: task)
            }
        }
        .onAppear {
            viewModel.refreshTask(task, for: date)
        }
        .onChange(of: scenePhase) { oldPhase, newPhase in
            if newPhase == .active {
                viewModel.refreshTask(task, for: date)
            }
        }
        .onChange(of: task) { oldTask, newTask in
            viewModel.refreshTask(newTask, for: date)
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = Int(duration) / 60 % 60
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        }
        return "\(minutes)m"
    }
    
    private func priorityColor(_ priority: Priority) -> Color {
        switch priority {
        case .high:
            return .red
        case .medium:
            return .orange
        case .low:
            return .green
        }
    }
    
    private func deleteTask() {
        TaskManager.shared.removeTask(task)
    }
    
    private func editTask() {
        showingEditSheet = true
    }
}

extension String {
    var isNilOrEmpty: Bool {
        self.isEmpty
    }
}
</file>

<file path="SnapTask/Views/TaskView.swift/TaskView.swift">
import SwiftUI

struct TaskView: View {
    let task: TodoTask
    let onToggleComplete: () -> Void
    let onToggleSubtask: (UUID) -> Void
    @Environment(\.colorScheme) private var colorScheme
    @State private var showingPomodoro = false
    @StateObject private var taskManager = TaskManager.shared
    
    private var isCompleted: Bool {
        if let completion = task.completions[Date().startOfDay] {
            return completion.isCompleted
        }
        return false
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack(alignment: .center, spacing: 8) {
                VStack(alignment: .leading, spacing: 2) {
                    Text(task.name)
                        .font(.headline)
                        .foregroundColor(.primary)
                        .padding(.leading, 8)
                    
                    if let description = task.description {
                        Text(description)
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                            .lineLimit(1)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                Spacer()
                
                if task.hasDuration && task.duration > 0 {
                    Text(formatDuration(task.duration))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                if task.pomodoroSettings != nil {
                    Button(action: { 
                        PomodoroViewModel.shared.setActiveTask(task)
                        showingPomodoro = true
                    }) {
                        ZStack {
                            Circle()
                                .fill(Color.accentColor.opacity(0.15))
                                .frame(width: 36, height: 36)
                                
                            Image(systemName: "timer")
                                .font(.system(size: 16, weight: .medium))
                                .foregroundColor(task.category.map { Color(hex: $0.color) } ?? .accentColor)
                        }
                        .overlay(
                            Circle()
                                .strokeBorder(Color.accentColor.opacity(0.5), lineWidth: 1)
                        )
                        .shadow(color: Color.accentColor.opacity(0.2), radius: 2, x: 0, y: 1)
                    }
                }
                
                Button(action: onToggleComplete) {
                    Image(systemName: isCompleted ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(isCompleted ? .green : .gray)
                        .font(.title2)
                }
                .buttonStyle(BorderlessButtonStyle())
                .contentShape(Rectangle())
                .frame(width: 44, height: 44)
            }
            
            if !task.subtasks.isEmpty {
                ProgressView(value: task.completionProgress, total: 1.0)
                    .tint(task.category.map { Color(hex: $0.color) } ?? .gray)
                    .animation(.spring(response: 0.3, dampingFraction: 0.8), value: task.completionProgress)
                
                ForEach(task.subtasks) { subtask in
                    HStack {
                        Button(action: { onToggleSubtask(subtask.id) }) {
                            SubtaskCheckmark(isCompleted: subtask.isCompleted)
                        }
                        .buttonStyle(BorderlessButtonStyle())
                        
                        Text(subtask.name)
                            .font(.subheadline)
                            .foregroundColor(isCompleted ? .secondary : .primary)
                            .strikethrough(isCompleted)
                        
                        Spacer()
                    }
                    .contentShape(Rectangle())
                }
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 4)
        .frame(maxWidth: .infinity, minHeight: 50)
        .background(
            RoundedRectangle(cornerRadius: 14)
                .fill(colorScheme == .dark ? Color(.systemGray6) : .white)
                .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
        )
        .sheet(isPresented: $showingPomodoro) {
            PomodoroView(task: task)
        }
        .onChange(of: task.completions) { oldValue, newValue in
            taskManager.updateTask(task)
        }
    }
    
    private func formatDuration(_ duration: TimeInterval) -> String {
        let hours = Int(duration) / 3600
        let minutes = Int(duration) / 60 % 60
        if hours > 0 {
            return "\(hours)h \(minutes)m"
        }
        return "\(minutes)m"
    }
}

#Preview {
    TaskView(
        task: TodoTask(
            name: "Sample Task",
            startTime: Date(),
            duration: 3600,
            category: Category(id: UUID(), name: "Work", color: "#FF0000")
        ),
        onToggleComplete: {},
        onToggleSubtask: { _ in }
    )
    .padding()
}
</file>

<file path="SnapTask/Views/TimelineView.swift/TimelineView.swift">
import SwiftUI

struct TimelineView: View {
    @StateObject var viewModel: TimelineViewModel
    @State private var showingNewTask = false
    @State private var selectedDayOffset = 0
    @State private var showingCalendarPicker = false
    @State private var scrollProxy: ScrollViewProxy?
    
    var body: some View {
        NavigationStack {
            GeometryReader { geometry in
                VStack(spacing: 0) {
                    // Header con mese e selettore data
                    TimelineHeaderView(
                        viewModel: viewModel,
                        selectedDayOffset: $selectedDayOffset,
                        showingCalendarPicker: $showingCalendarPicker,
                        scrollProxy: $scrollProxy
                    )
                    .background(Color(.systemBackground))
                    .zIndex(1)
                    
                    // Lista task e pulsante aggiungi
                    TaskListView(
                        viewModel: viewModel,
                        showingNewTask: $showingNewTask
                    )
                    .frame(maxHeight: .infinity)
                }
            }
            .navigationBarHidden(true)
            .sheet(isPresented: $showingNewTask) {
                TaskFormView(
                    viewModel: TaskFormViewModel(initialDate: viewModel.selectedDate),
                    onSave: { task in
                        viewModel.addTask(task)
                    }
                )
            }
            .sheet(isPresented: $showingCalendarPicker) {
                CalendarPickerView(
                    selectedDate: $viewModel.selectedDate,
                    selectedDayOffset: $selectedDayOffset,
                    viewModel: viewModel,
                    scrollProxy: scrollProxy
                )
            }
        }
    }
}

// MARK: - Header View
struct TimelineHeaderView: View {
    @ObservedObject var viewModel: TimelineViewModel
    @Binding var selectedDayOffset: Int
    @Binding var showingCalendarPicker: Bool
    @Binding var scrollProxy: ScrollViewProxy?
    
    var body: some View {
        VStack(spacing: 4) {
            // Titolo mese e anno
            HStack {
                Text(viewModel.monthYearString)
                    .font(.title2.bold())
                Spacer()
                Button(action: { showingCalendarPicker = true }) {
                    Image(systemName: "calendar")
                        .foregroundColor(.pink)
                }
            }
            .padding(.horizontal)
            .padding(.top, 8)
            
            // Selettore date orizzontale
            DateSelectorView(
                viewModel: viewModel,
                selectedDayOffset: $selectedDayOffset,
                scrollProxy: $scrollProxy
            )
        }
    }
}

// MARK: - Date Selector
struct DateSelectorView: View {
    @ObservedObject var viewModel: TimelineViewModel
    @Binding var selectedDayOffset: Int
    @Binding var scrollProxy: ScrollViewProxy?
    @State private var isDragging = false
    @State private var dragOffset: CGFloat = 0
    
    var body: some View {
        ZStack {
            // Indicatore centrale fisso (rimosso il rettangolo azzurro)
            
            ScrollViewReader { proxy in
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(-365...365, id: \.self) { offset in
                            DayCell(
                                date: Calendar.current.date(
                                    byAdding: .day,
                                    value: offset,
                                    to: Date()
                                ) ?? Date(),
                                isSelected: offset == selectedDayOffset,
                                offset: offset
                            ) { _ in
                                withAnimation {
                                    selectedDayOffset = offset
                                    viewModel.selectDate(offset)
                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                    
                                    // Assicurati che la data selezionata sia centrata
                                    proxy.scrollTo(offset, anchor: .center)
                                }
                            }
                            .id(offset)
                            .scaleEffect(offset == selectedDayOffset ? 1.08 : 1.0)
                            .animation(.spring(response: 0.3), value: offset == selectedDayOffset)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.vertical, 6) // Aggiunto padding verticale per evitare il taglio
                }
                .onAppear {
                    scrollProxy = proxy
                    // Centra la data selezionata all'avvio
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        withAnimation {
                            proxy.scrollTo(selectedDayOffset, anchor: .center)
                        }
                    }
                }
                // Aggiornato per iOS 17+
                .onChange(of: selectedDayOffset) { _, newValue in
                    // Centra la data selezionata quando cambia
                    withAnimation {
                        proxy.scrollTo(newValue, anchor: .center)
                    }
                }
                .simultaneousGesture(
                    DragGesture()
                        .onChanged { value in
                            isDragging = true
                            dragOffset = value.translation.width
                        }
                        .onEnded { value in
                            isDragging = false
                            let velocity = value.predictedEndLocation.x - value.location.x
                            
                            if abs(velocity) > 50 {
                                let direction = velocity > 0 ? -1 : 1
                                let newOffset = selectedDayOffset + direction
                                
                                withAnimation {
                                    selectedDayOffset = newOffset
                                    viewModel.selectDate(newOffset)
                                    proxy.scrollTo(newOffset, anchor: .center)
                                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                }
                            } else {
                                // Calcola l'offset più vicino in base alla posizione di trascinamento
                                let cellWidth: CGFloat = 62 // 50 (width) + 12 (spacing)
                                let estimatedOffset = Int(round(dragOffset / cellWidth))
                                let newOffset = selectedDayOffset - estimatedOffset
                                
                                if newOffset != selectedDayOffset {
                                    withAnimation {
                                        selectedDayOffset = newOffset
                                        viewModel.selectDate(newOffset)
                                        proxy.scrollTo(newOffset, anchor: .center)
                                        UIImpactFeedbackGenerator(style: .light).impactOccurred()
                                    }
                                } else {
                                    // Se non cambia l'offset, assicurati che la vista torni alla posizione centrale
                                    withAnimation {
                                        proxy.scrollTo(selectedDayOffset, anchor: .center)
                                    }
                                }
                            }
                        }
                )
            }
        }
    }
}

// MARK: - Task List View
struct TaskListView: View {
    @ObservedObject var viewModel: TimelineViewModel
    @Binding var showingNewTask: Bool
    @StateObject private var pomodoroViewModel = PomodoroViewModel.shared
    @State private var showingActivePomodoroSession = false
    
    var body: some View {
        ZStack {
            ScrollView {
                LazyVStack(spacing: 8) {
                    ForEach(viewModel.tasksForSelectedDate().indices, id: \.self) { index in
                        TimelineTaskCard(
                            task: viewModel.tasksForSelectedDate()[index],
                            onToggleComplete: { viewModel.toggleTaskCompletion(viewModel.tasksForSelectedDate()[index].id) },
                            onToggleSubtask: { subtaskId in
                                viewModel.toggleSubtask(taskId: viewModel.tasksForSelectedDate()[index].id, subtaskId: subtaskId)
                            },
                            viewModel: viewModel
                        )
                        .padding(.horizontal, 4)
                        .padding(.top, index == 0 ? 8 : 0)
                        .padding(.bottom, 0)
                        .frame(maxWidth: .infinity)
                    }
                }
                .padding(.horizontal, 4)
                .padding(.bottom, 100)
            }
            
            // Centered Add Button and Active Pomodoro Widget
            VStack {
                Spacer()
                
                // Position the floating widget above the add button
                VStack(spacing: 0) {
                    // Active Pomodoro Widget (if available)
                    if pomodoroViewModel.hasActiveTask {
                        MiniPomodoroWidget(viewModel: pomodoroViewModel) {
                            showingActivePomodoroSession = true
                        }
                        .padding(.bottom, 10)
                        .zIndex(1)
                    }
                    
                    // Add Button
                    AddTaskButton(isShowingTaskForm: $showingNewTask)
                }
                .padding(.bottom, 16)
            }
        }
        .sheet(isPresented: $showingActivePomodoroSession) {
            if pomodoroViewModel.activeTask != nil {
                NavigationStack {
                    PomodoroView(task: pomodoroViewModel.activeTask!)
                }
            }
        }
    }
}

// MARK: - Calendar Picker View
struct CalendarPickerView: View {
    @Binding var selectedDate: Date
    @Binding var selectedDayOffset: Int
    @ObservedObject var viewModel: TimelineViewModel
    let scrollProxy: ScrollViewProxy?
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationStack {
            VStack {
                DatePicker("",
                          selection: $selectedDate,
                          displayedComponents: [.date])
                    .datePickerStyle(.graphical)
                    .padding()
                
                Button("Done") {
                    let calendar = Calendar.current
                    let today = Date()
                    if let daysDiff = calendar.dateComponents([.day], from: today, to: selectedDate).day {
                        withAnimation {
                            selectedDayOffset = daysDiff
                            viewModel.selectDate(daysDiff)
                            scrollProxy?.scrollTo(daysDiff, anchor: .center)
                        }
                    }
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
                .padding(.bottom)
            }
            .navigationBarHidden(true)
            .presentationDetents([.height(500)])
            .presentationDragIndicator(.visible)
        }
    }
}

// Day Cell Component
private struct DayCell: View {
    let date: Date
    let isSelected: Bool
    let offset: Int
    let action: (Int) -> Void
    
    // Explicit initializer to handle closure parameter
    init(date: Date, isSelected: Bool, offset: Int, action: @escaping (Int) -> Void) {
        self.date = date
        self.isSelected = isSelected
        self.offset = offset
        self.action = action
    }
    
    private var isToday: Bool {
        Calendar.current.isDateInToday(date)
    }

    var body: some View {
        VStack(spacing: 4) {
            Text(dayName)
                .font(.caption2)
                .fontWeight(.medium)
                .foregroundColor(isSelected ? .white : (isToday ? .pink : .secondary))
            
            Text(dayNumber)
                .font(.callout)
                .fontWeight(.bold)
                .foregroundColor(isSelected ? .white : (isToday ? .pink : .primary))
        }
        .frame(width: 45, height: 60)
        .scaleEffect(isSelected ? 1.1 : 1.0)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(isSelected ? 
                    AnyShapeStyle(
                        LinearGradient(
                            colors: [.pink, .pink.opacity(0.8)],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    ) :
                    (isToday ? 
                        AnyShapeStyle(Color.pink.opacity(0.1)) : 
                        AnyShapeStyle(Color.clear)))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .strokeBorder(isSelected ? Color.clear : (isToday ? Color.pink.opacity(0.3) : Color.gray.opacity(0.2)), 
                            lineWidth: 1)
        )
        .onTapGesture {
            action(offset)
        }
    }
    
    private var dayName: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEE"
        return formatter.string(from: date).lowercased()
    }
    
    private var dayNumber: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "d"
        return formatter.string(from: date)
    }
}

// Enhanced Task Card
private struct TimelineTaskCard: View {
    let task: TodoTask
    let onToggleComplete: () -> Void
    let onToggleSubtask: (UUID) -> Void
    @ObservedObject var viewModel: TimelineViewModel
    @State private var isExpanded = false
    @State private var showingPomodoro = false
    @State private var showingEditSheet = false
    @State private var offset: CGFloat = 0
    @Environment(\.colorScheme) private var colorScheme
    
    private var isCompleted: Bool {
        let startOfDay = viewModel.selectedDate.startOfDay
        if let completion = task.completions[startOfDay] {
            return completion.isCompleted
        }
        return false
    }
    
    private var completionProgress: Double {
        guard !task.subtasks.isEmpty else { return isCompleted ? 1.0 : 0.0 }
        let completion = task.completions[viewModel.selectedDate.startOfDay]
        let completedCount = completion?.completedSubtasks.count ?? 0
        return Double(completedCount) / Double(task.subtasks.count)
    }
    
    private var completedSubtasks: Set<UUID> {
        task.completions[viewModel.selectedDate.startOfDay]?.completedSubtasks ?? []
    }
    
    private var subtaskCountText: String {
        if task.subtasks.isEmpty { return "" }
        let completedCount = completedSubtasks.count
        let totalCount = task.subtasks.count
        return "\(completedCount)/\(totalCount)"
    }
    
    private var currentStreak: Int {
        guard let recurrence = task.recurrence else { return 0 }
        
        // Ottieni la data selezionata
        let selectedDate = viewModel.selectedDate.startOfDay
        
        // Calcola lo streak fino alla data selezionata
        var streak = 0
        var currentDate = selectedDate
        
        // Controlla se la task è completata nella data selezionata
        let isCompletedOnSelectedDate = task.completions[selectedDate]?.isCompleted == true
        
        // Se la task è completata nella data selezionata, inizia il conteggio da 1
        if isCompletedOnSelectedDate {
            streak = 1
            // Vai indietro di un giorno per continuare il conteggio
            currentDate = Calendar.current.date(byAdding: .day, value: -1, to: currentDate)!
        }
        
        // Controlla all'indietro per trovare lo streak
        while true {
            // Verifica se la data corrente è una data in cui la task dovrebbe essere eseguita
            guard recurrence.shouldOccurOn(date: currentDate) else {
                // Se la task non doveva essere eseguita in questa data, passa alla data precedente
                currentDate = Calendar.current.date(byAdding: .day, value: -1, to: currentDate)!
                continue
            }
            
            // Verifica se la task è stata completata in questa data
            if task.completions[currentDate]?.isCompleted == true {
                streak += 1
                currentDate = Calendar.current.date(byAdding: .day, value: -1, to: currentDate)!
            } else {
                // Lo streak è interrotto
                break
            }
        }
        
        return streak
    }
    
    var body: some View {
        ZStack(alignment: .leading) {
            // Action buttons background
            // This is the container that will be visible when swiping
            HStack(spacing: 4) {
                Spacer()
                
                // Edit button
                Button(action: {
                    showingEditSheet = true
                    withAnimation(.spring()) {
                        offset = 0
                    }
                }) {
                    ZStack {
                        RoundedRectangle(cornerRadius: 10)
                            .fill(
                                LinearGradient(
                                    colors: [Color.blue, Color.blue.opacity(0.8)],
                                    startPoint: .top,
                                    endPoint: .bottom
                                )
                            )
                            .frame(width: 60, height: 50)
                            .shadow(color: Color.blue.opacity(0.2), radius: 2, x: 0, y: 1)
                        
                        VStack(spacing: 2) {
                            Image(systemName: "pencil")
                                .font(.system(size: 16, weight: .semibold))
                            Text("edit".localized)
                                .font(.system(.caption2, design: .rounded).bold())
                        }
                        .foregroundColor(.white)
                    }
                }
                
                // Delete button
                Button(action: {
                    withAnimation(.spring()) {
                        TaskManager.shared.removeTask(task)
                        offset = 0
                    }
                }) {
                    ZStack {
                        RoundedRectangle(cornerRadius: 10)
                            .fill(
                                LinearGradient(
                                    colors: [Color.red, Color.red.opacity(0.8)],
                                    startPoint: .top,
                                    endPoint: .bottom
                                )
                            )
                            .frame(width: 60, height: 50)
                            .shadow(color: Color.red.opacity(0.2), radius: 2, x: 0, y: 1)
                        
                        VStack(spacing: 2) {
                            Image(systemName: "trash")
                                .font(.system(size: 16, weight: .semibold))
                            Text("delete".localized)
                                .font(.system(.caption2, design: .rounded).bold())
                        }
                        .foregroundColor(.white)
                    }
                }
            }
            .padding(.trailing, 8)
            .frame(maxWidth: .infinity, minHeight: 60)
            .opacity(offset < -20 ? 1 : 0)
            
            // Card principale
            VStack(alignment: .leading, spacing: 2) {
                // Task header con tutti i contenuti
                HStack(alignment: .center, spacing: 8) {
                    // Barra colorata della categoria
                    Rectangle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    task.category.map { Color(hex: $0.color) } ?? .gray,
                                    task.category.map { Color(hex: $0.color).opacity(0.7) } ?? .gray.opacity(0.7)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(width: 4)
                        .cornerRadius(2)
                        .padding(.vertical, 4)
                    
                    VStack(alignment: .leading, spacing: 2) {
                        HStack(alignment: .center) {
                            Text(task.name)
                                .font(.headline)
                                .foregroundColor(.primary)
                            
                            // Streak indicator migliorato
                            if task.recurrence != nil && currentStreak > 0 {
                                HStack(spacing: 2) {
                                    Image(systemName: "flame.fill")
                                        .foregroundColor(.orange)
                                        .font(.system(size: 12))
                                    Text("\(currentStreak)")
                                        .font(.system(.caption, design: .rounded).bold())
                                        .foregroundColor(.orange)
                                }
                                .padding(.horizontal, 4)
                                .padding(.vertical, 1)
                                .background(
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.orange.opacity(0.15))
                                )
                            }
                            
                            Spacer()
                            
                            // Freccia per espandere se ci sono subtask
                            if !task.subtasks.isEmpty {
                                Image(systemName: "chevron.down")
                                    .font(.system(size: 12))
                                    .foregroundColor(.secondary)
                                    .rotationEffect(.degrees(isExpanded ? 180 : 0))
                                    .animation(.easeInOut(duration: 0.2), value: isExpanded)
                            }
                        }
                        
                        if let description = task.description {
                            Text(description)
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .lineLimit(1)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Spacer()
                    
                    if task.hasDuration && task.duration > 0 {
                        Text(task.duration.formatted())
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    if task.pomodoroSettings != nil {
                        Button(action: { 
                            PomodoroViewModel.shared.setActiveTask(task)
                            showingPomodoro = true
                        }) {
                            ZStack {
                                Circle()
                                    .fill(Color.accentColor.opacity(0.15))
                                    .frame(width: 36, height: 36)
                                    
                                Image(systemName: "timer")
                                    .font(.system(size: 16, weight: .medium))
                                    .foregroundColor(task.category.map { Color(hex: $0.color) } ?? .accentColor)
                            }
                            .overlay(
                                Circle()
                                    .strokeBorder(Color.accentColor.opacity(0.5), lineWidth: 1)
                            )
                            .shadow(color: Color.accentColor.opacity(0.2), radius: 2, x: 0, y: 1)
                        }
                    }
                    
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            onToggleComplete()
                        }
                    }) {
                        ZStack {
                            // Background circle
                            Circle()
                                .stroke(Color.gray.opacity(0.3), lineWidth: 2)
                                .frame(width: 32, height: 32)
                            
                            // Progress circle
                            if !task.subtasks.isEmpty {
                                Circle()
                                    .trim(from: 0, to: completionProgress)
                                    .stroke(Color.pink, lineWidth: 3)
                                    .frame(width: 32, height: 32)
                                    .rotationEffect(.degrees(-90))
                                    .animation(.spring(response: 0.3, dampingFraction: 0.8), value: completionProgress)
                            }
                            
                            // Checkmark
                            Image(systemName: isCompleted ? "checkmark.circle.fill" : "circle")
                                .foregroundColor(isCompleted ? .green : .gray)
                                .font(.title2)
                        }
                    }
                    .buttonStyle(BorderlessButtonStyle())
                    .frame(width: 44, height: 44)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                
                // Subtasks (mostrati solo se espanso)
                if isExpanded && !task.subtasks.isEmpty {
                    VStack(spacing: 8) {
                        ForEach(task.subtasks) { subtask in
                            TimelineSubtaskRow(
                                subtask: subtask,
                                isCompleted: completedSubtasks.contains(subtask.id),
                                onToggle: { onToggleSubtask(subtask.id) }
                            )
                        }
                    }
                    .padding(.vertical, 8)
                }
            }
            .frame(maxWidth: .infinity, minHeight: 60)
            .background(
                RoundedRectangle(cornerRadius: 14)
                    .fill(colorScheme == .dark ? Color(.systemGray6) : .white)
                    .shadow(color: .black.opacity(0.1), radius: 5, x: 0, y: 2)
            )
            .offset(x: offset)
        }
        .contentShape(Rectangle())
        .gesture(
            DragGesture(minimumDistance: 5)
                .onChanged { gesture in
                    // Verifico che lo swipe sia orizzontale (non verticale)
                    if abs(gesture.translation.width) > abs(gesture.translation.height) * 1.5 {
                        withAnimation(.interactiveSpring(response: 0.4, dampingFraction: 0.8)) {
                            // Limito lo swipe verso sinistra a -140, impedisco lo swipe verso destra
                            if gesture.translation.width <= 0 {
                                offset = max(-140, gesture.translation.width)
                            } else if offset < 0 {
                                // Permetto lo swipe verso destra solo per chiudere
                                offset = min(0, offset + gesture.translation.width)
                            }
                        }
                    }
                }
                .onEnded { gesture in
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.75)) {
                        if offset < -40 {
                            // Se lo swipe è stato significativo, apri completamente
                            offset = -140
                        } else {
                            // Altrimenti, chiudi
                            offset = 0
                        }
                    }
                }
        )
        .onTapGesture {
            if offset < 0 {
                withAnimation(.spring()) {
                    offset = 0
                }
            } else if !task.subtasks.isEmpty {
                withAnimation(.easeInOut(duration: 0.2)) {
                    isExpanded.toggle()
                }
            }
        }
        .sheet(isPresented: $showingEditSheet) {
            NavigationStack {
                TaskFormView(initialTask: task)
            }
        }
        .sheet(isPresented: $showingPomodoro) {
            PomodoroView(task: task)
        }
    }
}

// Add Task Button
private struct AddTaskButton: View {
    @Binding var isShowingTaskForm: Bool
    @Environment(\.colorScheme) private var colorScheme
    
    var body: some View {
        Button(action: { isShowingTaskForm = true }) {
            Image(systemName: "plus")
                .font(.system(size: 24, weight: .medium))
                .foregroundColor(.white)
                .frame(width: 56, height: 56)
                .background(
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [Color.pink, Color.pink.opacity(0.8)],
                                    startPoint: .top,
                                    endPoint: .bottom
                                )
                            )
                        Circle()
                            .fill(Color.pink.opacity(0.3))
                            .blur(radius: 8)
                            .scaleEffect(1.2)
                        
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [Color.pink, Color.pink.opacity(0.8)],
                                    startPoint: .top,
                                    endPoint: .bottom
                                )
                            )
                    }
                    .shadow(
                        color: Color.pink.opacity(0.3),
                        radius: 8,
                        x: 0,
                        y: 4
                    )
                )
        }
        .padding(.horizontal, 20)
    }
}

private struct TimelineSubtaskRow: View {
    let subtask: Subtask
    let isCompleted: Bool
    let onToggle: () -> Void
    
    var body: some View {
        HStack {
            Button(action: {
                // Disable implicit animations
                withAnimation(.none) {
                    onToggle()
                }
            }) {
                SubtaskCheckmark(isCompleted: isCompleted)
            }
            .buttonStyle(BorderlessButtonStyle())
            .contentShape(Rectangle())
            .frame(width: 32, height: 32)
            
            Text(subtask.name)
                .font(.subheadline)
                .foregroundColor(isCompleted ? .secondary : .primary)
            
            Spacer()
        }
        .padding(.leading, 16) // Add more padding to move subtasks to the right
    }
}
</file>

<file path="SnapTask/Views/WeekdayPicker.swift/WeekdayPicker.swift">
import SwiftUI

struct WeekdayPicker: View {
    @Binding var selectedDays: Set<Int>
    
    private let weekdays = [
        (1, "Sun"), (2, "Mon"), (3, "Tue"),
        (4, "Wed"), (5, "Thu"), (6, "Fri"), (7, "Sat")
    ]
    
    var body: some View {
        VStack(alignment: .leading) {
            Text("Repeat on")
                .font(.subheadline)
                .foregroundColor(.secondary)
            
            HStack {
                ForEach(weekdays, id: \.0) { day, name in
                    Button(action: {
                        if selectedDays.contains(day) {
                            selectedDays.remove(day)
                        } else {
                            selectedDays.insert(day)
                        }
                    }) {
                        Text(name)
                            .font(.caption)
                            .padding(8)
                            .background(selectedDays.contains(day) ? Color.accentColor : Color.secondary.opacity(0.2))
                            .foregroundColor(selectedDays.contains(day) ? .white : .primary)
                            .clipShape(Circle())
                    }
                }
            }
        }
        .padding(.vertical, 8)
    }
}
</file>

<file path="SnapTask Watch App Watch App/Assets.xcassets/AccentColor.colorset/Contents.json/Contents.json">
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask Watch App Watch App/Assets.xcassets/AppIcon.appiconset/Contents.json/Contents.json">
{
  "images" : [
    {
      "filename" : "AppIcon24x24@2x.png",
      "idiom" : "watch",
      "role" : "notificationCenter",
      "scale" : "2x",
      "size" : "24x24",
      "subtype" : "38mm"
    },
    {
      "filename" : "AppIcon27.5x27.5@2x.png",
      "idiom" : "watch",
      "role" : "notificationCenter",
      "scale" : "2x",
      "size" : "27.5x27.5",
      "subtype" : "42mm"
    },
    {
      "filename" : "AppIcon29x29@2x.png",
      "idiom" : "watch",
      "role" : "companionSettings",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "AppIcon29x29@3x.png",
      "idiom" : "watch",
      "role" : "companionSettings",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "watch",
      "role" : "notificationCenter",
      "scale" : "2x",
      "size" : "33x33",
      "subtype" : "45mm"
    },
    {
      "filename" : "AppIcon40x40@2x.png",
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "40x40",
      "subtype" : "38mm"
    },
    {
      "filename" : "AppIcon44x44@2x.png",
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "44x44",
      "subtype" : "40mm"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "46x46",
      "subtype" : "41mm"
    },
    {
      "filename" : "AppIcon50x50@2x.png",
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "50x50",
      "subtype" : "44mm"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "51x51",
      "subtype" : "45mm"
    },
    {
      "idiom" : "watch",
      "role" : "appLauncher",
      "scale" : "2x",
      "size" : "54x54",
      "subtype" : "49mm"
    },
    {
      "filename" : "AppIcon86x86@2x.png",
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "86x86",
      "subtype" : "38mm"
    },
    {
      "filename" : "AppIcon98x98@2x.png",
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "98x98",
      "subtype" : "42mm"
    },
    {
      "filename" : "AppIcon108x108@2x.png",
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "108x108",
      "subtype" : "44mm"
    },
    {
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "117x117",
      "subtype" : "45mm"
    },
    {
      "idiom" : "watch",
      "role" : "quickLook",
      "scale" : "2x",
      "size" : "129x129",
      "subtype" : "49mm"
    },
    {
      "filename" : "watchicon.png",
      "idiom" : "watch-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask Watch App Watch App/Assets.xcassets/Contents.json/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="SnapTask Watch App Watch App/CloudKitService.swift/CloudKitService.swift">
import Foundation
import CloudKit
import Combine

class CloudKitService: ObservableObject {
    static let shared = CloudKitService()
    
    private let container: CKContainer
    private let privateDatabase: CKDatabase
    private let recordZone: CKRecordZone
    private let zoneID: CKRecordZone.ID
    
    private let taskRecordType = "TodoTask"
    private let deletedTasksKey = "deletedTaskIDs_watch" // Key for tracking deleted tasks on watch
    
    @Published var isSyncing = false
    @Published var lastSyncDate: Date?
    @Published var syncError: Error?
    
    private var subscriptions = Set<AnyCancellable>()
    // private var changedRecordZoneIDs: [CKRecordZone.ID] = [] // Not typically used in basic sync
    
    // Tracking deleted task IDs - Watch specific UserDefaults key
    private var deletedTaskIDs: Set<String> {
        get {
            // Use App Group UserDefaults if data needs to be shared with the main app directly
            // For now, using standard UserDefaults for the watch extension
            if let data = UserDefaults.standard.data(forKey: deletedTasksKey),
               let ids = try? JSONDecoder().decode([String].self, from: data) {
                return Set(ids)
            }
            return Set<String>()
        }
        set {
            if let data = try? JSONEncoder().encode(Array(newValue)) {
                UserDefaults.standard.set(data, forKey: deletedTasksKey)
            }
        }
    }
    
    private init() {
        container = CKContainer(identifier: "iCloud.com.giovanniamadei.SnapTask") 
        privateDatabase = container.privateCloudDatabase
        zoneID = CKRecordZone.ID(zoneName: "SnapTaskZone", ownerName: CKCurrentUserDefaultName)
        recordZone = CKRecordZone(zoneID: zoneID)
        
        checkCloudKitAvailability()
    }
    
    // MARK: - Public Methods
    
    func setup() {
        createCustomZoneIfNeeded()
        subscribeToChanges() // Enable if using push notifications for sync
    }
    
    func syncTasks() {
        isSyncing = true
        // Access TaskManager specific to the Watch App if it's different
        // Assuming TaskManager.shared is appropriate for watch context
        let localTasks = TaskManager.shared.tasks 
        
        fetchAllTasks { [weak self] remoteTasks, error in
            guard let self = self else { return }
            
            if let error = error {
                self.handleSyncError(error)
                return
            }
            self.mergeTasksSafely(localTasks: localTasks, remoteTasks: remoteTasks ?? [])
        }
    }
    
    func saveTask(_ task: TodoTask) {
        let record = taskToRecord(task)
        saveRecord(record) { [weak self] success, error in
            if let error = error {
                print("Watch CKService: Error saving task '\(task.name)': \(error.localizedDescription)")
                self?.handleSyncError(error)
            }
        }
    }
    
    func deleteTask(_ task: TodoTask) {
        let recordID = CKRecord.ID(recordName: task.id.uuidString, zoneID: zoneID)
        print("Watch CKService: Attempting to delete task with ID: \(task.id.uuidString)")
        addToDeletedTasks(taskID: task.id.uuidString)
        
        privateDatabase.delete(withRecordID: recordID) { [weak self] (deletedRecordID, error) in
            if let error = error as? CKError {
                if error.code != .unknownItem {
                    print("Watch CKService: Error deleting task: \(error.localizedDescription)")
                    self?.handleSyncError(error)
                } else {
                    print("Watch CKService: Task already deleted or not found in CloudKit")
                }
            } else if let error = error {
                print("Watch CKService: Error deleting task: \(error.localizedDescription)")
                self?.handleSyncError(error)
            } else {
                print("Watch CKService: Task successfully deleted from CloudKit")
                DispatchQueue.main.async {
                    self?.lastSyncDate = Date()
                }
            }
        }
    }
    
    private func addToDeletedTasks(taskID: String) {
        var ids = deletedTaskIDs
        ids.insert(taskID)
        deletedTaskIDs = ids
    }
    
    private func isTaskDeleted(taskID: String) -> Bool {
        return deletedTaskIDs.contains(taskID)
    }
        
    private func checkCloudKitAvailability() {
        container.accountStatus { [weak self] (status, error) in
            DispatchQueue.main.async {
                guard let self = self else { return }
                switch status {
                case .available:
                    print("Watch CKService: iCloud Account Available. Setting up zone.")
                    self.setup()
                case .noAccount:
                    print("Watch CKService: No iCloud account found.")
                    self.syncError = NSError(domain: "CloudKit", code: 1, userInfo: [NSLocalizedDescriptionKey: "No iCloud account found."])
                case .restricted:
                    print("Watch CKService: iCloud access restricted.")
                    self.syncError = NSError(domain: "CloudKit", code: 2, userInfo: [NSLocalizedDescriptionKey: "iCloud access restricted."])
                case .couldNotDetermine:
                    let errDesc = error?.localizedDescription ?? "Could not determine iCloud account status."
                    print("Watch CKService: Could not determine iCloud status. Error: \(errDesc)")
                    self.syncError = error ?? NSError(domain: "CloudKit", code: 3, userInfo: [NSLocalizedDescriptionKey: errDesc])
                @unknown default:
                    print("Watch CKService: Unknown iCloud account status.")
                    self.syncError = NSError(domain: "CloudKit", code: 4, userInfo: [NSLocalizedDescriptionKey: "Unknown iCloud status."])
                }
            }
        }
    }
    
    private func createCustomZoneIfNeeded() {
        privateDatabase.fetch(withRecordZoneID: zoneID) { [weak self] (zone, error) in
            guard let self = self else { return }
            if let error = error as? CKError, error.code == .zoneNotFound {
                print("Watch CKService: Zone 'SnapTaskZone' not found. Attempting to create.")
                self.createCustomZone()
            } else if let error = error {
                print("Watch CKService: Error fetching zone: \(error.localizedDescription)")
                self.handleSyncError(error)
            } else {
                print("Watch CKService: Zone 'SnapTaskZone' already exists.")
            }
        }
    }
    
    private func createCustomZone() {
        print("Watch CKService: Executing createCustomZone() for 'SnapTaskZone'.")
        privateDatabase.save(recordZone) { [weak self] (zone, error) in
            guard let self = self else { return }
            if let error = error {
                print("Watch CKService: Error creating zone: \(error.localizedDescription)")
                self.handleSyncError(error)
            } else {
                print("Watch CKService: Zone 'SnapTaskZone' created successfully.")
                self.syncError = nil
                self.syncTasks() // Sync after zone creation
            }
        }
    }
    
    private func subscribeToChanges() {
        let subscription = CKRecordZoneSubscription(zoneID: zoneID)
        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true // For silent background updates
        subscription.notificationInfo = notificationInfo
        
        privateDatabase.save(subscription) { (savedSubscription, error) in
            if let error = error {
                print("Watch CKService: Error saving subscription: \(error.localizedDescription)")
                // self.handleSyncError(error) // Decide if this is a critical sync error
            } else {
                print("Watch CKService: Successfully subscribed to zone changes.")
            }
        }
    }
    
    private func fetchAllTasks(completion: @escaping ([TodoTask]?, Error?) -> Void) {
        let predicate = NSPredicate(value: true)
        let query = CKQuery(recordType: taskRecordType, predicate: predicate)
        print("Watch CKService: Fetching all tasks from CloudKit")
        
        privateDatabase.perform(query, inZoneWith: zoneID) { [weak self] (records, error) in
            guard let self = self else { 
                completion(nil, NSError(domain: "CloudKitService.Watch", code: -1, userInfo: [NSLocalizedDescriptionKey: "Self is nil in fetchAllTasks"]))
                return
            }
            if let error = error {
                print("Watch CKService: Error fetching tasks: \(error.localizedDescription)")
                completion(nil, error)
                return
            }
            guard let records = records else {
                print("Watch CKService: No records found")
                completion([], nil)
                return
            }
            print("Watch CKService: Found \(records.count) records in CloudKit")
            let tasks = records.compactMap { record -> TodoTask? in
                if self.isTaskDeleted(taskID: record.recordID.recordName) {
                    print("Watch CKService: Skipping deleted task with ID: \(record.recordID.recordName)")
                    return nil
                }
                return self.recordToTask(record)
            }
            completion(tasks, nil)
        }
    }
    
    private func saveRecord(_ record: CKRecord, completion: @escaping (Bool, Error?) -> Void) {
        let modifyOperation = CKModifyRecordsOperation(recordsToSave: [record], recordIDsToDelete: nil)
        modifyOperation.savePolicy = .changedKeys
        modifyOperation.modifyRecordsCompletionBlock = { savedRecords, deletedRecordIDs, error in
            if let error = error {
                print("Watch CKService: Error saving record: \(error.localizedDescription)")
                completion(false, error)
                return
            }
            print("Watch CKService: Record saved successfully. Count: \(savedRecords?.count ?? 0)")
            completion(true, nil)
        }
        privateDatabase.add(modifyOperation)
    }
    
    private func mergeTasksSafely(localTasks: [TodoTask], remoteTasks: [TodoTask]) {
        print("Watch CKService: mergeTasksSafely - Local: \(localTasks.count), Remote: \(remoteTasks.count)")
        let localDeviceDeletedIDs = self.deletedTaskIDs
        var finalLocalState = [UUID: TodoTask]()
        var recordsToSaveToCloudKit = [CKRecord]()
        var recordIDsToDeleteFromCloudKit = Set<CKRecord.ID>()

        localDeviceDeletedIDs.forEach {
            recordIDsToDeleteFromCloudKit.insert(CKRecord.ID(recordName: $0, zoneID: self.zoneID))
        }

        let localTasksMap = Dictionary(localTasks.map { ($0.id, $0) }, uniquingKeysWith: { (first, _) in first })
        let remoteTasksMap = Dictionary(remoteTasks.map { ($0.id, $0) }, uniquingKeysWith: { (first, _) in first })
        let allConsideredIDs = Set(localTasksMap.keys).union(remoteTasksMap.keys)

        for taskID in allConsideredIDs {
            let idString = taskID.uuidString
            let localTask = localTasksMap[taskID]
            let remoteTask = remoteTasksMap[taskID]

            if localDeviceDeletedIDs.contains(idString) {
                print("Watch CKService: Merge - Task \(idString) in local deleted list. Ensuring server delete.")
                continue
            }

            if let lt = localTask, let rt = remoteTask {
                if lt.lastModifiedDate >= rt.lastModifiedDate {
                    finalLocalState[taskID] = lt
                    if lt.lastModifiedDate > rt.lastModifiedDate {
                        print("Watch CKService: Merge - Local task '\(lt.name)' is more recently modified. Scheduling for server update.")
                        recordsToSaveToCloudKit.append(self.taskToRecord(lt))
                    } else {
                        print("Watch CKService: Merge - Local task '\(lt.name)' and remote task have same modification date.")
                    }
                } else {
                    finalLocalState[taskID] = rt
                    print("Watch CKService: Merge - Remote task '\(rt.name)' is more recently modified. Updating local state.")
                }
            } else if let lt = localTask {
                finalLocalState[taskID] = lt
                print("Watch CKService: Merge - Task '\(lt.name)' local-only. Scheduling for upload.")
                recordsToSaveToCloudKit.append(self.taskToRecord(lt))
            } else if let rt = remoteTask {
                finalLocalState[taskID] = rt
                print("Watch CKService: Merge - Remote task '\(rt.name)' new. Adding locally.")
            }
        }

        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            let tasksForManager = Array(finalLocalState.values)
            print("Watch CKService: Merge - Updating TaskManager with \(tasksForManager.count) tasks.")
            TaskManager.shared.updateAllTasks(tasksForManager) // Assumes TaskManager.shared is correct for Watch

            let finalRecordIDsToDelete = Array(recordIDsToDeleteFromCloudKit)
            if !recordsToSaveToCloudKit.isEmpty || !finalRecordIDsToDelete.isEmpty {
                print("Watch CKService: Merge - CloudKit: Save \(recordsToSaveToCloudKit.count), Delete \(finalRecordIDsToDelete.count)")
                let modifyOp = CKModifyRecordsOperation(recordsToSave: recordsToSaveToCloudKit, recordIDsToDelete: finalRecordIDsToDelete)
                modifyOp.savePolicy = .changedKeys
                modifyOp.modifyRecordsCompletionBlock = { savedRecords, deletedRecordIDs, error in
                    DispatchQueue.main.async {
                        if let error = error {
                            print("Watch CKService: Merge - CKModifyRecordsOp error: \(error.localizedDescription)")
                            self.handleSyncError(error)
                        } else {
                            print("Watch CKService: Merge - CKModifyRecordsOp success. Saved: \(savedRecords?.count ?? 0), Deleted: \(deletedRecordIDs?.count ?? 0).")
                            self.syncError = nil
                        }
                        self.isSyncing = false
                        self.lastSyncDate = Date()
                    }
                }
                self.privateDatabase.add(modifyOp)
            } else {
                print("Watch CKService: Merge - No CloudKit operations needed.")
                self.isSyncing = false
                self.lastSyncDate = Date()
                self.syncError = nil
            }
        }
    }
    
    private func taskToRecord(_ task: TodoTask) -> CKRecord {
        let recordID = CKRecord.ID(recordName: task.id.uuidString, zoneID: zoneID)
        let record = CKRecord(recordType: taskRecordType, recordID: recordID)
        // Basic properties
        record["name"] = task.name as CKRecordValue
        record["appCreationDate"] = task.creationDate as NSDate
        record["lastModifiedDate"] = task.lastModifiedDate as NSDate
        record["startTime"] = task.startTime as NSDate
        record["duration"] = task.duration as CKRecordValue
        record["hasDuration"] = task.hasDuration as CKRecordValue
        record["icon"] = task.icon as CKRecordValue
        record["priority"] = task.priority.rawValue as CKRecordValue
        if let description = task.description, !description.isEmpty {
            record["description"] = description as CKRecordValue
        } else {
            record["description"] = nil
        }
        // Complex properties as NSData
        do {
            if let category = task.category { record["category"] = try JSONEncoder().encode(category) as NSData }
            if let recurrence = task.recurrence { record["recurrence"] = try JSONEncoder().encode(recurrence) as NSData }
            if let pomodoroSettings = task.pomodoroSettings { record["pomodoroSettings"] = try JSONEncoder().encode(pomodoroSettings) as NSData }
            if !task.subtasks.isEmpty { record["subtasks"] = try JSONEncoder().encode(task.subtasks) as NSData }
            if !task.completions.isEmpty { record["completions"] = try JSONEncoder().encode(task.completions) as NSData }
            if !task.completionDates.isEmpty { record["completionDates"] = try JSONEncoder().encode(task.completionDates) as NSData }
        } catch {
            print("Watch CKService: Error encoding task data for '\(task.name)': \(error.localizedDescription)")
        }
        return record
    }
    
    private func recordToTask(_ record: CKRecord) -> TodoTask? {
        print("Watch CKService: recordToTask - Processing record ID: \(record.recordID.recordName)")
        do {
            guard let name = record["name"] as? String else { return nil }
            let modelCreationDate = record["appCreationDate"] as? Date ?? record.creationDate ?? Date()
            let lastModifiedDate = record["lastModifiedDate"] as? Date ?? record.modificationDate ?? modelCreationDate
            let startTime = record["startTime"] as? Date ?? modelCreationDate
            let duration = record["duration"] as? TimeInterval ?? 0.0
            let hasDuration = record["hasDuration"] as? Bool ?? false
            let icon = record["icon"] as? String ?? "circle.fill"
            let description = record["description"] as? String
            var priority: Priority = .medium
            if let priorityRaw = record["priority"] as? String { priority = Priority(rawValue: priorityRaw) ?? .medium }
            // Simplified complex property decoding, add individual catch blocks if needed for fine-grained error handling
            let category = (record["category"] as? Data).flatMap { try? JSONDecoder().decode(Category.self, from: $0) }
            let recurrence = (record["recurrence"] as? Data).flatMap { try? JSONDecoder().decode(Recurrence.self, from: $0) }
            let pomodoroSettings = (record["pomodoroSettings"] as? Data).flatMap { try? JSONDecoder().decode(PomodoroSettings.self, from: $0) }
            let subtasks = (record["subtasks"] as? Data).flatMap { try? JSONDecoder().decode([Subtask].self, from: $0) } ?? []
            let completions = (record["completions"] as? Data).flatMap { try? JSONDecoder().decode([Date: TaskCompletion].self, from: $0) } ?? [:]
            let completionDates = (record["completionDates"] as? Data).flatMap { try? JSONDecoder().decode([Date].self, from: $0) } ?? []
            let uuid = UUID(uuidString: record.recordID.recordName) ?? UUID()
            
            var task = TodoTask(id: uuid, name: name, description: description, startTime: startTime, duration: duration, hasDuration: hasDuration, category: category, priority: priority, icon: icon, recurrence: recurrence, pomodoroSettings: pomodoroSettings, subtasks: subtasks)
            task.completions = completions
            task.completionDates = completionDates
            task.creationDate = modelCreationDate
            task.lastModifiedDate = lastModifiedDate
            return task
        } catch {
            print("Watch CKService: recordToTask - Error processing record ID \(record.recordID.recordName): \(error.localizedDescription)")
            return nil
        }
    }
    
    private func handleSyncError(_ error: Error) {
        DispatchQueue.main.async { [weak self] in
            print("Watch CKService: Sync Error - \(error.localizedDescription)")
            self?.syncError = error
            self?.isSyncing = false
        }
    }
}

// Ensure TaskManager, TodoTask, Category, Priority, etc. are available to the Watch target
// And that their definitions are consistent with the iOS app target.

// If .tasksDidUpdate notification is used, ensure it's defined and posted correctly in watch context.
// extension Notification.Name {
//    static let tasksDidUpdate = Notification.Name("tasksDidUpdate_watch")
// }
</file>

<file path="SnapTask Watch App Watch App/ContentView.swift/ContentView.swift">
import SwiftUI

struct ContentView: View {
    @StateObject private var taskManager = TaskManager.shared
    @State private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            TimelineWatchView()
                .tag(0)
            
            PomodoroListView()
                .tag(1)
                
            WatchStatisticsView()
                .tag(2)
                
            SettingsWatchView()
                .tag(3)
        }
        .tabViewStyle(PageTabViewStyle())
        .navigationTitle(tabTitle)
    }
    
    private var tabTitle: String {
        switch selectedTab {
        case 0:
            return ""
        case 1:
            return "Pomodoro"
        case 2:
            return "Statistics"
        case 3:
            return "Settings"
        default:
            return ""
        }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
</file>

<file path="SnapTask Watch App Watch App/Info.plist/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>$(DEVELOPMENT_LANGUAGE)</string>
    <key>CFBundleDisplayName</key>
    <string>SnapTask</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>WKWatchKitApp</key>
    <true/>
</dict>
</plist>
</file>

<file path="SnapTask Watch App Watch App/Models/Category.swift/Category.swift">
import Foundation

struct Category: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var color: String
}
</file>

<file path="SnapTask Watch App Watch App/Models/PomodoroSettings.swift/PomodoroSettings.swift">
import Foundation

struct PomodoroSettings: Codable, Equatable {
    var workDuration: Double
    var breakDuration: Double
    var longBreakDuration: Double
    var sessionsUntilLongBreak: Int
    
    static let defaultSettings = PomodoroSettings(
        workDuration: 25 * 60,    // 25 minutes in seconds
        breakDuration: 5 * 60,    // 5 minutes
        longBreakDuration: 15 * 60, // 15 minutes
        sessionsUntilLongBreak: 4
    )
    
    // Computed properties for session management
    var sessionDuration: Double {
        workDuration
    }
    
    var sessions: Int {
        sessionsUntilLongBreak
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/Priority.swift/Priority.swift">
import Foundation

enum Priority: String, CaseIterable, Codable {
    case low
    case medium
    case high
    
    var icon: String {
        switch self {
        case .low: return "arrow.down"
        case .medium: return "minus"
        case .high: return "arrow.up"
        }
    }
    
    var color: String {
        switch self {
        case .low: return "#00FF00"
        case .medium: return "#FFA500"
        case .high: return "#FF0000"
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/Quote.swift/Quote.swift">
import Foundation

struct Quote: Identifiable, Codable, Equatable {
    let id: UUID
    var text: String
    var author: String
    var lastUpdated: Date
    
    init(id: UUID = UUID(), text: String, author: String, lastUpdated: Date = Date()) {
        self.id = id
        self.text = text
        self.author = author
        self.lastUpdated = lastUpdated
    }
    
    static let placeholder = Quote(
        text: "The journey of a thousand miles begins with a single step.",
        author: "Lao Tzu"
    )
}
</file>

<file path="SnapTask Watch App Watch App/Models/Recurrence.swift/Recurrence.swift">
import Foundation

struct Recurrence: Codable, Equatable {
    enum RecurrenceType: Codable, Equatable {
        case daily
        case weekly(days: Set<Int>)
        case monthly(days: Set<Int>)
    }
    
    private enum CodingKeys: String, CodingKey {
        case type, endDate, trackInStatistics, startDate
    }
    
    let type: RecurrenceType
    let startDate: Date
    let endDate: Date?
    let trackInStatistics: Bool
    
    init(type: RecurrenceType, startDate: Date, endDate: Date?, trackInStatistics: Bool = true) {
        self.type = type
        self.startDate = startDate
        self.endDate = endDate
        self.trackInStatistics = trackInStatistics
    }
    
    // Custom decoder to handle missing trackInStatistics in older data
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        type = try container.decode(RecurrenceType.self, forKey: .type)
        startDate = try container.decode(Date.self, forKey: .startDate)
        endDate = try container.decodeIfPresent(Date.self, forKey: .endDate)
        
        // Default to true if property doesn't exist in saved data
        trackInStatistics = try container.decodeIfPresent(Bool.self, forKey: .trackInStatistics) ?? true
    }
}

extension Recurrence {
    func shouldOccurOn(date: Date) -> Bool {
        let calendar = Calendar.current
        
        switch self.type {
        case .daily:
            return true
            
        case .weekly(let days):
            // Ottieni il giorno della settimana (1-7, dove 1 è Domenica)
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
            
        case .monthly(let days):
            // Ottieni il giorno del mese (1-31)
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/RecurrenceExtension.swift/RecurrenceExtension.swift">
import Foundation

extension Recurrence {
    func isActiveOn(date: Date) -> Bool {
        // Primero verificamos si la fecha está dentro del rango de la recurrencia
        if let endDate = self.endDate {
            if date > endDate {
                return false
            }
        }
        
        let calendar = Calendar.current
        
        // Verificamos si la fecha es posterior a la fecha de inicio
        if date < calendar.startOfDay(for: self.startDate) {
            return false
        }
        
        switch self.type {
        case .daily:
            return true
            
        case .weekly(let days):
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
            
        case .monthly(let days):
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/Subtask.swift/Subtask.swift">
import Foundation

struct Subtask: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var isCompleted: Bool
    
    init(id: UUID = UUID(), name: String, isCompleted: Bool = false) {
        self.id = id
        self.name = name
        self.isCompleted = isCompleted
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/TaskCompletion.swift/TaskCompletion.swift">
import Foundation

struct TaskCompletion: Codable, Equatable {
    var isCompleted: Bool
    var completedSubtasks: Set<UUID>
    
    init(isCompleted: Bool = false, completedSubtasks: Set<UUID> = []) {
        self.isCompleted = isCompleted
        self.completedSubtasks = completedSubtasks
    }
}
</file>

<file path="SnapTask Watch App Watch App/Models/TaskManager.swift/TaskManager.swift">
import Foundation
import Combine
import CloudKit

class TaskManager: ObservableObject {
    static let shared = TaskManager()
    
    @Published var tasks: [TodoTask] = []
    private let tasksKey = "savedTasks"
    
    init() {
        loadTasks()
    }
    
    func addTask(_ task: TodoTask) {
        print("Adding task: \(task.name)")
        print("Has recurrence: \(task.recurrence != nil)")
        tasks.append(task)
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con CloudKit
        CloudKitService.shared.saveTask(task)
        
        // Sincronizza con iOS
        synchronizeWithWatch()
    }
    
    func updateTask(_ updatedTask: TodoTask) {
        if let index = tasks.firstIndex(where: { $0.id == updatedTask.id }) {
            // Preserva i dati di completamento esistenti
            let existingCompletions = tasks[index].completions
            var task = updatedTask
            task.completions = existingCompletions
            tasks[index] = task
            
            saveTasks()
            notifyTasksUpdated()
            
            // Sincronizza con CloudKit
            CloudKitService.shared.saveTask(task)
            
            // Sincronizza con iOS
            synchronizeWithWatch()
        }
    }
    
    func updateAllTasks(_ newTasks: [TodoTask]) {
        // Preserve completion data for tasks that already exist
        var updatedTasks: [TodoTask] = []
        
        for newTask in newTasks {
            if let existingIndex = tasks.firstIndex(where: { $0.id == newTask.id }) {
                // Preserve completion data
                var taskWithCompletions = newTask
                taskWithCompletions.completions = tasks[existingIndex].completions
                updatedTasks.append(taskWithCompletions)
            } else {
                // New task, add as is
                updatedTasks.append(newTask)
            }
        }
        
        tasks = updatedTasks
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
    }
    
    func removeTask(_ task: TodoTask) {
        tasks.removeAll { $0.id == task.id }
        saveTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con iOS
        synchronizeWithWatch()
    }
    
    func toggleTaskCompletion(_ taskId: UUID, on date: Date = Date()) {
        if let index = tasks.firstIndex(where: { $0.id == taskId }) {
            var task = tasks[index]
            let startOfDay = date.startOfDay
            
            // Aggiorna il completion status
            if let completion = task.completions[startOfDay] {
                task.completions[startOfDay] = TaskCompletion(
                    isCompleted: !completion.isCompleted,
                    completedSubtasks: completion.completedSubtasks
                )
            } else {
                task.completions[startOfDay] = TaskCompletion(
                    isCompleted: true,
                    completedSubtasks: []
                )
            }
            
            // Aggiorna completionDates
            if task.completions[startOfDay]?.isCompleted == true {
                if !task.completionDates.contains(startOfDay) {
                    task.completionDates.append(startOfDay)
                }
            } else {
                task.completionDates.removeAll { $0 == startOfDay }
            }
            
            tasks[index] = task
            
            // Forza l'aggiornamento
            DispatchQueue.main.async { [weak self] in
                self?.saveTasks()
                self?.notifyTasksUpdated()
                self?.objectWillChange.send()
                
                // Sincronizza con CloudKit
                CloudKitService.shared.saveTask(task)
                
                // Sincronizza con iOS
                self?.synchronizeWithWatch()
            }
        }
    }
    
    func toggleSubtask(taskId: UUID, subtaskId: UUID, on date: Date = Date()) {
        guard let taskIndex = tasks.firstIndex(where: { $0.id == taskId }) else { return }
        
        var task = tasks[taskIndex]
        let startOfDay = date.startOfDay
        
        var completion = task.completions[startOfDay] ?? TaskCompletion(isCompleted: false, completedSubtasks: [])
        
        if completion.completedSubtasks.contains(subtaskId) {
            completion.completedSubtasks.remove(subtaskId)
        } else {
            completion.completedSubtasks.insert(subtaskId)
        }
        
        task.completions[startOfDay] = completion
        tasks[taskIndex] = task
        
        // Ensure UI updates happen on the main thread
        DispatchQueue.main.async { [weak self] in
            self?.saveTasks()
            self?.notifyTasksUpdated()
            self?.objectWillChange.send()
            
            // Sincronizza con CloudKit
            CloudKitService.shared.saveTask(task)
            
            // Sincronizza con iOS
            self?.synchronizeWithWatch()
        }
    }
    
    func saveTasks() {
        do {
            let data = try JSONEncoder().encode(tasks)
            UserDefaults.standard.set(data, forKey: tasksKey)
        } catch {
            print("Error saving tasks: \(error)")
        }
    }
    
    private func loadTasks() {
        if let data = UserDefaults.standard.data(forKey: tasksKey) {
            do {
                tasks = try JSONDecoder().decode([TodoTask].self, from: data)
            } catch {
                print("Error loading tasks: \(error)")
                tasks = []
            }
        }
    }
    
    func notifyTasksUpdated() {
        NotificationCenter.default.post(name: .tasksDidUpdate, object: nil)
    }
    
    // For debugging purposes only
    func resetUserDefaults() {
        UserDefaults.standard.removeObject(forKey: tasksKey)
        loadTasks()
        notifyTasksUpdated()
        objectWillChange.send()
        
        // Sincronizza con iOS
        synchronizeWithWatch()
    }
    
    // Method to send task updates to the iOS app
    func synchronizeWithWatch() {
        WatchConnectivityManager.shared.sendTasksToiOS(tasks: self.tasks)
    }
    
    func isSubtaskCompleted(taskId: UUID, subtaskId: UUID, on date: Date = Date()) -> Bool {
        guard let task = tasks.first(where: { $0.id == taskId }) else { return false }
        let startOfDay = date.startOfDay
        
        if let completion = task.completions[startOfDay] {
            return completion.completedSubtasks.contains(subtaskId)
        }
        return false
    }
}

extension Notification.Name {
    static let tasksDidUpdate = Notification.Name("tasksDidUpdate")
}
</file>

<file path="SnapTask Watch App Watch App/Models/TaskManagerExtension.swift/TaskManagerExtension.swift">
import Foundation

// Questo file può essere usato per altre estensioni future
// Il metodo updateAllTasks è stato spostato nel file TaskManager.swift principale
</file>

<file path="SnapTask Watch App Watch App/Models/TodoTask.swift/TodoTask.swift">
import Foundation
import Combine

struct TodoTask: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var description: String?
    var startTime: Date
    var duration: TimeInterval
    var hasDuration: Bool
    var category: Category?
    var priority: Priority
    var icon: String
    var recurrence: Recurrence?
    var pomodoroSettings: PomodoroSettings?
    var completions: [Date: TaskCompletion] = [:]
    var subtasks: [Subtask] = []
    var completionDates: [Date] = []
    var creationDate: Date = Date()
    var lastModifiedDate: Date = Date()
    
    init(
        id: UUID = UUID(),
        name: String,
        description: String? = nil,
        startTime: Date,
        duration: TimeInterval = 0,
        hasDuration: Bool = false,
        category: Category? = nil,
        priority: Priority = .medium,
        icon: String = "circle",
        recurrence: Recurrence? = nil,
        pomodoroSettings: PomodoroSettings? = nil,
        subtasks: [Subtask] = []
    ) {
        self.id = id
        self.name = name
        self.description = description
        self.startTime = startTime
        self.duration = duration
        self.hasDuration = hasDuration
        self.category = category
        self.priority = priority
        self.icon = icon
        self.recurrence = recurrence
        self.pomodoroSettings = pomodoroSettings
        self.subtasks = subtasks
    }
    
    var completionProgress: Double {
        guard !subtasks.isEmpty else { 
            if let completion = completions[Date().startOfDay] {
                return completion.isCompleted ? 1.0 : 0.0
            }
            return 0.0
        }
        return Double(subtasks.filter(\.isCompleted).count) / Double(subtasks.count)
    }
    
    func streakForDate(_ date: Date) -> Int {
        guard let recurrence = recurrence else { return 0 }
        
        let calendar = Calendar.current
        var currentDate = date.startOfDay
        var streak = 0
        
        if currentDate > Date().startOfDay {
            return 0
        }
        
        while true {
            if currentDate < calendar.startOfDay(for: startTime) {
                break
            }
            
            if let endDate = recurrence.endDate, currentDate > endDate {
                break
            }
            
            let shouldCheck = shouldCheckDate(currentDate, recurrence: recurrence)
            
            if shouldCheck {
                if let completion = completions[currentDate], completion.isCompleted {
                    streak += 1
                } else {
                    break
                }
            }
            
            guard let newDate = calendar.date(byAdding: .day, value: -1, to: currentDate) else { break }
            currentDate = newDate
        }
        
        return streak
    }
    
    private func shouldCheckDate(_ date: Date, recurrence: Recurrence) -> Bool {
        let calendar = Calendar.current
        
        switch recurrence.type {
        case .daily:
            return true
        case .weekly(let days):
            let weekday = calendar.component(.weekday, from: date)
            return days.contains(weekday)
        case .monthly(let days):
            let day = calendar.component(.day, from: date)
            return days.contains(day)
        }
    }
    
    var currentStreak: Int {
        streakForDate(Date())
    }
    
    static func == (lhs: TodoTask, rhs: TodoTask) -> Bool {
        lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.description == rhs.description &&
        lhs.startTime == rhs.startTime &&
        lhs.duration == rhs.duration &&
        lhs.hasDuration == rhs.hasDuration &&
        lhs.category == rhs.category &&
        lhs.priority == rhs.priority &&
        lhs.icon == rhs.icon &&
        lhs.recurrence == rhs.recurrence &&
        lhs.pomodoroSettings == rhs.pomodoroSettings &&
        lhs.completions == rhs.completions &&
        lhs.subtasks == rhs.subtasks &&
        lhs.completionDates == rhs.completionDates
    }
}
</file>

<file path="SnapTask Watch App Watch App/QuoteManager.swift/QuoteManager.swift">
import Foundation
import SwiftUI
import Combine

class QuoteManager: ObservableObject {
    static let shared = QuoteManager()
    
    @Published private(set) var currentQuote: Quote
    @Published private(set) var isLoading = false
    private let service = QuoteService.shared
    
    private let lastUpdateDateKey = "lastQuoteUpdateDate"
    private let currentQuoteKey = "currentQuote"
    
    // Collection of fallback motivational quotes
    private let fallbackQuotes: [Quote] = [
        Quote(text: "The only way to do great work is to love what you do.", author: "Steve Jobs"),
        Quote(text: "Success is not final, failure is not fatal: It is the courage to continue that counts.", author: "Winston Churchill"),
        Quote(text: "Believe you can and you're halfway there.", author: "Theodore Roosevelt"),
        Quote(text: "Your time is limited, don't waste it living someone else's life.", author: "Steve Jobs"),
        Quote(text: "The future belongs to those who believe in the beauty of their dreams.", author: "Eleanor Roosevelt"),
        Quote(text: "It does not matter how slowly you go as long as you do not stop.", author: "Confucius"),
        Quote(text: "Don't watch the clock; do what it does. Keep going.", author: "Sam Levenson"),
        Quote(text: "The only limit to our realization of tomorrow is our doubts of today.", author: "Franklin D. Roosevelt"),
        Quote(text: "The way to get started is to quit talking and begin doing.", author: "Walt Disney"),
        Quote(text: "If you're going through hell, keep going.", author: "Winston Churchill")
    ]
    
    private var cancellables = Set<AnyCancellable>()
    
    init() {
        // Initialize with placeholder first
        self.currentQuote = Quote.placeholder
        
        // Then try to load saved quote
        if let savedQuote = loadSavedQuote() {
            self.currentQuote = savedQuote
        }
        
        // Check if we need to update the quote
        Task {
            await checkAndUpdateQuote()
        }
        
        // Set up a timer to refresh the quote daily
        Timer.publish(every: 86400, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                Task { [weak self] in
                    await self?.checkAndUpdateQuote()
                }
            }
            .store(in: &cancellables)
    }
    
    @MainActor
    func checkAndUpdateQuote() async {
        // Only update if we haven't updated today
        guard shouldUpdateQuote() else { return }
        
        isLoading = true
        defer { isLoading = false }
        
        do {
            let quote = try await service.fetchDailyQuote()
            currentQuote = quote
            saveCurrentQuote()
            updateLastUpdateDate()
        } catch {
            print("Error fetching quote: \(error)")
            // If there's an error, use a random fallback quote
            currentQuote = fallbackQuotes.randomElement() ?? Quote.placeholder
            saveCurrentQuote()
            updateLastUpdateDate()
        }
    }
    
    private func shouldUpdateQuote() -> Bool {
        guard let lastUpdate = UserDefaults.standard.object(forKey: lastUpdateDateKey) as? Date else {
            return true
        }
        return !Calendar.current.isDate(lastUpdate, inSameDayAs: Date())
    }
    
    private func updateLastUpdateDate() {
        UserDefaults.standard.set(Date(), forKey: lastUpdateDateKey)
    }
    
    private func saveCurrentQuote() {
        if let encoded = try? JSONEncoder().encode(currentQuote) {
            UserDefaults.standard.set(encoded, forKey: currentQuoteKey)
        }
    }
    
    private func loadSavedQuote() -> Quote? {
        guard let data = UserDefaults.standard.data(forKey: currentQuoteKey),
              let quote = try? JSONDecoder().decode(Quote.self, from: data) else {
            return nil
        }
        return quote
    }
    
    func refreshQuote() {
        Task {
            await checkAndUpdateQuote()
        }
    }
    
    @MainActor
    func forceUpdateQuote() async {
        // Notifichiamo che stiamo caricando
        isLoading = true
        
        do {
            // Tentiamo di ottenere una nuova citazione dall'API
            let quote = try await service.fetchDailyQuote()
            currentQuote = quote
            saveCurrentQuote()
            updateLastUpdateDate()
        } catch {
            print("Error fetching quote: \(error)")
            // Se c'è un errore, utilizziamo una citazione casuale dalla lista
            let randomQuote = fallbackQuotes.randomElement() ?? fallbackQuotes[0]
            // Assicuriamoci che non sia uguale a quella attuale se possibile
            if fallbackQuotes.count > 1 && randomQuote.text == currentQuote.text {
                let filteredQuotes = fallbackQuotes.filter { $0.text != currentQuote.text }
                currentQuote = filteredQuotes.randomElement() ?? randomQuote
            } else {
                currentQuote = randomQuote
            }
            saveCurrentQuote()
            updateLastUpdateDate()
        }
        
        // Completato il caricamento
        isLoading = false
    }
}
</file>

<file path="SnapTask Watch App Watch App/SnapTask Watch App Watch App.entitlements/SnapTask Watch App Watch App.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>aps-environment</key>
	<string>development</string>
	<key>com.apple.developer.icloud-container-identifiers</key>
	<array>
		<string>iCloud.com.giovanniamadei.SnapTask</string>
	</array>
	<key>com.apple.developer.icloud-services</key>
	<array>
		<string>CloudKit</string>
	</array>
</dict>
</plist>
</file>

<file path="SnapTask Watch App Watch App/SnapTaskWatchApp.swift/SnapTaskWatchApp.swift">
//
//  SnapTask_Watch_AppApp.swift
//  SnapTask Watch App Watch App
//
//  Created by Giovanni Amadei on 14/05/25.
//

import SwiftUI
import CloudKit

@main
struct SnapTaskWatchApp: App {
    @StateObject private var taskManager = TaskManager.shared
    @StateObject private var quoteManager = QuoteManager.shared
    @StateObject private var connectivityManager = WatchConnectivityManager.shared
    @StateObject private var cloudKitService = CloudKitService.shared
    
    var body: some Scene {
        WindowGroup {
            NavigationView {
                ContentView()
            }
            .onAppear {
                Task {
                    await quoteManager.checkAndUpdateQuote()
                }
                
                // Prima sincronizzazione con CloudKit
                cloudKitService.syncTasks()
                
                // Richiesta delle attività da iOS come fallback
                connectivityManager.requestTasksFromiOS()
            }
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/ViewModels/SettingsViewModel.swift/SettingsViewModel.swift">
import Foundation
import SwiftUI

class SettingsViewModel: ObservableObject {
    @Published var categories: [Category] = []
    @Published var priorities: [Priority] = []
    @Published var pomodoroSettings = PomodoroSettings(
        workDuration: 25.0 * 60.0,
        breakDuration: 5.0 * 60.0,
        longBreakDuration: 15.0 * 60.0,
        sessionsUntilLongBreak: 4
    )
    
    private let taskManager = TaskManager.shared
    private let categoriesKey = "savedCategories"
    
    init() {
        loadCategories()
        loadPriorities()
        loadPomodoroSettings()
        
        // Add default categories if none exist
        if categories.isEmpty {
            addDefaultCategories()
        }
    }
    
    func loadCategories() {
        var shouldAddDefaults = true
        
        if let data = UserDefaults.standard.data(forKey: categoriesKey) {
            do {
                categories = try JSONDecoder().decode([Category].self, from: data)
                // Check if we have the default categories
                let defaultNames = ["Work", "Personal Care", "Leisure"]
                shouldAddDefaults = categories.filter { defaultNames.contains($0.name) }.count != defaultNames.count
            } catch {
                print("Error loading categories: \(error)")
                categories = []
            }
        }
        
        if shouldAddDefaults {
            addDefaultCategories()
        }
    }
    
    private func addDefaultCategories() {
        let defaultCategories = [
            Category(id: UUID(), name: "Work", color: "#E74C3C"),        // Rosso più piacevole
            Category(id: UUID(), name: "Personal Care", color: "#2ECC71"), // Verde più piacevole
            Category(id: UUID(), name: "Leisure", color: "#3498DB")      // Blu più piacevole
        ]
        
        // Merge with existing categories, keeping any custom ones
        let existingCustomCategories = categories.filter { category in
            !defaultCategories.contains { $0.name == category.name }
        }
        
        categories = defaultCategories + existingCustomCategories
        saveCategories()
        
        // Force sync with iOS app
        UserDefaults.standard.synchronize()
    }
    
    func loadPriorities() {
        self.priorities = Priority.allCases
    }
    
    func addCategory(_ category: Category) {
        categories.append(category)
        saveCategories()
    }
    
    func removeCategory(at indexSet: IndexSet) {
        categories.remove(atOffsets: indexSet)
        saveCategories()
    }
    
    func removeCategory(withID id: UUID) {
        categories.removeAll { $0.id == id }
        saveCategories()
    }
    
    private func saveCategories() {
        do {
            let data = try JSONEncoder().encode(categories)
            UserDefaults.standard.set(data, forKey: categoriesKey)
        } catch {
            print("Error saving categories: \(error)")
        }
    }
    
    private func loadPomodoroSettings() {
        if let data = UserDefaults.standard.data(forKey: "watchPomodoroSettings"),
           let settings = try? JSONDecoder().decode(PomodoroSettings.self, from: data) {
            pomodoroSettings = settings
        }
    }
    
    func savePomodoroSettings() {
        if let encoded = try? JSONEncoder().encode(pomodoroSettings) {
            UserDefaults.standard.set(encoded, forKey: "watchPomodoroSettings")
        }
    }
    
    func updatePomodoroSettings(workDuration: Int, breakDuration: Int, longBreakDuration: Int, sessionsUntilLongBreak: Int) {
        let newSettings = PomodoroSettings(
            workDuration: Double(workDuration) * 60.0, // Convert to seconds
            breakDuration: Double(breakDuration) * 60.0, // Convert to seconds
            longBreakDuration: Double(longBreakDuration) * 60.0, // Convert to seconds
            sessionsUntilLongBreak: sessionsUntilLongBreak
        )
        self.pomodoroSettings = newSettings
        
        // Aggiorna le impostazioni di default per i nuovi task
        UserDefaults.standard.set(Double(workDuration) * 60.0, forKey: "defaultWorkDuration")
        UserDefaults.standard.set(Double(breakDuration) * 60.0, forKey: "defaultBreakDuration")
        UserDefaults.standard.set(Double(longBreakDuration) * 60.0, forKey: "defaultLongBreakDuration")
        UserDefaults.standard.set(sessionsUntilLongBreak, forKey: "defaultSessionsUntilLongBreak")
    }
    
    // Add method to clear all data
    func clearAllData() {
        categories = []
        UserDefaults.standard.removeObject(forKey: categoriesKey)
        UserDefaults.standard.removeObject(forKey: "watchPomodoroSettings")
        UserDefaults.standard.removeObject(forKey: "defaultWorkDuration")
        UserDefaults.standard.removeObject(forKey: "defaultBreakDuration")
        UserDefaults.standard.removeObject(forKey: "defaultLongBreakDuration")
        UserDefaults.standard.removeObject(forKey: "defaultSessionsUntilLongBreak")
        UserDefaults.standard.synchronize()
        
        // Reset to default values
        pomodoroSettings = PomodoroSettings(
            workDuration: 25.0 * 60.0,
            breakDuration: 5.0 * 60.0,
            longBreakDuration: 15.0 * 60.0,
            sessionsUntilLongBreak: 4
        )
    }
}
</file>

<file path="SnapTask Watch App Watch App/ViewModels/StatisticsViewModel.swift/StatisticsViewModel.swift">
import Foundation
import SwiftUI

class StatisticsViewModel: ObservableObject {
    enum TimeRange: String, CaseIterable {
        case today = "Today"
        case week = "This Week"
        case month = "This Month"
        case year = "This Year"
    }
    
    struct CategoryStat: Identifiable {
        let id = UUID()
        let name: String
        let color: String
        let hours: Double
        let percentage: Double
    }
    
    struct DailyStat: Identifiable {
        let id = UUID()
        let day: String
        let completedTasks: Int
        let totalTasks: Int
    }
    
    @Published var selectedTimeRange: TimeRange = .week
    @Published var categoryStats: [CategoryStat] = []
    @Published var weeklyStats: [DailyStat] = []
    @Published var currentStreak: Int = 0
    @Published var bestStreak: Int = 0
    
    private let taskManager = TaskManager.shared
    
    func refreshStats() {
        calculateCategoryStats()
        calculateWeeklyStats()
        calculateStreaks()
    }
    
    private func calculateCategoryStats() {
        let startDate: Date
        let endDate = Date()
        
        switch selectedTimeRange {
        case .today:
            startDate = Calendar.current.startOfDay(for: endDate)
        case .week:
            startDate = Calendar.current.date(byAdding: .day, value: -7, to: endDate)!
        case .month:
            startDate = Calendar.current.date(byAdding: .month, value: -1, to: endDate)!
        case .year:
            startDate = Calendar.current.date(byAdding: .year, value: -1, to: endDate)!
        }
        
        var categoryToTime: [String: TimeInterval] = [:]
        var totalTime: TimeInterval = 0
        
        for task in taskManager.tasks {
            guard task.hasDuration else { continue }
            
            // Ottieni le date di completamento nel range specificato
            let completions = task.completions.filter { dateCompletion in
                let date = dateCompletion.key
                return date >= startDate && date <= endDate && dateCompletion.value.isCompleted
            }
            
            if completions.isEmpty { continue }
            
            // Calcola il tempo totale per categoria
            let categoryName = task.category?.name ?? "Uncategorized"
            let categoryColor = task.category?.color ?? "AAAAAA"
            let taskDuration = Double(task.duration) * 60 // Converti in secondi
            
            let totalTaskTime = taskDuration * Double(completions.count)
            categoryToTime[categoryName, default: 0] += totalTaskTime
            totalTime += totalTaskTime
        }
        
        // Converti in ore e crea gli oggetti CategoryStat
        var stats: [CategoryStat] = []
        for (name, time) in categoryToTime {
            let hours = time / 3600 // Converti secondi in ore
            let percentage = totalTime > 0 ? (time / totalTime) * 100 : 0
            
            let color = taskManager.tasks
                .first(where: { $0.category?.name == name })?
                .category?.color ?? "AAAAAA"
            
            stats.append(CategoryStat(name: name, color: color, hours: hours, percentage: percentage))
        }
        
        categoryStats = stats.sorted { $0.hours > $1.hours }
    }
    
    private func calculateWeeklyStats() {
        let calendar = Calendar.current
        let today = Date()
        var stats: [DailyStat] = []
        
        for dayOffset in -6...0 {
            guard let date = calendar.date(byAdding: .day, value: dayOffset, to: today) else { continue }
            
            let dayFormatter = DateFormatter()
            dayFormatter.dateFormat = "E"
            let dayString = dayFormatter.string(from: date)
            
            let dayStart = calendar.startOfDay(for: date)
            let completedTasks = countCompletedTasks(for: dayStart)
            let totalTasks = countTotalTasks(for: dayStart)
            
            stats.append(DailyStat(
                day: dayString,
                completedTasks: completedTasks,
                totalTasks: totalTasks
            ))
        }
        
        weeklyStats = stats
    }
    
    private func calculateStreaks() {
        let calendar = Calendar.current
        let today = Date()
        
        var currentStreak = 0
        var bestStreak = 0
        var tempStreak = 0
        
        // Calcola gli ultimi 365 giorni
        for dayOffset in (0...365).reversed() {
            guard let date = calendar.date(byAdding: .day, value: -dayOffset, to: today) else { continue }
            
            let dayStart = calendar.startOfDay(for: date)
            let completedTasks = countCompletedTasks(for: dayStart)
            let totalTasks = countTotalTasks(for: dayStart)
            
            if completedTasks > 0 && totalTasks > 0 && completedTasks >= totalTasks / 2 {
                // Giorno produttivo (almeno metà dei task completati)
                tempStreak += 1
                
                if tempStreak > bestStreak {
                    bestStreak = tempStreak
                }
                
                // Se siamo nel giorno corrente, aggiorna lo streak attuale
                if dayOffset == 0 {
                    currentStreak = tempStreak
                }
            } else {
                // Streak interrotto
                tempStreak = 0
                
                // Se è il giorno corrente senza attività, lo streak attuale è 0
                if dayOffset == 0 {
                    currentStreak = 0
                }
            }
        }
        
        self.currentStreak = currentStreak
        self.bestStreak = bestStreak
    }
    
    private func countCompletedTasks(for date: Date) -> Int {
        let tasks = taskManager.tasks.filter { task in
            if let completion = task.completions[date], completion.isCompleted {
                return true
            }
            return false
        }
        return tasks.count
    }
    
    private func countTotalTasks(for date: Date) -> Int {
        let dateStart = Calendar.current.startOfDay(for: date)
        
        return taskManager.tasks.filter { task in
            let taskDate = Calendar.current.startOfDay(for: task.startTime)
            
            // Task creati per quella data
            if taskDate == dateStart {
                return true
            }
            
            // Task ricorrenti attivi in quella data
            if let recurrence = task.recurrence, recurrence.isActiveOn(date: date) {
                return true
            }
            
            return false
        }.count
    }
}
</file>

<file path="SnapTask Watch App Watch App/ViewModels/TaskFormViewModel.swift/TaskFormViewModel.swift">
import Foundation
import SwiftUI

class TaskFormViewModel: ObservableObject {
    @Published var name: String = ""
    @Published var icon: String = "checkmark.circle"
    @Published var startTime: Date
    @Published var duration: TimeInterval = 1800 // 30 minutes in seconds
    @Published var hasDuration: Bool = false
    @Published var category: Category?
    @Published var priority: Priority = .medium
    @Published var isRecurring: Bool = false
    @Published var recurrenceType: String = "daily"
    @Published var selectedDaysOfWeek: Set<Int> = []
    @Published var selectedDaysOfMonth: Set<Int> = []
    @Published var pomodoroSettings: PomodoroSettings?
    @Published var subtasks: [Subtask] = []
    
    var editingTask: TodoTask?
    private let taskManager = TaskManager.shared
    
    init(task: TodoTask? = nil, initialDate: Date = Date()) {
        self.startTime = initialDate
        
        if let task = task {
            self.editingTask = task
            self.name = task.name
            self.icon = task.icon
            self.startTime = task.startTime
            self.duration = task.duration
            self.hasDuration = task.hasDuration
            self.category = task.category
            self.priority = task.priority
            self.isRecurring = task.recurrence != nil
            self.recurrence = task.recurrence
            self.pomodoroSettings = task.pomodoroSettings
            self.subtasks = task.subtasks
            
            if let recurrence = task.recurrence {
                switch recurrence.type {
                case .daily:
                    self.recurrenceType = "daily"
                    self.selectedDaysOfWeek = []
                    self.selectedDaysOfMonth = []
                case .weekly(let days):
                    self.recurrenceType = "weekly"
                    self.selectedDaysOfWeek = days
                    self.selectedDaysOfMonth = []
                case .monthly(let days):
                    self.recurrenceType = "monthly"
                    self.selectedDaysOfWeek = []
                    self.selectedDaysOfMonth = days
                }
            }
        }
    }
    
    var recurrence: Recurrence? {
        get {
            guard isRecurring else { return nil }
            
            let recurrenceStartDate = Calendar.current.startOfDay(for: self.startTime)
            
            switch recurrenceType {
            case "daily":
                return Recurrence(type: .daily, startDate: recurrenceStartDate, endDate: nil)
            case "weekly":
                return Recurrence(type: .weekly(days: selectedDaysOfWeek), startDate: recurrenceStartDate, endDate: nil)
            case "monthly":
                return Recurrence(type: .monthly(days: selectedDaysOfMonth), startDate: recurrenceStartDate, endDate: nil)
            default:
                return nil
            }
        }
        set {
            if let newValue = newValue {
                isRecurring = true
                switch newValue.type {
                case .daily:
                    recurrenceType = "daily"
                    selectedDaysOfWeek = []
                    selectedDaysOfMonth = []
                case .weekly(let days):
                    recurrenceType = "weekly"
                    selectedDaysOfWeek = days
                    selectedDaysOfMonth = []
                case .monthly(let days):
                    recurrenceType = "monthly"
                    selectedDaysOfWeek = []
                    selectedDaysOfMonth = days
                }
            } else {
                isRecurring = false
                recurrenceType = "daily"
                selectedDaysOfWeek = []
                selectedDaysOfMonth = []
            }
        }
    }
    
    func addSubtask(_ name: String) {
        let newSubtask = Subtask(id: UUID(), name: name, isCompleted: false)
        subtasks.append(newSubtask)
        objectWillChange.send()
    }
    
    func removeSubtask(at index: Int) {
        guard index >= 0 && index < subtasks.count else { return }
        subtasks.remove(at: index)
        objectWillChange.send()
    }
    
    func moveSubtask(from source: IndexSet, to destination: Int) {
        subtasks.move(fromOffsets: source, toOffset: destination)
        objectWillChange.send()
    }
    
    func updateSubtask(_ subtask: Subtask) {
        if let index = subtasks.firstIndex(where: { $0.id == subtask.id }) {
            subtasks[index] = subtask
            objectWillChange.send()
        }
    }
    
    @discardableResult
    func saveTask() -> TodoTask {
        if let editingTask = editingTask {
            // Editing existing task
            var updatedTask = TodoTask(
                id: editingTask.id,
                name: name,
                description: nil,
                startTime: startTime,
                duration: duration,
                hasDuration: hasDuration,
                category: category,
                priority: priority,
                icon: icon,
                recurrence: recurrence,
                pomodoroSettings: pomodoroSettings,
                subtasks: subtasks
            )
            
            // Preserve completions and completion dates
            updatedTask.completions = editingTask.completions
            updatedTask.completionDates = editingTask.completionDates
            
            // Update subtask completion states
            for subtask in subtasks {
                if let existingSubtask = editingTask.subtasks.first(where: { $0.id == subtask.id }) {
                    for (date, completion) in editingTask.completions {
                        if completion.completedSubtasks.contains(existingSubtask.id) {
                            updatedTask.completions[date]?.completedSubtasks.insert(subtask.id)
                        }
                    }
                }
            }
            
            taskManager.updateTask(updatedTask)
            return updatedTask
        } else {
            // Creating new task
            let newTask = TodoTask(
                id: UUID(),
                name: name,
                description: nil,
                startTime: startTime,
                duration: duration,
                hasDuration: hasDuration,
                category: category,
                priority: priority,
                icon: icon,
                recurrence: recurrence,
                pomodoroSettings: pomodoroSettings,
                subtasks: subtasks
            )
            
            taskManager.addTask(newTask)
            return newTask
        }
    }
    
    func configurePomodoroSettings(workDuration: Int, breakDuration: Int, longBreakDuration: Int, sessionsUntilLongBreak: Int) {
        pomodoroSettings = PomodoroSettings(
            workDuration: Double(workDuration) * 60.0, // Convert to seconds
            breakDuration: Double(breakDuration) * 60.0, // Convert to seconds
            longBreakDuration: Double(longBreakDuration) * 60.0, // Convert to seconds
            sessionsUntilLongBreak: sessionsUntilLongBreak
        )
    }
    
    func removePomodoroSettings() {
        pomodoroSettings = nil
    }
}
</file>

<file path="SnapTask Watch App Watch App/ViewModels/TimelineViewModel.swift/TimelineViewModel.swift">
import Foundation
import SwiftUI

class TimelineViewModel: ObservableObject {
    @Published var selectedDate: Date = Date()
    @Published var selectedDayOffset: Int = 0
    
    // Proprietà calcolata per la stringa del mese e anno
    var monthYearString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: selectedDate)
    }
    
    // Proprietà calcolata per il giorno della settimana
    var weekdayString: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE"
        return formatter.string(from: selectedDate)
    }
    
    // Funzione per selezionare una data specifica
    func selectDate(_ offset: Int) {
        if let newDate = Calendar.current.date(byAdding: .day, value: offset, to: Date()) {
            selectedDate = newDate
            selectedDayOffset = offset
        }
    }
    
    // Funzione per selezionare una data specifica
    func selectSpecificDate(_ date: Date) {
        selectedDate = date
        if let days = Calendar.current.dateComponents([.day], from: Date(), to: date).day {
            selectedDayOffset = days
        }
    }
    
    // Funzione per ottenere i task per la data selezionata
    func tasksForSelectedDate() -> [TodoTask] {
        let taskManager = TaskManager.shared
        let startOfDay = Calendar.current.startOfDay(for: selectedDate)
        
        return taskManager.tasks.filter { task in
            let taskDate = Calendar.current.startOfDay(for: task.startTime)
            
            // Include i task del giorno selezionato
            if taskDate == startOfDay {
                return true
            }
            
            // Include i task ricorrenti attivi nella data selezionata
            if let recurrence = task.recurrence, recurrence.isActiveOn(date: selectedDate) {
                return true
            }
            
            return false
        }
        .sorted { $0.startTime < $1.startTime }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/CreateTaskView.swift/CreateTaskView.swift">
import SwiftUI

struct CreateTaskView: View {
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = TaskFormViewModel()
    
    var body: some View {
        WatchTaskFormView(viewModel: viewModel, isPresented: .constant(true))
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
    }
}

#Preview {
    CreateTaskView()
}
</file>

<file path="SnapTask Watch App Watch App/Views/PomodoroListView.swift/PomodoroListView.swift">
import SwiftUI

struct PomodoroListView: View {
    @ObservedObject private var taskManager = TaskManager.shared
    
    var body: some View {
        List {
            if pomodoroTasks.isEmpty {
                Text("No Pomodoro tasks")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, alignment: .center)
                    .listRowBackground(Color.clear)
            } else {
                ForEach(pomodoroTasks) { task in
                    NavigationLink(destination: WatchPomodoroView(task: task)) {
                        WatchPomodoroRow(task: task)
                    }
                }
            }
        }
        .listStyle(CarouselListStyle())
        .navigationTitle("Pomodoro")
    }
    
    private var pomodoroTasks: [TodoTask] {
        taskManager.tasks.filter { $0.pomodoroSettings != nil }
            .sorted { $0.name < $1.name }
    }
}

struct WatchPomodoroRow: View {
    let task: TodoTask
    
    var body: some View {
        HStack {
            // Task icon with colored background
            ZStack {
                Circle()
                    .fill(task.category != nil ? Color(hex: task.category!.color) : Color.gray)
                    .frame(width: 30, height: 30)
                
                Image(systemName: task.icon)
                    .foregroundColor(.white)
                    .font(.system(size: 14))
            }
            
            VStack(alignment: .leading, spacing: 2) {
                Text(task.name)
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                
                if let settings = task.pomodoroSettings {
                    Text("\(settings.workDuration)m focus / \(settings.breakDuration)m break")
                        .font(.system(size: 12))
                        .foregroundColor(.secondary)
                        .lineLimit(1)
                }
            }
        }
        .padding(.vertical, 2)
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/QuickStatsView.swift/QuickStatsView.swift">
import SwiftUI

struct QuickStatsView: View {
    @ObservedObject private var taskManager = TaskManager.shared
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                completionRateCard
                topStreaksCard
            }
            .padding(10)
        }
        .navigationTitle("Stats")
    }
    
    // Completion rate card
    private var completionRateCard: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text("Today's Progress")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(.primary)
            
            HStack {
                Text("\(completionRate)%")
                    .font(.system(size: 24, weight: .bold))
                    .foregroundColor(.blue)
                
                Spacer()
                
                Text("\(completedToday)/\(totalTasksToday)")
                    .font(.system(size: 14))
                    .foregroundColor(.secondary)
            }
            
            // Progress bar
            progressBar
        }
        .padding(10)
        .background(Color.secondary.opacity(0.2))
        .cornerRadius(12)
    }
    
    // Progress bar
    private var progressBar: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .frame(width: geometry.size.width, height: 10)
                    .opacity(0.2)
                    .foregroundColor(.blue)
                    .cornerRadius(5)
                
                Rectangle()
                    .frame(width: progressWidth(totalWidth: geometry.size.width), height: 10)
                    .foregroundColor(.blue)
                    .cornerRadius(5)
            }
        }
        .frame(height: 10)
    }
    
    // Helper method to calculate progress width
    private func progressWidth(totalWidth: CGFloat) -> CGFloat {
        let percentage = Double(completedToday) / max(Double(totalTasksToday), 1.0)
        return totalWidth * CGFloat(percentage)
    }
    
    // Top streaks card
    private var topStreaksCard: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text("Top Streaks")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(.primary)
            
            streakContent
        }
        .padding(10)
        .background(Color.secondary.opacity(0.2))
        .cornerRadius(12)
    }
    
    // Streak content
    private var streakContent: some View {
        Group {
            if topStreakTasks.isEmpty {
                Text("No active streaks")
                    .font(.system(size: 14))
                    .foregroundColor(.secondary)
            } else {
                streaksList
            }
        }
    }
    
    // Streaks list
    private var streaksList: some View {
        ForEach(topStreakTasks.prefix(3)) { task in
            HStack {
                Text(task.name)
                    .font(.system(size: 14))
                    .foregroundColor(.primary)
                    .lineLimit(1)
                
                Spacer()
                
                HStack(spacing: 4) {
                    Image(systemName: "flame.fill")
                        .foregroundColor(.orange)
                        .font(.system(size: 12))
                    
                    Text("\(task.currentStreak)")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.orange)
                }
            }
        }
    }
    
    private var todayTasks: [TodoTask] {
        let today = Date().startOfDay
        
        return taskManager.tasks.filter { task in
            let taskDate = Calendar.current.startOfDay(for: task.startTime)
            
            // Include tasks for today
            if taskDate == today {
                return true
            }
            
            // Include recurring tasks active today
            if let recurrence = task.recurrence, recurrence.isActiveOn(date: today) {
                return true
            }
            
            return false
        }
    }
    
    private var completedToday: Int {
        todayTasks.filter { task in
            if let completion = task.completions[Date().startOfDay] {
                return completion.isCompleted
            }
            return false
        }.count
    }
    
    private var totalTasksToday: Int {
        todayTasks.count
    }
    
    private var completionRate: Int {
        let total = totalTasksToday
        if total == 0 {
            return 0
        }
        
        return Int(Double(completedToday) / Double(total) * 100.0)
    }
    
    private var topStreakTasks: [TodoTask] {
        taskManager.tasks
            .filter { $0.recurrence != nil && $0.currentStreak > 0 }
            .sorted { $0.currentStreak > $1.currentStreak }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/SettingsWatchView.swift/SettingsWatchView.swift">
import SwiftUI

struct SettingsWatchView: View {
    @StateObject private var viewModel = SettingsViewModel()
    @StateObject private var quoteManager = QuoteManager.shared
    @StateObject private var cloudKitService = CloudKitService.shared
    @Environment(\.colorScheme) private var colorScheme
    @AppStorage("isDarkMode") private var isDarkMode = false
    @State private var showingLanguagePicker = false
    @State private var showingCategoriesView = false
    @State private var showingPrioritiesView = false
    @State private var showingPomodoroSettings = false
    @State private var selectedLanguage = "en"
    
    // Date formatter
    private var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                // Quote of the day
                VStack(alignment: .leading, spacing: 8) {
                    Text("Quote of the Day")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    if quoteManager.isLoading {
                        ProgressView()
                            .frame(maxWidth: .infinity, alignment: .center)
                            .padding(.vertical, 8)
                    } else {
                        Text(quoteManager.currentQuote.text)
                            .font(.caption)
                            .italic()
                        
                        Text("- \(quoteManager.currentQuote.author)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                    
                    Button(action: {
                        Task {
                            await quoteManager.forceUpdateQuote()
                        }
                    }) {
                        Label("New Quote", systemImage: "arrow.clockwise")
                            .font(.caption)
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.small)
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 10)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.gray.opacity(0.1))
                )
                
                // iCloud Sync Section - NEW
                VStack(alignment: .leading, spacing: 8) {
                    Text("iCloud Sync")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    if cloudKitService.isSyncing {
                        HStack {
                            ProgressView()
                                .controlSize(.small)
                            Text("Sincronizzazione in corso...")
                                .font(.caption)
                        }
                    } else {
                        Button(action: {
                            cloudKitService.syncTasks()
                        }) {
                            Label("Sincronizza Ora", systemImage: "arrow.triangle.2.circlepath.icloud.fill")
                        }
                        .buttonStyle(.bordered)
                        // .disabled(cloudKitService.isSyncing) // Already handled by showing ProgressView
                    }
                    
                    if let lastSync = cloudKitService.lastSyncDate {
                        Text("Ultima sinc.: \(lastSync, formatter: dateFormatter)")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    } else {
                        Text("Ultima sinc.: Mai")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                    
                    if let error = cloudKitService.syncError {
                        Text("Errore: \(error.localizedDescription)")
                            .font(.caption2)
                            .foregroundColor(.red)
                            .lineLimit(5)
                    }
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 10)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.gray.opacity(0.1))
                )
                
                // Categories
                Button(action: { showingCategoriesView = true }) {
                    HStack {
                        Label("Categories", systemImage: "folder.fill")
                        Spacer()
                        Text("\(viewModel.categories.count)")
                            .foregroundColor(.secondary)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // Priorities
                Button(action: { showingPrioritiesView = true }) {
                    HStack {
                        Label("Priorities", systemImage: "flag.fill")
                        Spacer()
                        Text("\(viewModel.priorities.count)")
                            .foregroundColor(.secondary)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // Pomodoro Settings
                Button(action: { showingPomodoroSettings = true }) {
                    HStack {
                        Label("Pomodoro Settings", systemImage: "timer")
                        Spacer()
                        Image(systemName: "chevron.right")
                            .font(.caption2)
                            .foregroundColor(.secondary)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
                
                // Appearance
                VStack(spacing: 8) {
                    Toggle("Dark Mode", isOn: $isDarkMode)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 4)
                    
                    Divider()
                        .padding(.horizontal, 12)
                    
                    Button(action: { showingLanguagePicker = true }) {
                        HStack {
                            Label("Language", systemImage: "globe")
                            Spacer()
                            Text(selectedLanguage == "en" ? "English" : "Italiano")
                                .foregroundColor(.secondary)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 4)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(Color.gray.opacity(0.1))
                )
                
                // App Info
                VStack(alignment: .center, spacing: 4) {
                    Text("SnapTask")
                        .font(.caption)
                        .bold()
                    
                    Text("Version 1.0")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .padding(.top, 8)
            }
            .padding()
        }
        .onAppear {
            viewModel.loadCategories()
            viewModel.loadPriorities()
            
            Task {
                await quoteManager.checkAndUpdateQuote()
            }
        }
        .sheet(isPresented: $showingLanguagePicker) {
            LanguagePicker(selectedLanguage: $selectedLanguage)
        }
        .sheet(isPresented: $showingCategoriesView) {
            WatchCategoriesView(viewModel: viewModel)
        }
        .sheet(isPresented: $showingPrioritiesView) {
            WatchPrioritiesView(viewModel: viewModel)
        }
        .sheet(isPresented: $showingPomodoroSettings) {
            WatchPomodoroSettingsView(viewModel: viewModel)
        }
    }
}

struct WatchCategoriesView: View {
    @ObservedObject var viewModel: SettingsViewModel
    @State private var showingNewCategorySheet = false
    @State private var categoryName = ""
    @State private var categoryColor = "FF5733"
    @State private var showingColorPicker = false
    
    // Predefined colors for watchOS
    private let predefinedColors = [
        "FF5733", // Red-orange
        "3498DB", // Blue
        "2ECC71", // Green
        "F1C40F", // Yellow
        "9B59B6", // Purple
        "1ABC9C", // Teal
        "E74C3C", // Red
        "34495E", // Dark blue
        "D35400", // Orange
        "8E44AD"  // Violet
    ]
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                Text("Categories")
                    .font(.headline)
                    .padding(.top, 8)
                
                if viewModel.categories.isEmpty {
                    Text("No categories yet")
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    ForEach(viewModel.categories) { category in
                        HStack {
                            Circle()
                                .fill(Color(hex: category.color))
                                .frame(width: 16, height: 16)
                            
                            Text(category.name)
                                .lineLimit(1)
                            
                            Spacer()
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.gray.opacity(0.1))
                        )
                    }
                }
                
                Divider()
                    .padding(.vertical, 8)
                
                // Add new category form
                VStack(spacing: 10) {
                    Text("New Category")
                        .font(.subheadline)
                    
                    TextField("Category name", text: $categoryName)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 6)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    
                    // Color selection button instead of ColorPicker
                    Button(action: {
                        showingColorPicker = true
                    }) {
                        HStack {
                            Text("Color")
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            Circle()
                                .fill(Color(hex: categoryColor))
                                .frame(width: 20, height: 20)
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.gray.opacity(0.1))
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                    
                    Button(action: {
                        if !categoryName.isEmpty {
                            let newCategory = Category(id: UUID(), name: categoryName, color: categoryColor)
                            viewModel.addCategory(newCategory)
                            categoryName = ""
                            categoryColor = "FF5733"
                        }
                    }) {
                        Label("Add Category", systemImage: "plus")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    .disabled(categoryName.isEmpty)
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.gray.opacity(0.1))
                )
            }
            .padding()
        }
        .sheet(isPresented: $showingColorPicker) {
            WatchColorPicker(selectedColor: $categoryColor)
        }
    }
}

// Add a new color picker view for watchOS
struct WatchColorPicker: View {
    @Binding var selectedColor: String
    @Environment(\.dismiss) private var dismiss
    
    // Predefined colors for watchOS
    private let predefinedColors = [
        "FF5733", // Red-orange
        "3498DB", // Blue
        "2ECC71", // Green
        "F1C40F", // Yellow
        "9B59B6", // Purple
        "1ABC9C", // Teal
        "E74C3C", // Red
        "34495E", // Dark blue
        "D35400", // Orange
        "8E44AD"  // Violet
    ]
    
    var body: some View {
        VStack(spacing: 16) {
            Text("Select Color")
                .font(.headline)
                .padding(.top, 8)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 3), spacing: 12) {
                ForEach(predefinedColors, id: \.self) { color in
                    Button(action: {
                        selectedColor = color
                        dismiss()
                    }) {
                        Circle()
                            .fill(Color(hex: color))
                            .frame(width: 40, height: 40)
                            .overlay(
                                ZStack {
                                    if selectedColor == color {
                                        Image(systemName: "checkmark")
                                            .foregroundColor(.white)
                                    }
                                }
                            )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding()
            
            Button("Cancel") {
                dismiss()
            }
            .buttonStyle(.bordered)
            .padding(.bottom)
        }
    }
}

struct WatchPrioritiesView: View {
    @ObservedObject var viewModel: SettingsViewModel
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                Text("Priorities")
                    .font(.headline)
                    .padding(.top, 8)
                
                ForEach(viewModel.priorities, id: \.self) { priority in
                    HStack {
                        Image(systemName: priority.icon)
                            .foregroundColor(Color(hex: priority.color))
                        
                        Text(priority.rawValue.capitalized)
                        
                        Spacer()
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                
                Text("Priorities are predefined and cannot be modified on Apple Watch. Use the iPhone app for advanced customization.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .multilineTextAlignment(.center)
                    .padding(.top, 8)
            }
            .padding()
        }
    }
}

struct WatchPomodoroSettingsView: View {
    @ObservedObject var viewModel: SettingsViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var workDuration: Double = 25
    @State private var breakDuration: Double = 5
    @State private var longBreakDuration: Double = 15
    @State private var sessionsUntilLongBreak: Double = 4
    
    var body: some View {
        ScrollView {
            VStack(spacing: 16) {
                Text("Pomodoro Settings")
                    .font(.headline)
                    .padding(.top, 8)
                
                VStack(spacing: 8) {
                    Text("Work Duration: \(Int(workDuration)) min")
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Slider(value: $workDuration, in: 5...60, step: 5)
                }
                
                VStack(spacing: 8) {
                    Text("Break Duration: \(Int(breakDuration)) min")
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Slider(value: $breakDuration, in: 1...30, step: 1)
                }
                
                VStack(spacing: 8) {
                    Text("Long Break: \(Int(longBreakDuration)) min")
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Slider(value: $longBreakDuration, in: 5...45, step: 5)
                }
                
                VStack(spacing: 8) {
                    Text("Sessions until Long Break: \(Int(sessionsUntilLongBreak))")
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Slider(value: $sessionsUntilLongBreak, in: 2...6, step: 1)
                }
                
                Button("Save") {
                    viewModel.updatePomodoroSettings(
                        workDuration: Int(workDuration),
                        breakDuration: Int(breakDuration),
                        longBreakDuration: Int(longBreakDuration),
                        sessionsUntilLongBreak: Int(sessionsUntilLongBreak)
                    )
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
                .padding(.top, 8)
            }
            .padding()
        }
        .onAppear {
            // Convert from seconds to minutes for UI
            workDuration = viewModel.pomodoroSettings.workDuration / 60.0
            breakDuration = viewModel.pomodoroSettings.breakDuration / 60.0
            longBreakDuration = viewModel.pomodoroSettings.longBreakDuration / 60.0
            sessionsUntilLongBreak = Double(viewModel.pomodoroSettings.sessionsUntilLongBreak)
        }
    }
}

struct LanguagePicker: View {
    @Binding var selectedLanguage: String
    @Environment(\.dismiss) private var dismiss
    
    let languages = [
        ("en", "English"),
        ("it", "Italiano")
    ]
    
    var body: some View {
        VStack(spacing: 16) {
            Text("Select Language")
                .font(.headline)
                .padding(.top, 8)
            
            ForEach(languages, id: \.0) { code, name in
                Button(action: {
                    selectedLanguage = code
                    dismiss()
                }) {
                    HStack {
                        Text(name)
                        
                        Spacer()
                        
                        if selectedLanguage == code {
                            Image(systemName: "checkmark")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding()
    }
}

// Extension per ottenere il codice esadecimale da un Color
extension Color {
    func toHex() -> String? {
        let uic = UIColor(self)
        guard let components = uic.cgColor.components, components.count >= 3 else {
            return nil
        }
        let r = Float(components[0])
        let g = Float(components[1])
        let b = Float(components[2])
        
        return String(format: "%02lX%02lX%02lX", lroundf(r * 255), lroundf(g * 255), lroundf(b * 255))
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/TaskListView.swift/TaskListView.swift">
import SwiftUI

struct TaskListView: View {
    @ObservedObject private var taskManager = TaskManager.shared
    @State private var date = Date()
    @State private var isShowingCreateTask = false
    @State private var showTaskDetail: TodoTask? = nil
    @State private var editingTask: TodoTask? = nil
    @State private var hapticEngine = WKHapticType.click
    @State private var selectedTask: TodoTask? = nil
    @State private var showingActionSheet = false
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading) {
                if todaysTasks.isEmpty {
                    Text("No tasks for today (Simplified View)")
                        .foregroundColor(.secondary)
                        .frame(maxWidth: .infinity, alignment: .center)
                        .padding()
                } else {
                    Text("Tasks (Simplified View):")
                        .font(.headline)
                        .padding(.bottom, 5)
                    
                    ForEach(todaysTasks) { taskItem in
                        TaskRowView(
                            task: taskItem,
                            onTap: {
                                showTaskDetail = taskItem
                                WKInterfaceDevice.current().play(hapticEngine)
                            },
                            onLongPress: {
                                selectedTask = taskItem
                                showingActionSheet = true
                                WKInterfaceDevice.current().play(hapticEngine)
                            }
                        )
                        Divider()
                    }
                }
            }
        }
        .navigationTitle("Tasks (Simplified)")
        .sheet(isPresented: $isShowingCreateTask) {
            WatchTaskFormView(
                viewModel: editingTask != nil ? TaskFormViewModel(task: editingTask!, initialDate: date) : TaskFormViewModel(initialDate: date),
                isPresented: $isShowingCreateTask
            )
            .onDisappear {
                editingTask = nil
            }
        }
        .sheet(item: $showTaskDetail) { task in
            WatchTaskDetailView(task: task, date: date)
        }
        .sheet(isPresented: $showingActionSheet) {
            if let task = selectedTask {
                ActionSheetView(
                    task: task,
                    onEdit: {
                        editingTask = task
                        isShowingCreateTask = true
                        showingActionSheet = false
                    },
                    onDelete: {
                        taskManager.removeTask(task)
                        showingActionSheet = false
                    }
                )
            }
        }
    }
    
    private var todaysTasks: [TodoTask] {
        let startOfDay = Calendar.current.startOfDay(for: date)
        return taskManager.tasks.filter { task in
            let taskDate = Calendar.current.startOfDay(for: task.startTime)
            
            if taskDate == startOfDay {
                return true
            }
            
            if let recurrence = task.recurrence, recurrence.isActiveOn(date: date) {
                return true
            }
            
            return false
        }
        .sorted { $0.startTime < $1.startTime }
    }
}

struct TaskRowView: View {
    let task: TodoTask
    let onTap: () -> Void
    let onLongPress: () -> Void
    
    var body: some View {
        Button(action: onTap) {
            HStack {
                Image(systemName: task.completions[Calendar.current.startOfDay(for: Date())]?.isCompleted ?? false ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(task.completions[Calendar.current.startOfDay(for: Date())]?.isCompleted ?? false ? .green : .gray)
                    .font(.system(size: 20))
                
                Text(task.name)
                    .padding(.vertical, 4)
                
                Spacer()
            }
            .padding(.horizontal)
        }
        .buttonStyle(PlainButtonStyle())
        .gesture(
            LongPressGesture(minimumDuration: 0.5)
                .onEnded { _ in
                    onLongPress()
                }
        )
    }
}

struct ActionSheetView: View {
    let task: TodoTask
    let onEdit: () -> Void
    let onDelete: () -> Void
    
    var body: some View {
        List {
            Button(action: onEdit) {
                Label("Edit Task", systemImage: "pencil")
                    .foregroundColor(.orange)
            }
            
            Button(role: .destructive, action: onDelete) {
                Label("Delete Task", systemImage: "trash")
            }
        }
        .listStyle(EllipticalListStyle())
    }
}

struct WatchTaskRow: View {
    @ObservedObject var taskManager: TaskManager
    let taskId: UUID
    @State private var showTaskDetail = false

    private var task: TodoTask? {
        taskManager.tasks.first { $0.id == taskId }
    }

    private var isCompletedToday: Bool {
        guard let currentTask = task else { return false }
        return currentTask.completions[Calendar.current.startOfDay(for: Date())]?.isCompleted ?? false
    }

    var body: some View {
        if let currentTask = task {
            HStack {
                // Check button
                Button(action: {
                    taskManager.toggleTaskCompletion(taskId, on: Date())
                }) {
                    Image(systemName: isCompletedToday ? "checkmark.circle.fill" : "circle")
                        .foregroundColor(isCompletedToday ? .green : .gray)
                        .font(.system(size: 20))
                }
                .buttonStyle(PlainButtonStyle())

                // Rest of the card is tappable for task details
                Button(action: {
                    showTaskDetail = true
                }) {
                    HStack {
                        ZStack {
                            Circle()
                                .fill(currentTask.category != nil ? Color(hex: currentTask.category!.color) : Color.gray)
                                .frame(width: 30, height: 30)

                            Image(systemName: currentTask.icon)
                                .foregroundColor(.white)
                                .font(.system(size: 14))
                        }
                        .padding(.leading, 5)

                        VStack(alignment: .leading, spacing: 2) {
                            Text(currentTask.name)
                                .font(.system(size: 16, weight: .medium))
                                .foregroundColor(isCompletedToday ? .secondary : .primary)
                                .strikethrough(isCompletedToday, color: .secondary)
                                .lineLimit(1)
                        }
                        Spacer()
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding(.vertical, 2)
            .sheet(isPresented: $showTaskDetail) {
                WatchTaskDetailView(task: currentTask, date: Date())
            }
        } else {
            Text("Task not found")
                .foregroundColor(.red)
        }
    }
}

extension Date {
    var startOfDay: Date {
        Calendar.current.startOfDay(for: self)
    }
}

extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/TimelineWatchView.swift/TimelineWatchView.swift">
import SwiftUI

struct TimelineWatchView: View {
    @StateObject private var viewModel = TimelineViewModel()
    @StateObject private var taskManager = TaskManager.shared
    @State private var isShowingCreateTask = false
    @State private var isShowingCalendarPicker = false
    @State private var showTaskDetail: TodoTask? = nil
    @State private var editingTask: TodoTask? = nil
    
    var body: some View {
        VStack(spacing: 4) {
            // Add some padding at the top to prevent clipping
            Color.clear.frame(height: 2)
            
            // Header di navigazione date
            DateNavigationHeader(
                viewModel: viewModel,
                isShowingCalendarPicker: $isShowingCalendarPicker
            )
            .padding(.top, 6) // Add padding to push content down
            
            // Add Task Button
            Button(action: {
                isShowingCreateTask = true
            }) {
                Label("Add Task", systemImage: "plus")
                    .font(.footnote)
            }
            .padding(.vertical, 4)
            .buttonStyle(.borderless)
            
            // Task List
            taskList
        }
        .safeAreaInset(edge: .top) {
            Color.clear.frame(height: 0)
        }
        .ignoresSafeArea(.container, edges: .top)
        .sheet(isPresented: $isShowingCreateTask) {
            WatchTaskFormView(
                viewModel: editingTask != nil ? TaskFormViewModel(task: editingTask!, initialDate: viewModel.selectedDate) : TaskFormViewModel(initialDate: viewModel.selectedDate),
                isPresented: $isShowingCreateTask
            )
            .onDisappear {
                editingTask = nil
            }
        }
        .sheet(item: $showTaskDetail) { task in
            WatchTaskDetailView(task: task, date: viewModel.selectedDate)
        }
        .sheet(isPresented: $isShowingCalendarPicker) {
            VStack {
                Text("Select Date")
                    .font(.headline)
                    .padding(.top)
                
                WatchCalendarPicker(selectedDate: $viewModel.selectedDate, selectedDayOffset: $viewModel.selectedDayOffset)
                    .frame(maxHeight: 200)
                
                Button("Done") {
                    isShowingCalendarPicker = false
                }
                .padding(.bottom)
            }
            .presentationDetents([.height(250)])
        }
    }
    
    // Extracted task list view with improved list style
    private var taskList: some View {
        Group {
            if viewModel.tasksForSelectedDate().isEmpty {
                // Empty state (no tasks)
                VStack {
                    Spacer()
                    Text("No tasks for this day")
                        .foregroundColor(.secondary)
                        .multilineTextAlignment(.center)
                    Spacer()
                }
            } else {
                // Tasks list
                List {
                    ForEach(viewModel.tasksForSelectedDate()) { task in
                        taskRow(task: task)
                            .listRowInsets(EdgeInsets(top: 1, leading: 4, bottom: 1, trailing: 4))
                    }
                }
                .listStyle(CarouselListStyle())
                .scrollDisabled(false)
                .scrollIndicators(.hidden)
            }
        }
    }
    
    // Completely rebuilt task row view for better clickability
    private func taskRow(task: TodoTask) -> some View {
        Button {
            showTaskDetail = task
        } label: {
            HStack(spacing: 8) {
                // Left side - Category bar and indicator
                if let category = task.category {
                    VStack(spacing: 0) {
                        Rectangle()
                            .fill(Color(hex: category.color))
                            .frame(width: 4)
                            .cornerRadius(2)
                    }
                    .frame(maxHeight: .infinity)
                    .padding(.vertical, 2)
                }
                
                // Center - Task info with time
                VStack(alignment: .leading, spacing: 2) {
                    // Task name
                    Text(task.name)
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.primary)
                        .lineLimit(1)
                    
                    // Time if available
                    if task.hasDuration {
                        Text(formatTime(task.startTime))
                            .font(.system(size: 12))
                            .foregroundColor(.secondary)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                
                // Right side - Completion button
                Button {
                    taskManager.toggleTaskCompletion(task.id, on: viewModel.selectedDate)
                } label: {
                    Image(systemName: isCompleted(task) ? "checkmark.circle.fill" : "circle")
                        .font(.system(size: 20))
                        .foregroundColor(isCompleted(task) ? .green : .gray)
                        .contentShape(Circle())
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .buttonStyle(PlainButtonStyle())
        .padding(.vertical, 6)
        .padding(.horizontal, 8)
        .contentShape(Rectangle())
        .contextMenu {
            Button(action: {
                showTaskDetail = task
            }) {
                Label("View Details", systemImage: "info.circle")
            }
            
            Button(action: {
                editingTask = task
                isShowingCreateTask = true 
            }) {
                Label("Edit Task", systemImage: "pencil")
            }
            
            Button(role: .destructive, action: {
                taskManager.removeTask(task)
            }) {
                Label("Delete Task", systemImage: "trash")
            }
        }
    }
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func isCompleted(_ task: TodoTask) -> Bool {
        if let completion = task.completions[viewModel.selectedDate.startOfDay] {
            return completion.isCompleted
        }
        return false
    }
}

struct DateNavigationHeader: View {
    @ObservedObject var viewModel: TimelineViewModel
    @Binding var isShowingCalendarPicker: Bool
    
    var body: some View {
        HStack {
            // Previous Day Button
            Button(action: {
                withAnimation {
                    viewModel.selectDate(viewModel.selectedDayOffset - 1)
                }
            }) {
                Image(systemName: "chevron.left")
                    .font(.system(size: 18))
            }
            .buttonStyle(PlainButtonStyle())
            .frame(width: 30)
            
            // Calendar Icon Button
            Button(action: {
                isShowingCalendarPicker = true
            }) {
                HStack(spacing: 4) {
                    Text(formattedDate)
                        .font(.system(size: 14, weight: .medium))
                        .lineLimit(1)
                        .minimumScaleFactor(0.8)
                    
                    Image(systemName: "calendar")
                        .font(.system(size: 14))
                }
            }
            .buttonStyle(PlainButtonStyle())
            .frame(maxWidth: .infinity)
            
            // Next Day Button
            Button(action: {
                withAnimation {
                    viewModel.selectDate(viewModel.selectedDayOffset + 1)
                }
            }) {
                Image(systemName: "chevron.right")
                    .font(.system(size: 18))
            }
            .buttonStyle(PlainButtonStyle())
            .frame(width: 30)
        }
        .padding(.horizontal, 6)
        .frame(height: 28)
    }
    
    private var formattedDate: String {
        if viewModel.selectedDayOffset == 0 {
            return "Today"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "E, MMM d" // Compact date format
            return formatter.string(from: viewModel.selectedDate)
        }
    }
}

struct WatchCalendarPicker: View {
    @Binding var selectedDate: Date
    @Binding var selectedDayOffset: Int
    
    var body: some View {
        ScrollView {
            LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7), spacing: 8) {
                ForEach(-7...7, id: \.self) { dayOffset in
                    let date = Calendar.current.date(byAdding: .day, value: dayOffset, to: Date()) ?? Date()
                    DayButton(
                        day: date,
                        isSelected: dayOffset == selectedDayOffset,
                        action: {
                            selectedDate = date
                            selectedDayOffset = dayOffset
                        }
                    )
                }
            }
            .padding()
        }
    }
}

struct DayButton: View {
    let day: Date
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            VStack(spacing: 2) {
                Text(dayName)
                    .font(.system(size: 12))
                    .foregroundColor(textColor)
                
                Text(dayNumber)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(textColor)
            }
            .frame(width: 36, height: 36)
            .background(
                Circle()
                    .fill(isSelected ? Color.blue : Color.clear)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    private var dayName: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "E"
        return formatter.string(from: day)
    }
    
    private var dayNumber: String {
        let calendar = Calendar.current
        let day = calendar.component(.day, from: day)
        return "\(day)"
    }
    
    private var textColor: Color {
        if isSelected {
            return .white
        } else {
            return .primary
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/WatchPomodoroView.swift/WatchPomodoroView.swift">
import SwiftUI

struct WatchPomodoroView: View {
    let task: TodoTask
    @StateObject private var viewModel = WatchPomodoroViewModel()
    
    var body: some View {
        VStack(spacing: 8) {
            // Timer Display
            ZStack {
                // Background circle
                Circle()
                    .stroke(lineWidth: 10)
                    .opacity(0.2)
                    .foregroundColor(viewModel.state == .working ? .blue : .green)
                
                // Progress circle
                Circle()
                    .trim(from: 0.0, to: viewModel.progress)
                    .stroke(style: StrokeStyle(
                        lineWidth: 10,
                        lineCap: .round
                    ))
                    .foregroundColor(viewModel.state == .working ? .blue : .green)
                    .rotationEffect(Angle(degrees: -90))
                    .animation(.linear(duration: 0.1), value: viewModel.progress)
                
                // Time and Session Display
                VStack(spacing: 4) {
                    // Session state
                    Text(viewModel.state == .working ? "Focus" : "Break")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.secondary)
                    
                    // Time remaining
                    Text(timeString(from: viewModel.timeRemaining))
                        .font(.system(size: 28, weight: .bold))
                        .monospacedDigit()
                        .foregroundColor(viewModel.state == .working ? .blue : .green)
                }
            }
            .padding(.top, 10)
            
            // Controls
            HStack(spacing: 20) {
                // Play/Pause Button
                Button(action: {
                    if viewModel.state == .notStarted || viewModel.state == .paused {
                        viewModel.start()
                    } else {
                        viewModel.pause()
                    }
                }) {
                    Image(systemName: viewModel.state == .working || viewModel.state == .onBreak ? 
                          "pause.fill" : "play.fill")
                        .font(.system(size: 20))
                        .foregroundColor(viewModel.state == .working ? .blue : 
                                         viewModel.state == .onBreak ? .green : .primary)
                }
                .buttonStyle(BorderedButtonStyle(tint: viewModel.state == .working ? .blue : 
                                                viewModel.state == .onBreak ? .green : .gray))
                
                // Reset Button
                Button(action: {
                    viewModel.reset()
                }) {
                    Image(systemName: "arrow.counterclockwise")
                        .font(.system(size: 20))
                }
                .buttonStyle(BorderedButtonStyle())
                .disabled(viewModel.state == .notStarted)
            }
            .padding(.bottom, 10)
        }
        .navigationTitle(task.name)
        .onAppear {
            if let settings = task.pomodoroSettings {
                viewModel.setup(workDuration: Int(settings.workDuration), 
                                breakDuration: Int(settings.breakDuration),
                                longBreakDuration: Int(settings.longBreakDuration),
                               sessionsUntilLongBreak: settings.sessionsUntilLongBreak)
            }
        }
    }
    
    private func timeString(from timeInterval: TimeInterval) -> String {
        let minutes = Int(timeInterval) / 60
        let seconds = Int(timeInterval) % 60
        return String(format: "%02d:%02d", minutes, seconds)
    }
}

enum PomodoroState: Equatable {
    case notStarted
    case working
    case onBreak
    case paused
    case completed
}

class WatchPomodoroViewModel: ObservableObject {
    @Published var timeRemaining: TimeInterval = 0
    @Published var state: PomodoroState = .notStarted
    @Published var currentSession: Int = 1
    @Published var totalSessions: Int = 4
    
    private var workDuration: TimeInterval = 25 * 60
    private var breakDuration: TimeInterval = 5 * 60
    private var longBreakDuration: TimeInterval = 15 * 60
    private var sessionsUntilLongBreak: Int = 4
    
    private var timer: Timer?
    private var startTime: Date?
    private var pauseTime: TimeInterval = 0
    
    var progress: Double {
        if state == .notStarted {
            return 0.0
        }
        
        let totalDuration = state == .working ? workDuration : 
                            (currentSession % sessionsUntilLongBreak == 0 ? longBreakDuration : breakDuration)
        
        return 1.0 - (timeRemaining / totalDuration)
    }
    
    func setup(workDuration: Int, breakDuration: Int, longBreakDuration: Int, sessionsUntilLongBreak: Int) {
        self.workDuration = TimeInterval(workDuration * 60)
        self.breakDuration = TimeInterval(breakDuration * 60)
        self.longBreakDuration = TimeInterval(longBreakDuration * 60)
        self.sessionsUntilLongBreak = sessionsUntilLongBreak
        self.totalSessions = sessionsUntilLongBreak
        
        timeRemaining = self.workDuration
        state = .notStarted
        currentSession = 1
    }
    
    func start() {
        if state == .notStarted {
            state = .working
            timeRemaining = workDuration
        } else if state == .paused {
            state = pauseTime >= workDuration ? .onBreak : .working
        }
        
        startTime = Date()
        
        timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            self?.updateTimer()
        }
    }
    
    func pause() {
        timer?.invalidate()
        timer = nil
        state = .paused
        pauseTime = timeRemaining
    }
    
    func reset() {
        timer?.invalidate()
        timer = nil
        timeRemaining = workDuration
        state = .notStarted
        currentSession = 1
    }
    
    private func updateTimer() {
        guard let startTime = startTime else { return }
        
        let elapsedTime = Date().timeIntervalSince(startTime)
        let newTimeRemaining = max(pauseTime - elapsedTime, 0)
        
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            
            self.timeRemaining = newTimeRemaining
            
            if self.timeRemaining <= 0 {
                self.timer?.invalidate()
                self.timer = nil
                
                // Logic to switch between working and breaks
                if self.state == .working {
                    self.state = .onBreak
                    
                    // Check if it's time for a long break
                    if self.currentSession % self.sessionsUntilLongBreak == 0 {
                        self.timeRemaining = self.longBreakDuration
                    } else {
                        self.timeRemaining = self.breakDuration
                    }
                    
                    self.pauseTime = self.timeRemaining
                    self.start()
                } else if self.state == .onBreak {
                    // End of break, prepare for next work session
                    if self.currentSession >= self.totalSessions {
                        self.state = .completed
                    } else {
                        self.currentSession += 1
                        self.state = .working
                        self.timeRemaining = self.workDuration
                        self.pauseTime = self.timeRemaining
                        self.start()
                    }
                }
            }
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/WatchStatisticsView.swift/WatchStatisticsView.swift">
import SwiftUI
import Charts

struct WatchStatisticsView: View {
    @StateObject private var viewModel = StatisticsViewModel()
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                // Filtro periodo
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 8) {
                        ForEach(StatisticsViewModel.TimeRange.allCases, id: \.self) { range in
                            Button(action: {
                                withAnimation {
                                    viewModel.selectedTimeRange = range
                                }
                            }) {
                                Text(range.rawValue)
                                    .font(.system(.footnote, design: .rounded))
                                    .padding(.horizontal, 10)
                                    .padding(.vertical, 6)
                                    .background(
                                        RoundedRectangle(cornerRadius: 8)
                                            .fill(viewModel.selectedTimeRange == range ? 
                                                Color.blue.opacity(0.2) : Color.gray.opacity(0.1))
                                            .overlay(
                                                RoundedRectangle(cornerRadius: 8)
                                                    .strokeBorder(
                                                        viewModel.selectedTimeRange == range ? Color.blue : Color.clear, 
                                                        lineWidth: 1
                                                    )
                                            )
                                    )
                                    .foregroundColor(viewModel.selectedTimeRange == range ? .blue : .primary)
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                    }
                    .padding(.horizontal, 4)
                }
                
                // Grafico a torta per le categorie
                if viewModel.categoryStats.isEmpty {
                    Text("No data for this period")
                        .foregroundColor(.secondary)
                        .frame(height: 150)
                        .frame(maxWidth: .infinity)
                } else {
                    VStack(spacing: 8) {
                        Chart(viewModel.categoryStats) { stat in
                            SectorMark(
                                angle: .value("Hours", stat.hours),
                                innerRadius: .ratio(0.5),
                                angularInset: 1.5
                            )
                            .cornerRadius(3)
                            .foregroundStyle(Color(hex: stat.color))
                        }
                        .frame(height: 150)
                        
                        // Legenda
                        VStack(spacing: 6) {
                            ForEach(viewModel.categoryStats.prefix(3)) { stat in
                                HStack {
                                    Circle()
                                        .fill(Color(hex: stat.color))
                                        .frame(width: 10, height: 10)
                                    Text(stat.name)
                                        .font(.system(size: 12))
                                        .lineLimit(1)
                                    Spacer()
                                    Text(String(format: "%.1f hrs", stat.hours))
                                        .font(.system(size: 12))
                                        .foregroundColor(.secondary)
                                }
                            }
                            
                            if viewModel.categoryStats.count > 3 {
                                Text("+ \(viewModel.categoryStats.count - 3) more")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }
                
                Divider()
                
                // Grafico a barre per i task completati
                VStack(alignment: .leading, spacing: 8) {
                    Text("Task Completion")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                    
                    if viewModel.weeklyStats.isEmpty {
                        Text("No data for this week")
                            .foregroundColor(.secondary)
                            .frame(height: 100)
                            .frame(maxWidth: .infinity)
                    } else {
                        Chart(viewModel.weeklyStats) { stat in
                            BarMark(
                                x: .value("Day", stat.day),
                                y: .value("Tasks", stat.completedTasks)
                            )
                            .foregroundStyle(Color.pink.gradient)
                        }
                        .frame(height: 120)
                    }
                }
                
                Divider()
                
                // Streak
                VStack(spacing: 12) {
                    HStack {
                        VStack(alignment: .leading) {
                            Text("\(viewModel.currentStreak)")
                                .font(.system(size: 24, weight: .bold, design: .rounded))
                            Text("Current Streak")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        Spacer()
                        VStack(alignment: .trailing) {
                            Text("\(viewModel.bestStreak)")
                                .font(.system(size: 24, weight: .bold, design: .rounded))
                            Text("Best Streak")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
            .padding()
        }
        .onAppear {
            viewModel.refreshStats()
        }
        .refreshable {
            viewModel.refreshStats()
        }
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/WatchTaskDetailView.swift/WatchTaskDetailView.swift">
import SwiftUI

struct DetailRow: View {
    let icon: String
    let text: String
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .foregroundColor(.secondary)
                .frame(width: 16)
            
            Text(text)
                .font(.subheadline)
        }
    }
}

struct WatchTaskDetailView: View {
    let task: TodoTask
    let date: Date
    @State private var isShowingEditTask = false
    @State private var isShowingPomodoro = false
    @State private var refreshUI = false
    @Environment(\.dismiss) private var dismiss
    @StateObject private var taskManager = TaskManager.shared
    @State private var hapticEngine = WKHapticType.click
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 8) {
                // Header with task name and icon
                HStack {
                    ZStack {
                        Circle()
                            .fill(task.category != nil ? Color(hex: task.category!.color) : Color.gray)
                            .frame(width: 30, height: 30)
                        
                        Image(systemName: task.icon)
                            .foregroundColor(.white)
                            .font(.system(size: 14))
                    }
                    
                    Text(task.name)
                        .font(.headline)
                        .lineLimit(2)
                }
                .padding(.bottom, 4)
                
                // Task details
                if let category = task.category {
                    DetailRow(icon: "folder", text: category.name)
                }
                
                DetailRow(icon: "calendar", text: formattedDate(task.startTime))
                
                if task.hasDuration {
                    DetailRow(icon: "clock", text: "\(task.duration) min")
                }
                
                DetailRow(icon: "flag", text: task.priority.rawValue.capitalized)
                
                if let recurrence = task.recurrence {
                    DetailRow(icon: "repeat", text: recurrenceText(recurrence))
                }
                
                // Subtasks section with progress
                if !task.subtasks.isEmpty {
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            Text("Subtasks")
                                .font(.headline)
                            
                            Spacer()
                            
                            // Progress indicator
                            Text("\(completedSubtasksCount)/\(task.subtasks.count)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        .padding(.top, 8)
                        
                        // Progress bar
                        GeometryReader { geometry in
                            ZStack(alignment: .leading) {
                                Rectangle()
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(height: 4)
                                    .cornerRadius(2)
                                
                                Rectangle()
                                    .fill(Color.green)
                                    .frame(width: geometry.size.width * CGFloat(completedSubtasksCount) / CGFloat(task.subtasks.count), height: 4)
                                    .cornerRadius(2)
                            }
                        }
                        .frame(height: 4)
                        .padding(.bottom, 4)
                        
                        ForEach(task.subtasks) { subtask in
                            Button(action: {
                                taskManager.toggleSubtask(taskId: task.id, subtaskId: subtask.id, on: date)
                                WKInterfaceDevice.current().play(hapticEngine)
                                refreshUI.toggle()
                            }) {
                                HStack {
                                    Image(systemName: isSubtaskCompleted(subtask) ? "checkmark.circle.fill" : "circle")
                                        .foregroundColor(isSubtaskCompleted(subtask) ? .green : .gray)
                                        .font(.system(size: 18))
                                    
                                    Text(subtask.name)
                                        .font(.subheadline)
                                        .foregroundColor(.primary)
                                }
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .contentShape(Rectangle())
                            }
                            .buttonStyle(PlainButtonStyle())
                            .padding(.vertical, 6)
                        }
                    }
                }
                
                // Button actions
                Button(action: {
                    taskManager.toggleTaskCompletion(task.id, on: date)
                    WKInterfaceDevice.current().play(hapticEngine)
                }) {
                    Label(
                        isCompleted ? "Mark Incomplete" : "Mark Complete",
                        systemImage: isCompleted ? "circle" : "checkmark.circle"
                    )
                    .font(.system(size: 14))
                    .frame(maxWidth: .infinity)
                }
                .buttonStyle(.bordered)
                .padding(.top, 8)
                
                if task.pomodoroSettings != nil {
                    Button(action: {
                        isShowingPomodoro = true
                    }) {
                        Label("Start Pomodoro", systemImage: "timer")
                            .font(.system(size: 14))
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    .padding(.top, 4)
                }
                
                HStack {
                    Button(action: {
                        isShowingEditTask = true
                    }) {
                        Label("Edit", systemImage: "pencil")
                            .font(.system(size: 14))
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    
                    Button(role: .destructive, action: {
                        taskManager.removeTask(task)
                        dismiss()
                    }) {
                        Label("Delete", systemImage: "trash")
                            .font(.system(size: 14))
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                }
                .padding(.top, 4)
            }
            .padding()
        }
        .navigationTitle("Task Details")
        .sheet(isPresented: $isShowingEditTask) {
            WatchTaskFormView(
                viewModel: TaskFormViewModel(task: task),
                isPresented: $isShowingEditTask
            )
        }
        .sheet(isPresented: $isShowingPomodoro) {
            WatchPomodoroView(task: task)
        }
    }
    
    private var isCompleted: Bool {
        if let completion = task.completions[date.startOfDay] {
            return completion.isCompleted
        }
        return false
    }
    
    private func isSubtaskCompleted(_ subtask: Subtask) -> Bool {
        if let completion = task.completions[date.startOfDay] {
            return completion.completedSubtasks.contains(subtask.id)
        }
        return false
    }
    
    private var completedSubtasksCount: Int {
        if let completion = task.completions[date.startOfDay] {
            return task.subtasks.filter { completion.completedSubtasks.contains($0.id) }.count
        }
        return 0
    }
    
    private func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
    
    private func recurrenceText(_ recurrence: Recurrence) -> String {
        switch recurrence.type {
        case .daily:
            return "Daily"
        case .weekly(let days):
            if !days.isEmpty {
                let dayNames = days.sorted().map { dayOfWeekName($0) }.joined(separator: ", ")
                return "Weekly on \(dayNames)"
            }
            return "Weekly"
        case .monthly(let days):
            if !days.isEmpty {
                return "Monthly on day\(days.count > 1 ? "s" : "") \(days.sorted().map { "\($0)" }.joined(separator: ", "))"
            }
            return "Monthly"
        }
    }
    
    private func dayOfWeekName(_ day: Int) -> String {
        let days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        return days[day - 1]
    }
}
</file>

<file path="SnapTask Watch App Watch App/Views/WatchTaskFormView.swift/WatchTaskFormView.swift">
import SwiftUI

struct WatchTaskFormView: View {
    @ObservedObject var viewModel: TaskFormViewModel
    @Binding var isPresented: Bool
    @State private var showCategoryPicker = false
    @State private var showPriorityPicker = false
    @State private var showRecurrencePicker = false
    @State private var showDatePicker = false
    @State private var showDurationPicker = false
    @State private var showPomodoroPicker = false
    @State private var newSubtaskName = ""
    @State private var editingSubtaskId: UUID?
    @State private var hapticEngine = WKHapticType.click
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                // Form header
                Text(viewModel.editingTask == nil ? "New Task" : "Edit Task")
                    .font(.headline)
                    .padding(.bottom, 8)
                    .frame(maxWidth: .infinity, alignment: .center)

                // Task Name
                TextField("Task Name", text: $viewModel.name)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color.gray.opacity(0.15))
                    .cornerRadius(8)
                    .padding(.horizontal, -4)  // Compensate for the parent padding

                // Date selection
                formRowButton(icon: "calendar", label: "Date", value: formattedDate, action: { showDatePicker = true })
                
                // Duration
                formRowButton(icon: "clock", label: "Duration", value: viewModel.hasDuration ? "\(Int(viewModel.duration / 60.0)) min" : "Not set", action: { showDurationPicker = true })
                
                // Category
                formRowButton(icon: "folder", label: "Category", value: viewModel.category?.name ?? "Not set", color: viewModel.category != nil ? Color(hex: viewModel.category!.color) : nil, action: { showCategoryPicker = true })
                
                // Priority
                formRowButton(icon: "flag", label: "Priority", value: viewModel.priority.rawValue.capitalized, action: { showPriorityPicker = true })
                
                // Recurrence
                formRowButton(icon: "repeat", label: "Recurrence", value: viewModel.isRecurring ? recurrenceTypeText : "Not set", action: { showRecurrencePicker = true })
                
                // Pomodoro Settings
                formRowButton(icon: "timer", label: "Pomodoro", value: viewModel.pomodoroSettings != nil ? "\(Int(viewModel.pomodoroSettings!.workDuration / 60.0))m work" : "Not set", action: { showPomodoroPicker = true })
                
                // Subtasks section
                VStack(alignment: .leading, spacing: 8) {
                    Text("Subtasks")
                        .font(.headline)
                        .padding(.top, 8)
                    
                    // Subtask input field
                    HStack {
                        TextField("Add subtask", text: $newSubtaskName)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 8)
                            .background(Color.gray.opacity(0.15))
                            .cornerRadius(8)
                            .submitLabel(.done)
                            .onSubmit {
                                addSubtask()
                            }
                    }
                    
                    // Existing subtasks
                    if !viewModel.subtasks.isEmpty {
                        ForEach(viewModel.subtasks) { subtask in
                            HStack {
                                if editingSubtaskId == subtask.id {
                                    TextField("Edit subtask", text: Binding(
                                        get: { subtask.name },
                                        set: { newName in
                                            if let index = viewModel.subtasks.firstIndex(where: { $0.id == subtask.id }) {
                                                viewModel.subtasks[index].name = newName
                                            }
                                        }
                                    ))
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 8)
                                    .background(Color.gray.opacity(0.15))
                                    .cornerRadius(8)
                                    .submitLabel(.done)
                                    .onSubmit {
                                        editingSubtaskId = nil
                                        WKInterfaceDevice.current().play(hapticEngine)
                                    }
                                } else {
                                    Text(subtask.name)
                                        .font(.subheadline)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                        .contentShape(Rectangle())
                                        .onTapGesture {
                                            editingSubtaskId = subtask.id
                                            WKInterfaceDevice.current().play(hapticEngine)
                                        }
                                    
                                    Button(action: {
                                        deleteSubtask(subtask)
                                        WKInterfaceDevice.current().play(hapticEngine)
                                    }) {
                                        Image(systemName: "xmark.circle.fill")
                                            .foregroundColor(.red)
                                            .font(.system(size: 16))
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
                
                Spacer(minLength: 16)

                // Save button
                Button(action: {
                    let _ = viewModel.saveTask()
                    isPresented = false
                }) {
                    Text("Save")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                }
                .buttonStyle(.borderedProminent)
                .padding(.top, 16)
                .disabled(viewModel.name.isEmpty)
            }
            .padding(.horizontal)
        }
        .navigationTitle(viewModel.editingTask == nil ? "New Task" : "Edit Task")
        .sheet(isPresented: $showCategoryPicker) {
            WatchCategoryPicker(selectedCategory: $viewModel.category)
        }
        .sheet(isPresented: $showPriorityPicker) {
            WatchPriorityPicker(selectedPriority: $viewModel.priority)
        }
        .sheet(isPresented: $showRecurrencePicker) {
            WatchRecurrencePicker(
                isRecurring: $viewModel.isRecurring,
                recurrenceType: $viewModel.recurrenceType,
                selectedDaysOfWeek: $viewModel.selectedDaysOfWeek,
                selectedDaysOfMonth: $viewModel.selectedDaysOfMonth
            )
        }
        .sheet(isPresented: $showDatePicker) {
            VStack {
                Text("Select Date & Time")
                    .font(.headline)
                    .padding(.top)

                DatePicker("", selection: $viewModel.startTime, displayedComponents: [.date, .hourAndMinute])
                    .datePickerStyle(.wheel)
                    .labelsHidden()
                    .padding(.horizontal)
                    .frame(maxHeight: 160)

                Button("Done") {
                    showDatePicker = false
                }
                .padding(.top)
                .padding(.bottom)
            }
            .padding()
            .presentationDetents([.height(230), .medium])
        }
        .sheet(isPresented: $showDurationPicker) {
            WatchDurationPicker(
                hasDuration: $viewModel.hasDuration,
                duration: $viewModel.duration
            )
        }
        .sheet(isPresented: $showPomodoroPicker) {
            WatchPomodoroSettingsPicker(viewModel: viewModel)
        }
    }
    
    private func addSubtask() {
        if !newSubtaskName.isEmpty {
            viewModel.addSubtask(newSubtaskName)
            newSubtaskName = ""
            WKInterfaceDevice.current().play(hapticEngine)
        }
    }
    
    private func deleteSubtask(_ subtask: Subtask) {
        if let index = viewModel.subtasks.firstIndex(where: { $0.id == subtask.id }) {
            viewModel.subtasks.remove(at: index)
        }
    }
    
    @ViewBuilder
    private func formRowButton(icon: String, label: String, value: String, color: Color? = nil, action: @escaping () -> Void) -> some View {
        Button(action: action) {
            HStack {
                Image(systemName: icon)
                    .font(.body)
                    .frame(width: 24, alignment: .center)
                    .foregroundColor(color ?? .secondary)
                
                Text(label)
                    .font(.body)
                    .foregroundColor(.primary)
                
                Spacer()
                
                if let categoryColor = color, label == "Category" {
                     Circle()
                        .fill(categoryColor)
                        .frame(width: 10, height: 10)
                        .padding(.trailing, 4)
                }

                Text(value)
                    .font(.body)
                    .foregroundColor(.secondary)
                    .lineLimit(1)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(Color.gray.opacity(0.15))
            .cornerRadius(8)
        }
        .buttonStyle(PlainButtonStyle())
    }

    private var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: viewModel.startTime)
    }
    
    private var recurrenceTypeText: String {
        if !viewModel.isRecurring { return "Not set" }
        switch viewModel.recurrenceType {
        case "daily": return "Daily"
        case "weekly":
            return viewModel.selectedDaysOfWeek.isEmpty ? "Weekly" : "Weekly (\(viewModel.selectedDaysOfWeek.count) day\(viewModel.selectedDaysOfWeek.count == 1 ? "" : "s"))"
        case "monthly":
            return viewModel.selectedDaysOfMonth.isEmpty ? "Monthly" : "Monthly (\(viewModel.selectedDaysOfMonth.count) day\(viewModel.selectedDaysOfMonth.count == 1 ? "" : "s"))"
        default: return "Custom"
        }
    }
}

struct WatchCategoryPicker: View {
    @Binding var selectedCategory: Category?
    @Environment(\.dismiss) private var dismiss
    @StateObject private var viewModel = SettingsViewModel()
    
    var body: some View {
        ScrollView {
            VStack(spacing: 8) {
                Text("Select Category")
                    .font(.headline)
                    .padding(.vertical, 8)
                
                ForEach(viewModel.categories) { category in
                    Button(action: {
                        selectedCategory = category
                        dismiss()
                    }) {
                        HStack {
                            Circle()
                                .fill(Color(hex: category.color))
                                .frame(width: 16, height: 16)
                            
                            Text(category.name)
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            if selectedCategory?.id == category.id {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.gray.opacity(0.1))
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                
                Button(action: {
                    selectedCategory = nil
                    dismiss()
                }) {
                    HStack {
                        Text("None")
                            .foregroundColor(.primary)
                        
                        Spacer()
                        
                        if selectedCategory == nil {
                            Image(systemName: "checkmark")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding(.vertical, 8)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
            .padding()
        }
        .onAppear {
            viewModel.loadCategories() // Force load categories when view appears
        }
    }
}

struct WatchPriorityPicker: View {
    @Binding var selectedPriority: Priority
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        ScrollView {
            VStack(spacing: 8) {
                Text("Select Priority")
                    .font(.headline)
                    .padding(.vertical, 8)
                
                ForEach(Priority.allCases, id: \.self) { priority in
                    Button(action: {
                        selectedPriority = priority
                        dismiss()
                    }) {
                        HStack {
                            Image(systemName: priority.icon)
                                .foregroundColor(Color(hex: priority.color))
                            
                            Text(priority.rawValue.capitalized)
                                .foregroundColor(.primary)
                            
                            Spacer()
                            
                            if selectedPriority == priority {
                                Image(systemName: "checkmark")
                                    .foregroundColor(.blue)
                            }
                        }
                        .padding(.vertical, 8)
                        .padding(.horizontal, 12)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.gray.opacity(0.1))
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding()
        }
    }
}

struct WatchRecurrencePicker: View {
    @Binding var isRecurring: Bool
    @Binding var recurrenceType: String
    @Binding var selectedDaysOfWeek: Set<Int>
    @Binding var selectedDaysOfMonth: Set<Int>
    @Environment(\.dismiss) private var dismiss
    @State private var selectionStep = 0
    
    var body: some View {
        VStack {
            if selectionStep == 0 {
                // Recurring toggle
                Toggle("Recurring", isOn: $isRecurring)
                    .padding()
                
                // Recurrence type picker
                if isRecurring {
                    Picker("Recurrence", selection: $recurrenceType) {
                        Text("Daily").tag("daily")
                        Text("Weekly").tag("weekly")
                        Text("Monthly").tag("monthly")
                    }
                    .pickerStyle(WheelPickerStyle())
                    .frame(height: 100)
                    
                    Button("Next") {
                        if recurrenceType == "weekly" || recurrenceType == "monthly" {
                            selectionStep = 1
                        } else {
                            dismiss()
                        }
                    }
                    .buttonStyle(.bordered)
                    .padding()
                } else {
                    Button("Done") {
                        dismiss()
                    }
                    .buttonStyle(.bordered)
                    .padding()
                }
            } else if selectionStep == 1 {
                if recurrenceType == "weekly" {
                    weekdayPicker
                } else if recurrenceType == "monthly" {
                    monthDayPicker
                }
                
                Button("Done") {
                    dismiss()
                }
                .buttonStyle(.bordered)
                .padding()
            }
        }
    }
    
    private var weekdayPicker: some View {
        VStack(spacing: 12) {
            Text("Select Days of Week")
                .font(.headline)
            
            ForEach(1...7, id: \.self) { day in
                Button(action: {
                    if selectedDaysOfWeek.contains(day) {
                        selectedDaysOfWeek.remove(day)
                    } else {
                        selectedDaysOfWeek.insert(day)
                    }
                }) {
                    HStack {
                        Text(weekdayName(day))
                            .foregroundColor(.primary)
                        
                        Spacer()
                        
                        if selectedDaysOfWeek.contains(day) {
                            Image(systemName: "checkmark")
                                .foregroundColor(.blue)
                        }
                    }
                    .padding(.vertical, 6)
                    .padding(.horizontal, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 8)
                            .fill(Color.gray.opacity(0.1))
                    )
                }
                .buttonStyle(PlainButtonStyle())
            }
        }
        .padding()
    }
    
    private var monthDayPicker: some View {
        VStack(spacing: 12) {
            Text("Select Days of Month")
                .font(.headline)
            
            ScrollView {
                LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7), spacing: 8) {
                    ForEach(1...31, id: \.self) { day in
                        Button(action: {
                            if selectedDaysOfMonth.contains(day) {
                                selectedDaysOfMonth.remove(day)
                            } else {
                                selectedDaysOfMonth.insert(day)
                            }
                        }) {
                            Text("\(day)")
                                .frame(width: 24, height: 24)
                                .foregroundColor(selectedDaysOfMonth.contains(day) ? .white : .primary)
                                .background(
                                    Circle()
                                        .fill(selectedDaysOfMonth.contains(day) ? Color.blue : Color.clear)
                                )
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
            }
        }
        .padding()
    }
    
    private func weekdayName(_ day: Int) -> String {
        let days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
        return days[day - 1]
    }
}

struct WatchDurationPicker: View {
    @Binding var hasDuration: Bool
    @Binding var duration: TimeInterval
    @Environment(\.dismiss) private var dismiss
    
    // Durations in minutes, spaced out for better picking
    private let durations = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 75, 90, 105, 120, 150, 180]
    
    var body: some View {
        NavigationView { // Use NavigationView for a title and cleaner Done button placement
            VStack(spacing: 15) {
                Toggle("Enable Duration", isOn: $hasDuration)
                    .padding(.horizontal)
                
                if hasDuration {
                    Picker("Select Duration", selection: Binding(
                        get: { Int(duration / 60.0) },
                        set: { duration = TimeInterval($0) * 60.0 }
                    )) {
                        ForEach(durations, id: \.self) { mins in
                            Text("\(mins) min").tag(mins)
                        }
                    }
                    .labelsHidden() // Hide the "Select Duration" label from picker, title is enough
                    .pickerStyle(WheelPickerStyle())
                    .frame(maxWidth: .infinity) // Allow picker to use available width
                    .padding(.horizontal)
                    
                    Text("Selected: \(Int(duration / 60.0)) minutes")
                        .font(.caption)
                        .foregroundColor(.secondary)
                } else {
                    Spacer()
                    Text("Duration is disabled.")
                        .foregroundColor(.secondary)
                    Spacer()
                }
            }
            .padding(.vertical)
            .navigationTitle("Task Duration")
            .toolbar {
                ToolbarItem(placement: .cancellationAction) { // Standard placement for Done
                    Button("Done") { dismiss() }
                }
            }
        }
    }
}

struct WatchPomodoroSettingsPicker: View {
    @ObservedObject var viewModel: TaskFormViewModel
    @Environment(\.dismiss) private var dismiss
    @State private var hasPomodoro = false
    @State private var workDuration = 25
    @State private var breakDuration = 5
    @State private var longBreakDuration = 15
    @State private var sessionsUntilLongBreak = 4
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                Toggle("Use Pomodoro", isOn: $hasPomodoro)
                    .onChange(of: hasPomodoro) { _, newValue in
                        if newValue {
                            updateSettings()
                        } else {
                            viewModel.removePomodoroSettings()
                        }
                    }
                
                if hasPomodoro {
                    Group {
                        HStack {
                            Text("Work Duration")
                            Spacer()
                            Text("\(workDuration) min")
                        }
                        
                        Slider(value: Binding(
                            get: { Double(workDuration) },
                            set: { workDuration = Int($0) }
                        ), in: 5...60, step: 5)
                        
                        HStack {
                            Text("Break Duration")
                            Spacer()
                            Text("\(breakDuration) min")
                        }
                        
                        Slider(value: Binding(
                            get: { Double(breakDuration) },
                            set: { breakDuration = Int($0) }
                        ), in: 1...30, step: 1)
                        
                        HStack {
                            Text("Long Break")
                            Spacer()
                            Text("\(longBreakDuration) min")
                        }
                        
                        Slider(value: Binding(
                            get: { Double(longBreakDuration) },
                            set: { longBreakDuration = Int($0) }
                        ), in: 5...45, step: 5)
                        
                        HStack {
                            Text("Sessions")
                            Spacer()
                            Text("\(sessionsUntilLongBreak)")
                        }
                        
                        Slider(value: Binding(
                            get: { Double(sessionsUntilLongBreak) },
                            set: { sessionsUntilLongBreak = Int($0) }
                        ), in: 2...6, step: 1)
                    }
                    .onChange(of: workDuration) { _, _ in updateSettings() }
                    .onChange(of: breakDuration) { _, _ in updateSettings() }
                    .onChange(of: longBreakDuration) { _, _ in updateSettings() }
                    .onChange(of: sessionsUntilLongBreak) { _, _ in updateSettings() }
                }
                
                Button("Done") {
                    dismiss()
                }
                .buttonStyle(.bordered)
                .padding(.top, 8)
            }
            .padding()
        }
        .onAppear {
            if let settings = viewModel.pomodoroSettings {
                hasPomodoro = true
                workDuration = Int(settings.workDuration / 60.0)
                breakDuration = Int(settings.breakDuration / 60.0)
                longBreakDuration = Int(settings.longBreakDuration / 60.0)
                sessionsUntilLongBreak = settings.sessionsUntilLongBreak
            } else {
                hasPomodoro = false
            }
        }
    }
    
    private func updateSettings() {
        viewModel.configurePomodoroSettings(
            workDuration: workDuration,
            breakDuration: breakDuration,
            longBreakDuration: longBreakDuration,
            sessionsUntilLongBreak: sessionsUntilLongBreak
        )
    }
}
</file>

<file path="SnapTask Watch App Watch App/WatchConnectivityManager.swift/WatchConnectivityManager.swift">
import Foundation
import WatchConnectivity

class WatchConnectivityManager: NSObject, ObservableObject {
    static let shared = WatchConnectivityManager()
    
    private let session = WCSession.default
    @Published var isReachable = false
    @Published var receivedTasks: [TodoTask] = []
    
    private override init() {
        super.init()
        
        if WCSession.isSupported() {
            session.delegate = self
            session.activate()
        }
    }
    
    func sendTasksToiOS(tasks: [TodoTask]) {
        guard session.activationState == .activated else {
            print("WCSession not activated")
            return
        }
        
        do {
            let data = try JSONEncoder().encode(tasks)
            session.sendMessageData(data, replyHandler: nil) { error in
                print("Error sending tasks to iOS: \(error.localizedDescription)")
            }
        } catch {
            print("Error encoding tasks: \(error.localizedDescription)")
        }
    }
    
    func sendCompletionUpdate(taskId: UUID, isCompleted: Bool, date: Date) {
        guard session.activationState == .activated else {
            print("WCSession not activated")
            return
        }
        
        let message: [String: Any] = [
            "type": "taskCompletion",
            "taskId": taskId.uuidString,
            "isCompleted": isCompleted,
            "date": date.timeIntervalSince1970
        ]
        
        session.sendMessage(message, replyHandler: nil) { error in
            print("Error sending completion update: \(error.localizedDescription)")
        }
    }
    
    func requestTasksFromiOS() {
        guard session.activationState == .activated else {
            print("WCSession not activated")
            return
        }
        
        let message = ["type": "requestTasks"]
        session.sendMessage(message, replyHandler: { [weak self] reply in
            if let tasksData = reply["tasks"] as? Data {
                do {
                    let tasks = try JSONDecoder().decode([TodoTask].self, from: tasksData)
                    DispatchQueue.main.async {
                        self?.receivedTasks = tasks
                        // Update the TaskManager with the new tasks
                        TaskManager.shared.updateAllTasks(tasks)
                    }
                } catch {
                    print("Error decoding received tasks: \(error.localizedDescription)")
                }
            }
        }) { error in
            print("Error requesting tasks: \(error.localizedDescription)")
        }
    }
}

extension WatchConnectivityManager: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        DispatchQueue.main.async {
            self.isReachable = session.isReachable
        }
        
        if activationState == .activated {
            // Request tasks as soon as the session is activated
            DispatchQueue.main.async {
                self.requestTasksFromiOS()
            }
        }
    }
    
    func session(_ session: WCSession, didReceiveMessageData messageData: Data) {
        do {
            let receivedTasks = try JSONDecoder().decode([TodoTask].self, from: messageData)
            DispatchQueue.main.async {
                TaskManager.shared.updateAllTasks(receivedTasks)
            }
        } catch {
            print("Error decoding received tasks: \(error.localizedDescription)")
        }
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        if let type = message["type"] as? String {
            switch type {
            case "taskUpdate":
                if let taskData = message["task"] as? Data {
                    do {
                        let task = try JSONDecoder().decode(TodoTask.self, from: taskData)
                        DispatchQueue.main.async {
                            TaskManager.shared.updateTask(task)
                        }
                    } catch {
                        print("Error decoding task: \(error.localizedDescription)")
                    }
                }
            default:
                break
            }
        }
    }
    
    #if os(iOS)
    func sessionDidBecomeInactive(_ session: WCSession) {}
    func sessionDidDeactivate(_ session: WCSession) {
        session.activate()
    }
    #endif
}
</file>

<file path="SnapTask Watch App Watch AppTests/SnapTask_Watch_App_Watch_AppTests.swift/SnapTask_Watch_App_Watch_AppTests.swift">
//
//  SnapTask_Watch_App_Watch_AppTests.swift
//  SnapTask Watch App Watch AppTests
//
//  Created by Giovanni Amadei on 14/05/25.
//

import Testing
@testable import SnapTask_Watch_App_Watch_App

struct SnapTask_Watch_App_Watch_AppTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
</file>

<file path="SnapTask Watch App Watch AppUITests/SnapTask_Watch_App_Watch_AppUITests.swift/SnapTask_Watch_App_Watch_AppUITests.swift">
//
//  SnapTask_Watch_App_Watch_AppUITests.swift
//  SnapTask Watch App Watch AppUITests
//
//  Created by Giovanni Amadei on 14/05/25.
//

import XCTest

final class SnapTask_Watch_App_Watch_AppUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
</file>

<file path="SnapTask Watch App Watch AppUITests/SnapTask_Watch_App_Watch_AppUITestsLaunchTests.swift/SnapTask_Watch_App_Watch_AppUITestsLaunchTests.swift">
//
//  SnapTask_Watch_App_Watch_AppUITestsLaunchTests.swift
//  SnapTask Watch App Watch AppUITests
//
//  Created by Giovanni Amadei on 14/05/25.
//

import XCTest

final class SnapTask_Watch_App_Watch_AppUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
</file>

<file path="SnapTask.xcodeproj/project.pbxproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		FC6909862DD49BE00006E601 /* SnapTask Watch App Watch App.app in Embed Watch Content */ = {isa = PBXBuildFile; fileRef = FC6909662DD49BDF0006E601 /* SnapTask Watch App Watch App.app */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
		FC690B782DD4A0DA0006E601 /* QuoteService.swift in Sources */ = {isa = PBXBuildFile; fileRef = FC690B772DD4A0DA0006E601 /* QuoteService.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		ACCAD3F72D37D10600A26002 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = ACCAD3E52D37D10500A26002;
			remoteInfo = SnapTask;
		};
		ACCAD4012D37D10600A26002 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = ACCAD3E52D37D10500A26002;
			remoteInfo = SnapTask;
		};
		FC6909732DD49BE00006E601 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = FC6909652DD49BDF0006E601;
			remoteInfo = "SnapTask Watch App Watch App";
		};
		FC69097D2DD49BE00006E601 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = FC6909652DD49BDF0006E601;
			remoteInfo = "SnapTask Watch App Watch App";
		};
		FC6909842DD49BE00006E601 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = FC6909652DD49BDF0006E601;
			remoteInfo = "SnapTask Watch App Watch App";
		};
		FCB4D6252DD78BE3004F8476 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = FCB4D6112DD78BE3004F8476;
			remoteInfo = SnapTaskMac;
		};
		FCB4D62F2DD78BE3004F8476 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = ACCAD3DE2D37D10500A26002 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = FCB4D6112DD78BE3004F8476;
			remoteInfo = SnapTaskMac;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		FC6909872DD49BE00006E601 /* Embed Watch Content */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "$(CONTENTS_FOLDER_PATH)/Watch";
			dstSubfolderSpec = 16;
			files = (
				FC6909862DD49BE00006E601 /* SnapTask Watch App Watch App.app in Embed Watch Content */,
			);
			name = "Embed Watch Content";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		ACCAD3E62D37D10500A26002 /* SnapTask.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = SnapTask.app; sourceTree = BUILT_PRODUCTS_DIR; };
		ACCAD3F62D37D10600A26002 /* SnapTaskTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = SnapTaskTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		ACCAD4002D37D10600A26002 /* SnapTaskUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = SnapTaskUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		FC6909662DD49BDF0006E601 /* SnapTask Watch App Watch App.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "SnapTask Watch App Watch App.app"; sourceTree = BUILT_PRODUCTS_DIR; };
		FC6909722DD49BE00006E601 /* SnapTask Watch App Watch AppTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "SnapTask Watch App Watch AppTests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
		FC69097C2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "SnapTask Watch App Watch AppUITests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
		FC690B772DD4A0DA0006E601 /* QuoteService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = QuoteService.swift; path = SnapTask/Services/QuoteService.swift; sourceTree = "<group>"; };
		FCB4D6122DD78BE3004F8476 /* SnapTaskMac.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = SnapTaskMac.app; sourceTree = BUILT_PRODUCTS_DIR; };
		FCB4D6242DD78BE3004F8476 /* SnapTaskMacTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = SnapTaskMacTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		FCB4D62E2DD78BE3004F8476 /* SnapTaskMacUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = SnapTaskMacUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedBuildFileExceptionSet section */
		FC36957B2DDB490E00117EB0 /* Exceptions for "SnapTask Watch App Watch App" folder in "SnapTask Watch App Watch App" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				Info.plist,
			);
			target = FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */;
		};
		FCB4D6682DD78DE5004F8476 /* Exceptions for "SnapTask" folder in "SnapTaskMac" target */ = {
			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
			membershipExceptions = (
				Core/Timer/TimerViewModel.swift,
				"Extensions/Color+Extensions.swift",
				"Extensions/Color+Hex.swift",
				"Extensions/TimeInterval+Formatting.swift",
				"Extensions/View+CornerRadius.swift",
				Extensions/WatchConnectivityManager.swift,
				Models/FocusMode.swift,
				Models/FocusSettings.swift,
				Utils/HapticManager.swift,
				ViewModels/BiohackingViewModel.swift,
				ViewModels/FocusViewModel.swift,
				ViewModels/PomodoroViewModel.swift,
				ViewModels/QuoteViewModel.swift,
				ViewModels/SettingsViewModel.swift,
				ViewModels/StatsViewModel.swift,
				ViewModels/TaskFormViewModel.swift,
				ViewModels/TaskViewModel.swift,
				ViewModels/TimelineViewModel.swift,
			);
			target = FCB4D6112DD78BE3004F8476 /* SnapTaskMac */;
		};
/* End PBXFileSystemSynchronizedBuildFileExceptionSet section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		ACCAD3E82D37D10500A26002 /* SnapTask */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				FCB4D6682DD78DE5004F8476 /* Exceptions for "SnapTask" folder in "SnapTaskMac" target */,
			);
			path = SnapTask;
			sourceTree = "<group>";
		};
		ACCAD3F92D37D10600A26002 /* SnapTaskTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = SnapTaskTests;
			sourceTree = "<group>";
		};
		ACCAD4032D37D10600A26002 /* SnapTaskUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = SnapTaskUITests;
			sourceTree = "<group>";
		};
		FC6909672DD49BDF0006E601 /* SnapTask Watch App Watch App */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			exceptions = (
				FC36957B2DDB490E00117EB0 /* Exceptions for "SnapTask Watch App Watch App" folder in "SnapTask Watch App Watch App" target */,
			);
			path = "SnapTask Watch App Watch App";
			sourceTree = "<group>";
		};
		FC6909752DD49BE00006E601 /* SnapTask Watch App Watch AppTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "SnapTask Watch App Watch AppTests";
			sourceTree = "<group>";
		};
		FC69097F2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = "SnapTask Watch App Watch AppUITests";
			sourceTree = "<group>";
		};
		FCB4D6132DD78BE3004F8476 /* SnapTaskMac */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = SnapTaskMac;
			sourceTree = "<group>";
		};
		FCB4D6272DD78BE3004F8476 /* SnapTaskMacTests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = SnapTaskMacTests;
			sourceTree = "<group>";
		};
		FCB4D6312DD78BE3004F8476 /* SnapTaskMacUITests */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = SnapTaskMacUITests;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		ACCAD3E32D37D10500A26002 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3F32D37D10600A26002 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3FD2D37D10600A26002 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909632DD49BDF0006E601 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC69096F2DD49BE00006E601 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909792DD49BE00006E601 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D60F2DD78BE3004F8476 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D6212DD78BE3004F8476 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D62B2DD78BE3004F8476 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		ACCAD3DD2D37D10500A26002 = {
			isa = PBXGroup;
			children = (
				ACCAD3E82D37D10500A26002 /* SnapTask */,
				ACCAD3F92D37D10600A26002 /* SnapTaskTests */,
				ACCAD4032D37D10600A26002 /* SnapTaskUITests */,
				FC6909672DD49BDF0006E601 /* SnapTask Watch App Watch App */,
				FC6909752DD49BE00006E601 /* SnapTask Watch App Watch AppTests */,
				FC69097F2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests */,
				FCB4D6132DD78BE3004F8476 /* SnapTaskMac */,
				FCB4D6272DD78BE3004F8476 /* SnapTaskMacTests */,
				FCB4D6312DD78BE3004F8476 /* SnapTaskMacUITests */,
				ACCAD3E72D37D10500A26002 /* Products */,
				FC690D292DD4A4300006E601 /* Recovered References */,
			);
			sourceTree = "<group>";
		};
		ACCAD3E72D37D10500A26002 /* Products */ = {
			isa = PBXGroup;
			children = (
				ACCAD3E62D37D10500A26002 /* SnapTask.app */,
				ACCAD3F62D37D10600A26002 /* SnapTaskTests.xctest */,
				ACCAD4002D37D10600A26002 /* SnapTaskUITests.xctest */,
				FC6909662DD49BDF0006E601 /* SnapTask Watch App Watch App.app */,
				FC6909722DD49BE00006E601 /* SnapTask Watch App Watch AppTests.xctest */,
				FC69097C2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests.xctest */,
				FCB4D6122DD78BE3004F8476 /* SnapTaskMac.app */,
				FCB4D6242DD78BE3004F8476 /* SnapTaskMacTests.xctest */,
				FCB4D62E2DD78BE3004F8476 /* SnapTaskMacUITests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		FC690D292DD4A4300006E601 /* Recovered References */ = {
			isa = PBXGroup;
			children = (
				FC690B772DD4A0DA0006E601 /* QuoteService.swift */,
			);
			name = "Recovered References";
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		ACCAD3E52D37D10500A26002 /* SnapTask */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = ACCAD40A2D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTask" */;
			buildPhases = (
				ACCAD3E22D37D10500A26002 /* Sources */,
				ACCAD3E32D37D10500A26002 /* Frameworks */,
				ACCAD3E42D37D10500A26002 /* Resources */,
				FC6909872DD49BE00006E601 /* Embed Watch Content */,
			);
			buildRules = (
			);
			dependencies = (
				FC6909852DD49BE00006E601 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				ACCAD3E82D37D10500A26002 /* SnapTask */,
			);
			name = SnapTask;
			packageProductDependencies = (
			);
			productName = SnapTask;
			productReference = ACCAD3E62D37D10500A26002 /* SnapTask.app */;
			productType = "com.apple.product-type.application";
		};
		ACCAD3F52D37D10600A26002 /* SnapTaskTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = ACCAD40D2D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTaskTests" */;
			buildPhases = (
				ACCAD3F22D37D10600A26002 /* Sources */,
				ACCAD3F32D37D10600A26002 /* Frameworks */,
				ACCAD3F42D37D10600A26002 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				ACCAD3F82D37D10600A26002 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				ACCAD3F92D37D10600A26002 /* SnapTaskTests */,
			);
			name = SnapTaskTests;
			packageProductDependencies = (
			);
			productName = SnapTaskTests;
			productReference = ACCAD3F62D37D10600A26002 /* SnapTaskTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		ACCAD3FF2D37D10600A26002 /* SnapTaskUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = ACCAD4102D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTaskUITests" */;
			buildPhases = (
				ACCAD3FC2D37D10600A26002 /* Sources */,
				ACCAD3FD2D37D10600A26002 /* Frameworks */,
				ACCAD3FE2D37D10600A26002 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				ACCAD4022D37D10600A26002 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				ACCAD4032D37D10600A26002 /* SnapTaskUITests */,
			);
			name = SnapTaskUITests;
			packageProductDependencies = (
			);
			productName = SnapTaskUITests;
			productReference = ACCAD4002D37D10600A26002 /* SnapTaskUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
		FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FC69098E2DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch App" */;
			buildPhases = (
				FC6909622DD49BDF0006E601 /* Sources */,
				FC6909632DD49BDF0006E601 /* Frameworks */,
				FC6909642DD49BDF0006E601 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				FC6909672DD49BDF0006E601 /* SnapTask Watch App Watch App */,
			);
			name = "SnapTask Watch App Watch App";
			packageProductDependencies = (
			);
			productName = "SnapTask Watch App Watch App";
			productReference = FC6909662DD49BDF0006E601 /* SnapTask Watch App Watch App.app */;
			productType = "com.apple.product-type.application";
		};
		FC6909712DD49BE00006E601 /* SnapTask Watch App Watch AppTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FC69098F2DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch AppTests" */;
			buildPhases = (
				FC69096E2DD49BE00006E601 /* Sources */,
				FC69096F2DD49BE00006E601 /* Frameworks */,
				FC6909702DD49BE00006E601 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				FC6909742DD49BE00006E601 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				FC6909752DD49BE00006E601 /* SnapTask Watch App Watch AppTests */,
			);
			name = "SnapTask Watch App Watch AppTests";
			packageProductDependencies = (
			);
			productName = "SnapTask Watch App Watch AppTests";
			productReference = FC6909722DD49BE00006E601 /* SnapTask Watch App Watch AppTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		FC69097B2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FC6909902DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch AppUITests" */;
			buildPhases = (
				FC6909782DD49BE00006E601 /* Sources */,
				FC6909792DD49BE00006E601 /* Frameworks */,
				FC69097A2DD49BE00006E601 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				FC69097E2DD49BE00006E601 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				FC69097F2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests */,
			);
			name = "SnapTask Watch App Watch AppUITests";
			packageProductDependencies = (
			);
			productName = "SnapTask Watch App Watch AppUITests";
			productReference = FC69097C2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
		FCB4D6112DD78BE3004F8476 /* SnapTaskMac */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FCB4D6362DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMac" */;
			buildPhases = (
				FCB4D60E2DD78BE3004F8476 /* Sources */,
				FCB4D60F2DD78BE3004F8476 /* Frameworks */,
				FCB4D6102DD78BE3004F8476 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				FCB4D6132DD78BE3004F8476 /* SnapTaskMac */,
			);
			name = SnapTaskMac;
			packageProductDependencies = (
			);
			productName = SnapTaskMac;
			productReference = FCB4D6122DD78BE3004F8476 /* SnapTaskMac.app */;
			productType = "com.apple.product-type.application";
		};
		FCB4D6232DD78BE3004F8476 /* SnapTaskMacTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FCB4D6392DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMacTests" */;
			buildPhases = (
				FCB4D6202DD78BE3004F8476 /* Sources */,
				FCB4D6212DD78BE3004F8476 /* Frameworks */,
				FCB4D6222DD78BE3004F8476 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				FCB4D6262DD78BE3004F8476 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				FCB4D6272DD78BE3004F8476 /* SnapTaskMacTests */,
			);
			name = SnapTaskMacTests;
			packageProductDependencies = (
			);
			productName = SnapTaskMacTests;
			productReference = FCB4D6242DD78BE3004F8476 /* SnapTaskMacTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		FCB4D62D2DD78BE3004F8476 /* SnapTaskMacUITests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = FCB4D63C2DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMacUITests" */;
			buildPhases = (
				FCB4D62A2DD78BE3004F8476 /* Sources */,
				FCB4D62B2DD78BE3004F8476 /* Frameworks */,
				FCB4D62C2DD78BE3004F8476 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				FCB4D6302DD78BE3004F8476 /* PBXTargetDependency */,
			);
			fileSystemSynchronizedGroups = (
				FCB4D6312DD78BE3004F8476 /* SnapTaskMacUITests */,
			);
			name = SnapTaskMacUITests;
			packageProductDependencies = (
			);
			productName = SnapTaskMacUITests;
			productReference = FCB4D62E2DD78BE3004F8476 /* SnapTaskMacUITests.xctest */;
			productType = "com.apple.product-type.bundle.ui-testing";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		ACCAD3DE2D37D10500A26002 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1630;
				LastUpgradeCheck = 1630;
				TargetAttributes = {
					ACCAD3E52D37D10500A26002 = {
						CreatedOnToolsVersion = 16.2;
					};
					ACCAD3F52D37D10600A26002 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = ACCAD3E52D37D10500A26002;
					};
					ACCAD3FF2D37D10600A26002 = {
						CreatedOnToolsVersion = 16.2;
						TestTargetID = ACCAD3E52D37D10500A26002;
					};
					FC6909652DD49BDF0006E601 = {
						CreatedOnToolsVersion = 16.3;
					};
					FC6909712DD49BE00006E601 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = FC6909652DD49BDF0006E601;
					};
					FC69097B2DD49BE00006E601 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = FC6909652DD49BDF0006E601;
					};
					FCB4D6112DD78BE3004F8476 = {
						CreatedOnToolsVersion = 16.3;
					};
					FCB4D6232DD78BE3004F8476 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = FCB4D6112DD78BE3004F8476;
					};
					FCB4D62D2DD78BE3004F8476 = {
						CreatedOnToolsVersion = 16.3;
						TestTargetID = FCB4D6112DD78BE3004F8476;
					};
				};
			};
			buildConfigurationList = ACCAD3E12D37D10500A26002 /* Build configuration list for PBXProject "SnapTask" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
				it,
			);
			mainGroup = ACCAD3DD2D37D10500A26002;
			minimizedProjectReferenceProxies = 1;
			preferredProjectObjectVersion = 77;
			productRefGroup = ACCAD3E72D37D10500A26002 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				ACCAD3E52D37D10500A26002 /* SnapTask */,
				ACCAD3F52D37D10600A26002 /* SnapTaskTests */,
				ACCAD3FF2D37D10600A26002 /* SnapTaskUITests */,
				FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */,
				FC6909712DD49BE00006E601 /* SnapTask Watch App Watch AppTests */,
				FC69097B2DD49BE00006E601 /* SnapTask Watch App Watch AppUITests */,
				FCB4D6112DD78BE3004F8476 /* SnapTaskMac */,
				FCB4D6232DD78BE3004F8476 /* SnapTaskMacTests */,
				FCB4D62D2DD78BE3004F8476 /* SnapTaskMacUITests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		ACCAD3E42D37D10500A26002 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3F42D37D10600A26002 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3FE2D37D10600A26002 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909642DD49BDF0006E601 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909702DD49BE00006E601 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC69097A2DD49BE00006E601 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D6102DD78BE3004F8476 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D6222DD78BE3004F8476 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D62C2DD78BE3004F8476 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		ACCAD3E22D37D10500A26002 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3F22D37D10600A26002 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		ACCAD3FC2D37D10600A26002 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909622DD49BDF0006E601 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				FC690B782DD4A0DA0006E601 /* QuoteService.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC69096E2DD49BE00006E601 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FC6909782DD49BE00006E601 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D60E2DD78BE3004F8476 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D6202DD78BE3004F8476 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		FCB4D62A2DD78BE3004F8476 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		ACCAD3F82D37D10600A26002 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = ACCAD3E52D37D10500A26002 /* SnapTask */;
			targetProxy = ACCAD3F72D37D10600A26002 /* PBXContainerItemProxy */;
		};
		ACCAD4022D37D10600A26002 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = ACCAD3E52D37D10500A26002 /* SnapTask */;
			targetProxy = ACCAD4012D37D10600A26002 /* PBXContainerItemProxy */;
		};
		FC6909742DD49BE00006E601 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */;
			targetProxy = FC6909732DD49BE00006E601 /* PBXContainerItemProxy */;
		};
		FC69097E2DD49BE00006E601 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */;
			targetProxy = FC69097D2DD49BE00006E601 /* PBXContainerItemProxy */;
		};
		FC6909852DD49BE00006E601 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = FC6909652DD49BDF0006E601 /* SnapTask Watch App Watch App */;
			targetProxy = FC6909842DD49BE00006E601 /* PBXContainerItemProxy */;
		};
		FCB4D6262DD78BE3004F8476 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = FCB4D6112DD78BE3004F8476 /* SnapTaskMac */;
			targetProxy = FCB4D6252DD78BE3004F8476 /* PBXContainerItemProxy */;
		};
		FCB4D6302DD78BE3004F8476 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = FCB4D6112DD78BE3004F8476 /* SnapTaskMac */;
			targetProxy = FCB4D62F2DD78BE3004F8476 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin XCBuildConfiguration section */
		ACCAD4082D37D10600A26002 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		ACCAD4092D37D10600A26002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		ACCAD40B2D37D10600A26002 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = SnapTask/SnapTask.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"SnapTask/Preview Content\"";
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_CFBundleDevelopmentRegion = en;
				INFOPLIST_KEY_CFBundleLocalizations = "en it";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 0.1;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		ACCAD40C2D37D10600A26002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = SnapTask/SnapTask.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "\"SnapTask/Preview Content\"";
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_CFBundleDevelopmentRegion = en;
				INFOPLIST_KEY_CFBundleLocalizations = "en it";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 0.1;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Release;
		};
		ACCAD40E2D37D10600A26002 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTaskTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTask.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTask";
			};
			name = Debug;
		};
		ACCAD40F2D37D10600A26002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 18.2;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTaskTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTask.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTask";
			};
			name = Release;
		};
		ACCAD4112D37D10600A26002 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTaskUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = SnapTask;
			};
			name = Debug;
		};
		ACCAD4122D37D10600A26002 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTaskUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				TEST_TARGET_NAME = SnapTask;
			};
			name = Release;
		};
		FC6909882DD49BE00006E601 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = "SnapTask Watch App Watch App/SnapTask Watch App Watch App.entitlements";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_CFBundleDisplayName = "SnapTask Watch App";
				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
				INFOPLIST_KEY_WKCompanionAppBundleIdentifier = com.giovanniamadei.SnapTask;
				INFOPLIST_KEY_WKRunsIndependentlyOfCompanionApp = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				WATCHOS_DEPLOYMENT_TARGET = 11.4;
			};
			name = Debug;
		};
		FC6909892DD49BE00006E601 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = "SnapTask Watch App Watch App/SnapTask Watch App Watch App.entitlements";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_CFBundleDisplayName = "SnapTask Watch App";
				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
				INFOPLIST_KEY_WKCompanionAppBundleIdentifier = com.giovanniamadei.SnapTask;
				INFOPLIST_KEY_WKRunsIndependentlyOfCompanionApp = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				WATCHOS_DEPLOYMENT_TARGET = 11.4;
			};
			name = Release;
		};
		FC69098A2DD49BE00006E601 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.giovanniamadei.SnapTask.watchkitapp.SnapTask-Watch-App-Watch-AppTests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTask Watch App Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTask Watch App Watch App";
				WATCHOS_DEPLOYMENT_TARGET = 11.4;
			};
			name = Debug;
		};
		FC69098B2DD49BE00006E601 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.giovanniamadei.SnapTask.watchkitapp.SnapTask-Watch-App-Watch-AppTests";
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTask Watch App Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTask Watch App Watch App";
				WATCHOS_DEPLOYMENT_TARGET = 11.4;
			};
			name = Release;
		};
		FC69098C2DD49BE00006E601 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = "SnapTask Watch App Watch App/Info.plist";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				WATCHOS_DEPLOYMENT_TARGET = 10.5;
			};
			name = Debug;
		};
		FC69098D2DD49BE00006E601 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = "SnapTask Watch App Watch App/Info.plist";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = watchos;
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 4;
				TEST_TARGET_NAME = "SnapTask Watch App Watch App";
				WATCHOS_DEPLOYMENT_TARGET = 10.5;
			};
			name = Release;
		};
		FCB4D6372DD78BE3004F8476 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = SnapTaskMac/SnapTaskMac.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMac;
				PRODUCT_NAME = "$(TARGET_NAME)";
				REGISTER_APP_GROUPS = YES;
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		FCB4D6382DD78BE3004F8476 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = SnapTaskMac/SnapTaskMac.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMac;
				PRODUCT_NAME = "$(TARGET_NAME)";
				REGISTER_APP_GROUPS = YES;
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		FCB4D63A2DD78BE3004F8476 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMacTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTaskMac.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTaskMac";
			};
			name = Debug;
		};
		FCB4D63B2DD78BE3004F8476 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMacTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/SnapTaskMac.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/SnapTaskMac";
			};
			name = Release;
		};
		FCB4D63D2DD78BE3004F8476 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMacUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TEST_TARGET_NAME = SnapTaskMac;
			};
			name = Debug;
		};
		FCB4D63E2DD78BE3004F8476 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = Y997848SS8;
				GENERATE_INFOPLIST_FILE = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.4;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.giovanniamadei.SnapTask.watchkitapp.SnapTaskMacUITests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = macosx;
				SWIFT_EMIT_LOC_STRINGS = NO;
				SWIFT_VERSION = 5.0;
				TEST_TARGET_NAME = SnapTaskMac;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		ACCAD3E12D37D10500A26002 /* Build configuration list for PBXProject "SnapTask" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				ACCAD4082D37D10600A26002 /* Debug */,
				ACCAD4092D37D10600A26002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		ACCAD40A2D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTask" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				ACCAD40B2D37D10600A26002 /* Debug */,
				ACCAD40C2D37D10600A26002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		ACCAD40D2D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTaskTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				ACCAD40E2D37D10600A26002 /* Debug */,
				ACCAD40F2D37D10600A26002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		ACCAD4102D37D10600A26002 /* Build configuration list for PBXNativeTarget "SnapTaskUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				ACCAD4112D37D10600A26002 /* Debug */,
				ACCAD4122D37D10600A26002 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FC69098E2DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch App" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FC6909882DD49BE00006E601 /* Debug */,
				FC6909892DD49BE00006E601 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FC69098F2DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch AppTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FC69098A2DD49BE00006E601 /* Debug */,
				FC69098B2DD49BE00006E601 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FC6909902DD49BE00006E601 /* Build configuration list for PBXNativeTarget "SnapTask Watch App Watch AppUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FC69098C2DD49BE00006E601 /* Debug */,
				FC69098D2DD49BE00006E601 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FCB4D6362DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMac" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FCB4D6372DD78BE3004F8476 /* Debug */,
				FCB4D6382DD78BE3004F8476 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FCB4D6392DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMacTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FCB4D63A2DD78BE3004F8476 /* Debug */,
				FCB4D63B2DD78BE3004F8476 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		FCB4D63C2DD78BE3004F8476 /* Build configuration list for PBXNativeTarget "SnapTaskMacUITests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				FCB4D63D2DD78BE3004F8476 /* Debug */,
				FCB4D63E2DD78BE3004F8476 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = ACCAD3DE2D37D10500A26002 /* Project object */;
}
</file>

<file path="SnapTask.xcodeproj/project.xcworkspace/contents.xcworkspacedata/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="SnapTask.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>
</file>

<file path="SnapTask.xcodeproj/xcuserdata/giovanni.xcuserdatad/xcschemes/xcschememanagement.plist/xcschememanagement.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>SnapTask.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>
</file>

<file path="SnapTask.xcodeproj/xcuserdata/giovanniamadei.xcuserdatad/xcschemes/xcschememanagement.plist/xcschememanagement.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>SnapTask Watch App Watch App.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>1</integer>
		</dict>
		<key>SnapTask.xcscheme_^#shared#^_</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
</dict>
</plist>
</file>

<file path="SnapTaskTests/SnapTaskTests.swift/SnapTaskTests.swift">
//
//  SnapTaskTests.swift
//  SnapTaskTests
//
//  Created by giovanni on 15/01/25.
//

import Testing
@testable import SnapTask

struct SnapTaskTests {

    @Test func example() async throws {
        // Write your test here and use APIs like `#expect(...)` to check expected conditions.
    }

}
</file>

<file path="SnapTaskUITests/SnapTaskUITests.swift/SnapTaskUITests.swift">
//
//  SnapTaskUITests.swift
//  SnapTaskUITests
//
//  Created by giovanni on 15/01/25.
//

import XCTest

final class SnapTaskUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
            // This measures how long it takes to launch your application.
            measure(metrics: [XCTApplicationLaunchMetric()]) {
                XCUIApplication().launch()
            }
        }
    }
}
</file>

<file path="SnapTaskUITests/SnapTaskUITestsLaunchTests.swift/SnapTaskUITestsLaunchTests.swift">
//
//  SnapTaskUITestsLaunchTests.swift
//  SnapTaskUITests
//
//  Created by giovanni on 15/01/25.
//

import XCTest

final class SnapTaskUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
</file>

</files>
